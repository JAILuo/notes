
<!doctype html>
<html lang="en" class="no-js">
  <head>
    
      <meta charset="utf-8">
      <meta name="viewport" content="width=device-width,initial-scale=1">
      
      
      
        <link rel="canonical" href="https://jailuo.github.io/notes/OpenCamp/2025%20Learning-C/learning-c.html">
      
      
      
      
      <link rel="icon" href="../../assets/images/favicon.png">
      <meta name="generator" content="mkdocs-1.6.1, mkdocs-material-9.5.48">
    
    
      
        <title>Stage 1: Basics - Messy Notes</title>
      
    
    
      <link rel="stylesheet" href="../../assets/stylesheets/main.6f8fc17f.min.css">
      
        
        <link rel="stylesheet" href="../../assets/stylesheets/palette.06af60db.min.css">
      
      


    
    
      
    
    
      
        
        
        <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
        <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Roboto:300,300i,400,400i,700,700i%7CRoboto+Mono:400,400i,700,700i&display=fallback">
        <style>:root{--md-text-font:"Roboto";--md-code-font:"Roboto Mono"}</style>
      
    
    
      <link rel="stylesheet" href="../../css/timeago.css">
    
    <script>__md_scope=new URL("../..",location),__md_hash=e=>[...e].reduce(((e,_)=>(e<<5)-e+_.charCodeAt(0)),0),__md_get=(e,_=localStorage,t=__md_scope)=>JSON.parse(_.getItem(t.pathname+"."+e)),__md_set=(e,_,t=localStorage,a=__md_scope)=>{try{t.setItem(a.pathname+"."+e,JSON.stringify(_))}catch(e){}}</script>
    
      

    
    
    
  </head>
  
  
    
    
      
    
    
    
    
    <body dir="ltr" data-md-color-scheme="default" data-md-color-primary="indigo" data-md-color-accent="indigo">
  
    
    <input class="md-toggle" data-md-toggle="drawer" type="checkbox" id="__drawer" autocomplete="off">
    <input class="md-toggle" data-md-toggle="search" type="checkbox" id="__search" autocomplete="off">
    <label class="md-overlay" for="__drawer"></label>
    <div data-md-component="skip">
      
        
        <a href="#stage-1-basics" class="md-skip">
          Skip to content
        </a>
      
    </div>
    <div data-md-component="announce">
      
    </div>
    
    
      

  

<header class="md-header md-header--shadow" data-md-component="header">
  <nav class="md-header__inner md-grid" aria-label="Header">
    <a href="../../index.html" title="Messy Notes" class="md-header__button md-logo" aria-label="Messy Notes" data-md-component="logo">
      
  
  <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M12 8a3 3 0 0 0 3-3 3 3 0 0 0-3-3 3 3 0 0 0-3 3 3 3 0 0 0 3 3m0 3.54C9.64 9.35 6.5 8 3 8v11c3.5 0 6.64 1.35 9 3.54 2.36-2.19 5.5-3.54 9-3.54V8c-3.5 0-6.64 1.35-9 3.54"/></svg>

    </a>
    <label class="md-header__button md-icon" for="__drawer">
      
      <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M3 6h18v2H3zm0 5h18v2H3zm0 5h18v2H3z"/></svg>
    </label>
    <div class="md-header__title" data-md-component="header-title">
      <div class="md-header__ellipsis">
        <div class="md-header__topic">
          <span class="md-ellipsis">
            Messy Notes
          </span>
        </div>
        <div class="md-header__topic" data-md-component="header-topic">
          <span class="md-ellipsis">
            
              Stage 1: Basics
            
          </span>
        </div>
      </div>
    </div>
    
      
        <form class="md-header__option" data-md-component="palette">
  
    
    
    
    <input class="md-option" data-md-color-media="" data-md-color-scheme="default" data-md-color-primary="indigo" data-md-color-accent="indigo"  aria-label="Switch to dark mode"  type="radio" name="__palette" id="__palette_0">
    
      <label class="md-header__button md-icon" title="Switch to dark mode" for="__palette_1" hidden>
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="m17.75 4.09-2.53 1.94.91 3.06-2.63-1.81-2.63 1.81.91-3.06-2.53-1.94L12.44 4l1.06-3 1.06 3zm3.5 6.91-1.64 1.25.59 1.98-1.7-1.17-1.7 1.17.59-1.98L15.75 11l2.06-.05L18.5 9l.69 1.95zm-2.28 4.95c.83-.08 1.72 1.1 1.19 1.85-.32.45-.66.87-1.08 1.27C15.17 23 8.84 23 4.94 19.07c-3.91-3.9-3.91-10.24 0-14.14.4-.4.82-.76 1.27-1.08.75-.53 1.93.36 1.85 1.19-.27 2.86.69 5.83 2.89 8.02a9.96 9.96 0 0 0 8.02 2.89m-1.64 2.02a12.08 12.08 0 0 1-7.8-3.47c-2.17-2.19-3.33-5-3.49-7.82-2.81 3.14-2.7 7.96.31 10.98 3.02 3.01 7.84 3.12 10.98.31"/></svg>
      </label>
    
  
    
    
    
    <input class="md-option" data-md-color-media="" data-md-color-scheme="slate" data-md-color-primary="indigo" data-md-color-accent="indigo"  aria-label="Switch to light mode"  type="radio" name="__palette" id="__palette_1">
    
      <label class="md-header__button md-icon" title="Switch to light mode" for="__palette_0" hidden>
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M12 7a5 5 0 0 1 5 5 5 5 0 0 1-5 5 5 5 0 0 1-5-5 5 5 0 0 1 5-5m0 2a3 3 0 0 0-3 3 3 3 0 0 0 3 3 3 3 0 0 0 3-3 3 3 0 0 0-3-3m0-7 2.39 3.42C13.65 5.15 12.84 5 12 5s-1.65.15-2.39.42zM3.34 7l4.16-.35A7.2 7.2 0 0 0 5.94 8.5c-.44.74-.69 1.5-.83 2.29zm.02 10 1.76-3.77a7.131 7.131 0 0 0 2.38 4.14zM20.65 7l-1.77 3.79a7.02 7.02 0 0 0-2.38-4.15zm-.01 10-4.14.36c.59-.51 1.12-1.14 1.54-1.86.42-.73.69-1.5.83-2.29zM12 22l-2.41-3.44c.74.27 1.55.44 2.41.44.82 0 1.63-.17 2.37-.44z"/></svg>
      </label>
    
  
</form>
      
    
    
      <script>var palette=__md_get("__palette");if(palette&&palette.color){if("(prefers-color-scheme)"===palette.color.media){var media=matchMedia("(prefers-color-scheme: light)"),input=document.querySelector(media.matches?"[data-md-color-media='(prefers-color-scheme: light)']":"[data-md-color-media='(prefers-color-scheme: dark)']");palette.color.media=input.getAttribute("data-md-color-media"),palette.color.scheme=input.getAttribute("data-md-color-scheme"),palette.color.primary=input.getAttribute("data-md-color-primary"),palette.color.accent=input.getAttribute("data-md-color-accent")}for(var[key,value]of Object.entries(palette.color))document.body.setAttribute("data-md-color-"+key,value)}</script>
    
    
    
      <label class="md-header__button md-icon" for="__search">
        
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0 1 16 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.52 6.52 0 0 1 9.5 16 6.5 6.5 0 0 1 3 9.5 6.5 6.5 0 0 1 9.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5"/></svg>
      </label>
      <div class="md-search" data-md-component="search" role="dialog">
  <label class="md-search__overlay" for="__search"></label>
  <div class="md-search__inner" role="search">
    <form class="md-search__form" name="search">
      <input type="text" class="md-search__input" name="query" aria-label="Search" placeholder="Search" autocapitalize="off" autocorrect="off" autocomplete="off" spellcheck="false" data-md-component="search-query" required>
      <label class="md-search__icon md-icon" for="__search">
        
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0 1 16 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.52 6.52 0 0 1 9.5 16 6.5 6.5 0 0 1 3 9.5 6.5 6.5 0 0 1 9.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5"/></svg>
        
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 320 512"><!--! Font Awesome Free 6.7.1 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2024 Fonticons, Inc.--><path d="M41.4 233.4c-12.5 12.5-12.5 32.8 0 45.3l160 160c12.5 12.5 32.8 12.5 45.3 0s12.5-32.8 0-45.3L109.3 256l137.3-137.4c12.5-12.5 12.5-32.8 0-45.3s-32.8-12.5-45.3 0l-160 160z"/></svg>
      </label>
      <nav class="md-search__options" aria-label="Search">
        
        <button type="reset" class="md-search__icon md-icon" title="Clear" aria-label="Clear" tabindex="-1">
          
          <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M19 6.41 17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12z"/></svg>
        </button>
      </nav>
      
    </form>
    <div class="md-search__output">
      <div class="md-search__scrollwrap" tabindex="0" data-md-scrollfix>
        <div class="md-search-result" data-md-component="search-result">
          <div class="md-search-result__meta">
            Initializing search
          </div>
          <ol class="md-search-result__list" role="presentation"></ol>
        </div>
      </div>
    </div>
  </div>
</div>
    
    
      <div class="md-header__source">
        <a href="https://github.com/JAILuo/notes" title="Go to repository" class="md-source" data-md-component="source">
  <div class="md-source__icon md-icon">
    
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 448 512"><!--! Font Awesome Free 6.7.1 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2024 Fonticons, Inc.--><path d="M439.55 236.05 244 40.45a28.87 28.87 0 0 0-40.81 0l-40.66 40.63 51.52 51.52c27.06-9.14 52.68 16.77 43.39 43.68l49.66 49.66c34.23-11.8 61.18 31 35.47 56.69-26.49 26.49-70.21-2.87-56-37.34L240.22 199v121.85c25.3 12.54 22.26 41.85 9.08 55a34.34 34.34 0 0 1-48.55 0c-17.57-17.6-11.07-46.91 11.25-56v-123c-20.8-8.51-24.6-30.74-18.64-45L142.57 101 8.45 235.14a28.86 28.86 0 0 0 0 40.81l195.61 195.6a28.86 28.86 0 0 0 40.8 0l194.69-194.69a28.86 28.86 0 0 0 0-40.81"/></svg>
  </div>
  <div class="md-source__repository">
    GitHub
  </div>
</a>
      </div>
    
  </nav>
  
</header>
    
    <div class="md-container" data-md-component="container">
      
      
        
          
        
      
      <main class="md-main" data-md-component="main">
        <div class="md-main__inner md-grid">
          
            
              
              <div class="md-sidebar md-sidebar--primary" data-md-component="sidebar" data-md-type="navigation" >
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    



<nav class="md-nav md-nav--primary" aria-label="Navigation" data-md-level="0">
  <label class="md-nav__title" for="__drawer">
    <a href="../../index.html" title="Messy Notes" class="md-nav__button md-logo" aria-label="Messy Notes" data-md-component="logo">
      
  
  <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M12 8a3 3 0 0 0 3-3 3 3 0 0 0-3-3 3 3 0 0 0-3 3 3 3 0 0 0 3 3m0 3.54C9.64 9.35 6.5 8 3 8v11c3.5 0 6.64 1.35 9 3.54 2.36-2.19 5.5-3.54 9-3.54V8c-3.5 0-6.64 1.35-9 3.54"/></svg>

    </a>
    Messy Notes
  </label>
  
    <div class="md-nav__source">
      <a href="https://github.com/JAILuo/notes" title="Go to repository" class="md-source" data-md-component="source">
  <div class="md-source__icon md-icon">
    
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 448 512"><!--! Font Awesome Free 6.7.1 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2024 Fonticons, Inc.--><path d="M439.55 236.05 244 40.45a28.87 28.87 0 0 0-40.81 0l-40.66 40.63 51.52 51.52c27.06-9.14 52.68 16.77 43.39 43.68l49.66 49.66c34.23-11.8 61.18 31 35.47 56.69-26.49 26.49-70.21-2.87-56-37.34L240.22 199v121.85c25.3 12.54 22.26 41.85 9.08 55a34.34 34.34 0 0 1-48.55 0c-17.57-17.6-11.07-46.91 11.25-56v-123c-20.8-8.51-24.6-30.74-18.64-45L142.57 101 8.45 235.14a28.86 28.86 0 0 0 0 40.81l195.61 195.6a28.86 28.86 0 0 0 40.8 0l194.69-194.69a28.86 28.86 0 0 0 0-40.81"/></svg>
  </div>
  <div class="md-source__repository">
    GitHub
  </div>
</a>
    </div>
  
  <ul class="md-nav__list" data-md-scrollfix>
    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../../index.html" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    首页
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    
    
    
    
    <li class="md-nav__item md-nav__item--nested">
      
        
        
        <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_2" >
        
          
          <label class="md-nav__link" for="__nav_2" id="__nav_2_label" tabindex="0">
            
  
  <span class="md-ellipsis">
    Article
  </span>
  

            <span class="md-nav__icon md-icon"></span>
          </label>
        
        <nav class="md-nav" data-md-level="1" aria-labelledby="__nav_2_label" aria-expanded="false">
          <label class="md-nav__title" for="__nav_2">
            <span class="md-nav__icon md-icon"></span>
            Article
          </label>
          <ul class="md-nav__list" data-md-scrollfix>
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="/article/concurrency sumary/summary.md" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    concurrency-summary
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="/article/toolchain/toolchain.mc" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    toolchain
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="/article/mount/mount.md" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    mount
  </span>
  

      </a>
    </li>
  

              
            
          </ul>
        </nav>
      
    </li>
  

    
      
      
  
  
  
  
    
    
    
    
    <li class="md-nav__item md-nav__item--nested">
      
        
        
        <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_3" >
        
          
          <label class="md-nav__link" for="__nav_3" id="__nav_3_label" tabindex="0">
            
  
  <span class="md-ellipsis">
    Course
  </span>
  

            <span class="md-nav__icon md-icon"></span>
          </label>
        
        <nav class="md-nav" data-md-level="1" aria-labelledby="__nav_3_label" aria-expanded="false">
          <label class="md-nav__title" for="__nav_3">
            <span class="md-nav__icon md-icon"></span>
            Course
          </label>
          <ul class="md-nav__list" data-md-scrollfix>
            
              
                
  
  
  
  
    
    
    
    
    <li class="md-nav__item md-nav__item--nested">
      
        
        
        <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_3_1" >
        
          
          <label class="md-nav__link" for="__nav_3_1" id="__nav_3_1_label" tabindex="0">
            
  
  <span class="md-ellipsis">
    University Course
  </span>
  

            <span class="md-nav__icon md-icon"></span>
          </label>
        
        <nav class="md-nav" data-md-level="2" aria-labelledby="__nav_3_1_label" aria-expanded="false">
          <label class="md-nav__title" for="__nav_3_1">
            <span class="md-nav__icon md-icon"></span>
            University Course
          </label>
          <ul class="md-nav__list" data-md-scrollfix>
            
              
                
  
  
  
  
    
    
    
    
    <li class="md-nav__item md-nav__item--nested">
      
        
        
        <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_3_1_1" >
        
          
          <label class="md-nav__link" for="__nav_3_1_1" id="__nav_3_1_1_label" tabindex="0">
            
  
  <span class="md-ellipsis">
    jyy OS2024
  </span>
  

            <span class="md-nav__icon md-icon"></span>
          </label>
        
        <nav class="md-nav" data-md-level="3" aria-labelledby="__nav_3_1_1_label" aria-expanded="false">
          <label class="md-nav__title" for="__nav_3_1_1">
            <span class="md-nav__icon md-icon"></span>
            jyy OS2024
          </label>
          <ul class="md-nav__list" data-md-scrollfix>
            
              
                
  
  
  
  
    
    
    
    
    <li class="md-nav__item md-nav__item--nested">
      
        
        
        <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_3_1_1_1" >
        
          
          <label class="md-nav__link" for="__nav_3_1_1_1" id="__nav_3_1_1_1_label" tabindex="0">
            
  
  <span class="md-ellipsis">
    course note
  </span>
  

            <span class="md-nav__icon md-icon"></span>
          </label>
        
        <nav class="md-nav" data-md-level="4" aria-labelledby="__nav_3_1_1_1_label" aria-expanded="false">
          <label class="md-nav__title" for="__nav_3_1_1_1">
            <span class="md-nav__icon md-icon"></span>
            course note
          </label>
          <ul class="md-nav__list" data-md-scrollfix>
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../Course/University%20Course/jyy%20OS2024/cousre%20note/1.%20introduction/introduction.html" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    introduction
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../Course/University%20Course/jyy%20OS2024/cousre%20note/2.%20concurrency/concurrency.html" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    concurrency
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../Course/University%20Course/jyy%20OS2024/cousre%20note/3.%20virtualization/virtualization.html" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    virtualization
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../Course/University%20Course/jyy%20OS2024/cousre%20note/4.%20kernel/kernel.html" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    kernel
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../Course/University%20Course/jyy%20OS2024/cousre%20note/5.%20persistence/persistence.html" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    persistence
  </span>
  

      </a>
    </li>
  

              
            
          </ul>
        </nav>
      
    </li>
  

              
            
              
                
  
  
  
  
    
    
    
    
    <li class="md-nav__item md-nav__item--nested">
      
        
        
        <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_3_1_1_2" >
        
          
          <label class="md-nav__link" for="__nav_3_1_1_2" id="__nav_3_1_1_2_label" tabindex="0">
            
  
  <span class="md-ellipsis">
    Mini Labs
  </span>
  

            <span class="md-nav__icon md-icon"></span>
          </label>
        
        <nav class="md-nav" data-md-level="4" aria-labelledby="__nav_3_1_1_2_label" aria-expanded="false">
          <label class="md-nav__title" for="__nav_3_1_1_2">
            <span class="md-nav__icon md-icon"></span>
            Mini Labs
          </label>
          <ul class="md-nav__list" data-md-scrollfix>
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../Course/University%20Course/jyy%20OS2024/Mini%20Labs/M1/M1.html" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    M1
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../Course/University%20Course/jyy%20OS2024/Mini%20Labs/M2/M2.html" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    M2
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../Course/University%20Course/jyy%20OS2024/Mini%20Labs/M3/M3.html" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    M3
  </span>
  

      </a>
    </li>
  

              
            
          </ul>
        </nav>
      
    </li>
  

              
            
              
                
  
  
  
  
    
    
    
    
    <li class="md-nav__item md-nav__item--nested">
      
        
        
        <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_3_1_1_3" >
        
          
          <label class="md-nav__link" for="__nav_3_1_1_3" id="__nav_3_1_1_3_label" tabindex="0">
            
  
  <span class="md-ellipsis">
    OS Labs
  </span>
  

            <span class="md-nav__icon md-icon"></span>
          </label>
        
        <nav class="md-nav" data-md-level="4" aria-labelledby="__nav_3_1_1_3_label" aria-expanded="false">
          <label class="md-nav__title" for="__nav_3_1_1_3">
            <span class="md-nav__icon md-icon"></span>
            OS Labs
          </label>
          <ul class="md-nav__list" data-md-scrollfix>
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../Course/University%20Course/jyy%20OS2024/OS%20Labs/L0/L0.html" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    L0
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../Course/University%20Course/jyy%20OS2024/OS%20Labs/L1/L1.html" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    L1
  </span>
  

      </a>
    </li>
  

              
            
          </ul>
        </nav>
      
    </li>
  

              
            
          </ul>
        </nav>
      
    </li>
  

              
            
          </ul>
        </nav>
      
    </li>
  

              
            
              
                
  
  
  
  
    
    
    
    
    <li class="md-nav__item md-nav__item--nested">
      
        
        
        <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_3_2" >
        
          
          <label class="md-nav__link" for="__nav_3_2" id="__nav_3_2_label" tabindex="0">
            
  
  <span class="md-ellipsis">
    GeekTime
  </span>
  

            <span class="md-nav__icon md-icon"></span>
          </label>
        
        <nav class="md-nav" data-md-level="2" aria-labelledby="__nav_3_2_label" aria-expanded="false">
          <label class="md-nav__title" for="__nav_3_2">
            <span class="md-nav__icon md-icon"></span>
            GeekTime
          </label>
          <ul class="md-nav__list" data-md-scrollfix>
            
              
                
  
  
  
  
    
    
    
    
    <li class="md-nav__item md-nav__item--nested">
      
        
        
        <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_3_2_1" >
        
          
          <label class="md-nav__link" for="__nav_3_2_1" id="__nav_3_2_1_label" tabindex="0">
            
  
  <span class="md-ellipsis">
    深入理解计算机组成原理
  </span>
  

            <span class="md-nav__icon md-icon"></span>
          </label>
        
        <nav class="md-nav" data-md-level="3" aria-labelledby="__nav_3_2_1_label" aria-expanded="false">
          <label class="md-nav__title" for="__nav_3_2_1">
            <span class="md-nav__icon md-icon"></span>
            深入理解计算机组成原理
          </label>
          <ul class="md-nav__list" data-md-scrollfix>
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../Course/GeekTime/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/%E4%B8%80%E5%91%A8%E7%9B%AE/1.%20%E6%8C%87%E4%BB%A4%E4%B8%8E%E8%BF%90%E7%AE%97/%E6%8C%87%E4%BB%A4%E4%B8%8E%E8%BF%90%E7%AE%97.html" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    1. 指令与运算
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../Course/GeekTime/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/%E4%B8%80%E5%91%A8%E7%9B%AE/2.%20%E5%A4%84%E7%90%86%E5%99%A8/%E5%A4%84%E7%90%86%E5%99%A8.html" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    2. 处理器
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../Course/GeekTime/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/%E4%B8%80%E5%91%A8%E7%9B%AE/3.%20%E5%AD%98%E5%82%A8%E4%B8%8EIO%E7%B3%BB%E7%BB%9F/%E5%AD%98%E5%82%A8%E4%B8%8EIO%E7%B3%BB%E7%BB%9F.html" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    3. 存储与IO系统
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../Course/GeekTime/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/%E4%B8%80%E5%91%A8%E7%9B%AE/4.%20%E5%BA%94%E7%94%A8/%E5%BA%94%E7%94%A8.html" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    4. 应用
  </span>
  

      </a>
    </li>
  

              
            
          </ul>
        </nav>
      
    </li>
  

              
            
              
                
  
  
  
  
    
    
    
    
    <li class="md-nav__item md-nav__item--nested">
      
        
        
        <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_3_2_2" >
        
          
          <label class="md-nav__link" for="__nav_3_2_2" id="__nav_3_2_2_label" tabindex="0">
            
  
  <span class="md-ellipsis">
    计算基础实战课
  </span>
  

            <span class="md-nav__icon md-icon"></span>
          </label>
        
        <nav class="md-nav" data-md-level="3" aria-labelledby="__nav_3_2_2_label" aria-expanded="false">
          <label class="md-nav__title" for="__nav_3_2_2">
            <span class="md-nav__icon md-icon"></span>
            计算基础实战课
          </label>
          <ul class="md-nav__list" data-md-scrollfix>
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../Course/GeekTime/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80%E5%AE%9E%E6%88%98%E8%AF%BE/1.%20MiniCPU%E8%AE%BE%E8%AE%A1/MiniCPU%E8%AE%BE%E8%AE%A1.html" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    1. MiniCPU设计
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../Course/GeekTime/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80%E5%AE%9E%E6%88%98%E8%AF%BE/2.%20%E8%AF%AD%E8%A8%80%E5%92%8C%E6%8C%87%E4%BB%A4/%E8%AF%AD%E8%A8%80%E5%92%8C%E6%8C%87%E4%BB%A4.html" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    2. 语言和指令
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../Course/GeekTime/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80%E5%AE%9E%E6%88%98%E8%AF%BE/3.%20%E5%BA%94%E7%94%A8%E5%92%8C%E5%86%85%E5%AD%98/%E5%BA%94%E7%94%A8%E5%92%8C%E5%86%85%E5%AD%98.html" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    3. 应用和内存
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../Course/GeekTime/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80%E5%AE%9E%E6%88%98%E8%AF%BE/4.%20IO%E4%B8%8E%E6%96%87%E4%BB%B6/IO%E5%92%8C%E6%96%87%E4%BB%B6.html" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    4. IO与文件
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../Course/GeekTime/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80%E5%AE%9E%E6%88%98%E8%AF%BE/5.%20%E7%BB%BC%E5%90%88%E5%BA%94%E7%94%A8/synthesis.html" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    5. 综合应用
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../Course/GeekTime/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80%E5%AE%9E%E6%88%98%E8%AF%BE/%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE%E5%92%8C%E5%B7%A5%E5%85%B7%E9%93%BE/%E7%9B%B8%E5%85%B3%E9%85%8D%E7%BD%AE.html" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    环境配置和工具链
  </span>
  

      </a>
    </li>
  

              
            
          </ul>
        </nav>
      
    </li>
  

              
            
          </ul>
        </nav>
      
    </li>
  

              
            
          </ul>
        </nav>
      
    </li>
  

    
      
      
  
  
  
  
    
    
    
    
    <li class="md-nav__item md-nav__item--nested">
      
        
        
        <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_4" >
        
          
          <label class="md-nav__link" for="__nav_4" id="__nav_4_label" tabindex="0">
            
  
  <span class="md-ellipsis">
    ysyx
  </span>
  

            <span class="md-nav__icon md-icon"></span>
          </label>
        
        <nav class="md-nav" data-md-level="1" aria-labelledby="__nav_4_label" aria-expanded="false">
          <label class="md-nav__title" for="__nav_4">
            <span class="md-nav__icon md-icon"></span>
            ysyx
          </label>
          <ul class="md-nav__list" data-md-scrollfix>
            
              
                
  
  
  
  
    
    
    
    
    <li class="md-nav__item md-nav__item--nested">
      
        
        
        <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_4_1" >
        
          
          <label class="md-nav__link" for="__nav_4_1" id="__nav_4_1_label" tabindex="0">
            
  
  <span class="md-ellipsis">
    NJU-ICS2023-PA
  </span>
  

            <span class="md-nav__icon md-icon"></span>
          </label>
        
        <nav class="md-nav" data-md-level="2" aria-labelledby="__nav_4_1_label" aria-expanded="false">
          <label class="md-nav__title" for="__nav_4_1">
            <span class="md-nav__icon md-icon"></span>
            NJU-ICS2023-PA
          </label>
          <ul class="md-nav__list" data-md-scrollfix>
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../ysyx/pa/pa1/pa1.html" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    PA1
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../ysyx/pa/pa2/pa2.html" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    PA2
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../ysyx/pa/pa3/pa3.html" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    PA3
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../ysyx/pa/pa4/pa4.html" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    PA4
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../ysyx/pa/c_marco/macro.html" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    C Macro
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../ysyx/pa/summary/summary.html" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Summary
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../ysyx/pa/Linux_porting/porting.html" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Linux Porting
  </span>
  

      </a>
    </li>
  

              
            
          </ul>
        </nav>
      
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../ysyx/digital-circuit/digital%20circuit.html" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Digital Circuit
  </span>
  

      </a>
    </li>
  

              
            
          </ul>
        </nav>
      
    </li>
  

    
      
      
  
  
  
  
    
    
    
    
    <li class="md-nav__item md-nav__item--nested">
      
        
        
        <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_5" >
        
          
          <label class="md-nav__link" for="__nav_5" id="__nav_5_label" tabindex="0">
            
  
  <span class="md-ellipsis">
    Tools
  </span>
  

            <span class="md-nav__icon md-icon"></span>
          </label>
        
        <nav class="md-nav" data-md-level="1" aria-labelledby="__nav_5_label" aria-expanded="false">
          <label class="md-nav__title" for="__nav_5">
            <span class="md-nav__icon md-icon"></span>
            Tools
          </label>
          <ul class="md-nav__list" data-md-scrollfix>
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../Tools/GDB/GDB.html" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    GDB
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    
    
    
    
    <li class="md-nav__item md-nav__item--nested">
      
        
        
        <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_5_2" >
        
          
          <label class="md-nav__link" for="__nav_5_2" id="__nav_5_2_label" tabindex="0">
            
  
  <span class="md-ellipsis">
    Vim
  </span>
  

            <span class="md-nav__icon md-icon"></span>
          </label>
        
        <nav class="md-nav" data-md-level="2" aria-labelledby="__nav_5_2_label" aria-expanded="false">
          <label class="md-nav__title" for="__nav_5_2">
            <span class="md-nav__icon md-icon"></span>
            Vim
          </label>
          <ul class="md-nav__list" data-md-scrollfix>
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../Tools/vim/usage/usage.html" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    usage
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../Tools/vim/vim-plugin/vim.html" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    vim-plugin
  </span>
  

      </a>
    </li>
  

              
            
          </ul>
        </nav>
      
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../Tools/doxygen/doxygen.html" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    doxygen
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../Tools/gcc/gcc.html" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    gcc
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../Tools/Git/Git.html" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Git
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../Tools/md2slider/md2slider.html" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    md2slider
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../Tools/tmux/tmux.html" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    tmux
  </span>
  

      </a>
    </li>
  

              
            
          </ul>
        </nav>
      
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../../Todo%20List/todo.html" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    TODO List
  </span>
  

      </a>
    </li>
  

    
  </ul>
</nav>
                  </div>
                </div>
              </div>
            
            
              
              <div class="md-sidebar md-sidebar--secondary" data-md-component="sidebar" data-md-type="toc" >
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    

<nav class="md-nav md-nav--secondary" aria-label="Table of contents">
  
  
  
    
  
  
    <label class="md-nav__title" for="__toc">
      <span class="md-nav__icon md-icon"></span>
      Table of contents
    </label>
    <ul class="md-nav__list" data-md-component="toc" data-md-scrollfix>
      
        <li class="md-nav__item">
  <a href="#_1" class="md-nav__link">
    <span class="md-ellipsis">
      题目汇总
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#01_insert_sort-" class="md-nav__link">
    <span class="md-ellipsis">
      01_insert_sort - 插入排序
    </span>
  </a>
  
    <nav class="md-nav" aria-label="01_insert_sort - 插入排序">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_2" class="md-nav__link">
    <span class="md-ellipsis">
      第一层：建立牢固的直觉认知（像打扑克牌一样）
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_3" class="md-nav__link">
    <span class="md-ellipsis">
      第二层：图文并茂，一步步“慢放”
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#c" class="md-nav__link">
    <span class="md-ellipsis">
      第三层：写出带详细追踪的C语言代码
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_4" class="md-nav__link">
    <span class="md-ellipsis">
      第四层：专业角度的深度分析（这才是“专业”的体现）
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_5" class="md-nav__link">
    <span class="md-ellipsis">
      总结：如何达到“专业理解”
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#02_merge_sort" class="md-nav__link">
    <span class="md-ellipsis">
      02_merge_sort
    </span>
  </a>
  
    <nav class="md-nav" aria-label="02_merge_sort">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_6" class="md-nav__link">
    <span class="md-ellipsis">
      第一阶段：建立直观理解
    </span>
  </a>
  
    <nav class="md-nav" aria-label="第一阶段：建立直观理解">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#11-" class="md-nav__link">
    <span class="md-ellipsis">
      1.1 核心思想 - "分而治之"
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#12" class="md-nav__link">
    <span class="md-ellipsis">
      1.2 为什么"合并"是关键？
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_7" class="md-nav__link">
    <span class="md-ellipsis">
      第二阶段：详细分解合并过程
    </span>
  </a>
  
    <nav class="md-nav" aria-label="第二阶段：详细分解合并过程">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_8" class="md-nav__link">
    <span class="md-ellipsis">
      合并的详细步骤：
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_9" class="md-nav__link">
    <span class="md-ellipsis">
      第三阶段：在归并排序中的完整流程
    </span>
  </a>
  
    <nav class="md-nav" aria-label="第三阶段：在归并排序中的完整流程">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_10" class="md-nav__link">
    <span class="md-ellipsis">
      分解阶段（递归拆分）：
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_11" class="md-nav__link">
    <span class="md-ellipsis">
      合并阶段（从底部开始）：
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#5-24" class="md-nav__link">
    <span class="md-ellipsis">
      详细演示合并 [5] 和 [2,4]：
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_12" class="md-nav__link">
    <span class="md-ellipsis">
      第四阶段：代码的逐行解释
    </span>
  </a>
  
    <nav class="md-nav" aria-label="第四阶段：代码的逐行解释">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_13" class="md-nav__link">
    <span class="md-ellipsis">
      关键理解点：
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_14" class="md-nav__link">
    <span class="md-ellipsis">
      第五阶段：可视化类比
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_15" class="md-nav__link">
    <span class="md-ellipsis">
      总结：理解合并过程的要点
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_16" class="md-nav__link">
    <span class="md-ellipsis">
      时间/空间
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#03_quick_sort" class="md-nav__link">
    <span class="md-ellipsis">
      03_quick_sort
    </span>
  </a>
  
    <nav class="md-nav" aria-label="03_quick_sort">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_17" class="md-nav__link">
    <span class="md-ellipsis">
      第一层：建立牢固的直觉认知（像整理书架一样）
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_18" class="md-nav__link">
    <span class="md-ellipsis">
      第二层：图文并茂，一步步"慢放"
    </span>
  </a>
  
    <nav class="md-nav" aria-label="第二层：图文并茂，一步步"慢放"">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_19" class="md-nav__link">
    <span class="md-ellipsis">
      第一次分区过程：
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_20" class="md-nav__link">
    <span class="md-ellipsis">
      递归处理左右分区：
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#c_1" class="md-nav__link">
    <span class="md-ellipsis">
      第三层：写出带详细追踪的C语言代码
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_21" class="md-nav__link">
    <span class="md-ellipsis">
      第四层：专业角度的深度分析
    </span>
  </a>
  
    <nav class="md-nav" aria-label="第四层：专业角度的深度分析">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#41" class="md-nav__link">
    <span class="md-ellipsis">
      4.1 时间复杂度分析
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#42" class="md-nav__link">
    <span class="md-ellipsis">
      4.2 空间复杂度
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#43" class="md-nav__link">
    <span class="md-ellipsis">
      4.3 稳定性
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#44" class="md-nav__link">
    <span class="md-ellipsis">
      4.4 基准选择策略
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#45" class="md-nav__link">
    <span class="md-ellipsis">
      4.5 优化技巧
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#46" class="md-nav__link">
    <span class="md-ellipsis">
      4.6 与归并排序的比较
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_22" class="md-nav__link">
    <span class="md-ellipsis">
      第五层：关键洞察与记忆技巧
    </span>
  </a>
  
    <nav class="md-nav" aria-label="第五层：关键洞察与记忆技巧">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#51" class="md-nav__link">
    <span class="md-ellipsis">
      5.1 核心思想总结
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#52" class="md-nav__link">
    <span class="md-ellipsis">
      5.2 分区过程的关键点
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#53" class="md-nav__link">
    <span class="md-ellipsis">
      5.3 实际应用建议
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_23" class="md-nav__link">
    <span class="md-ellipsis">
      总结：快速排序的专业理解路径
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#partition" class="md-nav__link">
    <span class="md-ellipsis">
      深入理解 partition 函数中的循环条件
    </span>
  </a>
  
    <nav class="md-nav" aria-label="深入理解 partition 函数中的循环条件">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_24" class="md-nav__link">
    <span class="md-ellipsis">
      循环条件的意义
    </span>
  </a>
  
    <nav class="md-nav" aria-label="循环条件的意义">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_25" class="md-nav__link">
    <span class="md-ellipsis">
      执行过程：
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#i-j-i-j" class="md-nav__link">
    <span class="md-ellipsis">
      为什么需要 i &lt;= j 而不是 i &lt; j
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#i-j" class="md-nav__link">
    <span class="md-ellipsis">
      内层循环中的 i &lt;= j 条件
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_26" class="md-nav__link">
    <span class="md-ellipsis">
      完整的执行流程示例
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#i-j_1" class="md-nav__link">
    <span class="md-ellipsis">
      如果改为 i &lt; j 会发生什么？
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_27" class="md-nav__link">
    <span class="md-ellipsis">
      总结
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_28" class="md-nav__link">
    <span class="md-ellipsis">
      代码
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#04_linear_search" class="md-nav__link">
    <span class="md-ellipsis">
      04_linear_search
    </span>
  </a>
  
    <nav class="md-nav" aria-label="04_linear_search">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#k" class="md-nav__link">
    <span class="md-ellipsis">
      基于快速选择的第k小元素查找算法
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#05_binary_search" class="md-nav__link">
    <span class="md-ellipsis">
      05_binary_search
    </span>
  </a>
  
    <nav class="md-nav" aria-label="05_binary_search">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_29" class="md-nav__link">
    <span class="md-ellipsis">
      问题一：返回第一个匹配元素的二分查找
    </span>
  </a>
  
    <nav class="md-nav" aria-label="问题一：返回第一个匹配元素的二分查找">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_30" class="md-nav__link">
    <span class="md-ellipsis">
      算法思路
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_31" class="md-nav__link">
    <span class="md-ellipsis">
      代码实现
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_32" class="md-nav__link">
    <span class="md-ellipsis">
      算法分析
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_33" class="md-nav__link">
    <span class="md-ellipsis">
      问题二：用二分查找求平方根
    </span>
  </a>
  
    <nav class="md-nav" aria-label="问题二：用二分查找求平方根">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_34" class="md-nav__link">
    <span class="md-ellipsis">
      算法思路
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_35" class="md-nav__link">
    <span class="md-ellipsis">
      代码实现
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_36" class="md-nav__link">
    <span class="md-ellipsis">
      迭代次数分析
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_37" class="md-nav__link">
    <span class="md-ellipsis">
      问题三：快速幂算法
    </span>
  </a>
  
    <nav class="md-nav" aria-label="问题三：快速幂算法">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_38" class="md-nav__link">
    <span class="md-ellipsis">
      算法原理
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_39" class="md-nav__link">
    <span class="md-ellipsis">
      递归实现
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_40" class="md-nav__link">
    <span class="md-ellipsis">
      循环实现
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_41" class="md-nav__link">
    <span class="md-ellipsis">
      完整测试代码
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#2" class="md-nav__link">
    <span class="md-ellipsis">
      处理非2的整数次幂
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_42" class="md-nav__link">
    <span class="md-ellipsis">
      时间复杂度分析
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_43" class="md-nav__link">
    <span class="md-ellipsis">
      二分查找思想的广泛应用
    </span>
  </a>
  
    <nav class="md-nav" aria-label="二分查找思想的广泛应用">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_44" class="md-nav__link">
    <span class="md-ellipsis">
      二分查找的应用模式
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#06_stack_maze" class="md-nav__link">
    <span class="md-ellipsis">
      06_stack_maze
    </span>
  </a>
  
    <nav class="md-nav" aria-label="06_stack_maze">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_45" class="md-nav__link">
    <span class="md-ellipsis">
      代码
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#dfs" class="md-nav__link">
    <span class="md-ellipsis">
      深入理解访问点、前驱点和DFS搜索过程
    </span>
  </a>
  
    <nav class="md-nav" aria-label="深入理解访问点、前驱点和DFS搜索过程">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#1-vs" class="md-nav__link">
    <span class="md-ellipsis">
      1. 访问点 vs 前驱点
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#2_1" class="md-nav__link">
    <span class="md-ellipsis">
      2. 为什么一个点可以探索多个地方？
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#3" class="md-nav__link">
    <span class="md-ellipsis">
      详细分解步骤3的执行过程
    </span>
  </a>
  
    <nav class="md-nav" aria-label="详细分解步骤3的执行过程">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#3_1" class="md-nav__link">
    <span class="md-ellipsis">
      步骤3开始前的状态
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#3_2" class="md-nav__link">
    <span class="md-ellipsis">
      步骤3执行过程
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#3_3" class="md-nav__link">
    <span class="md-ellipsis">
      步骤3结束后的状态
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#dfs-" class="md-nav__link">
    <span class="md-ellipsis">
      为什么这样设计？DFS的"探索-回溯"机制
    </span>
  </a>
  
    <nav class="md-nav" aria-label="为什么这样设计？DFS的"探索-回溯"机制">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#dfs_1" class="md-nav__link">
    <span class="md-ellipsis">
      DFS的核心思想：一条路走到黑，不行就回头
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_46" class="md-nav__link">
    <span class="md-ellipsis">
      搜索路径的可视化
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_47" class="md-nav__link">
    <span class="md-ellipsis">
      前驱点的关键作用：重建路径
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_48" class="md-nav__link">
    <span class="md-ellipsis">
      从思维转换到代码的关键突破
    </span>
  </a>
  
    <nav class="md-nav" aria-label="从思维转换到代码的关键突破">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#1" class="md-nav__link">
    <span class="md-ellipsis">
      1. 理解"探索"与"访问"的区别
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#2_2" class="md-nav__link">
    <span class="md-ellipsis">
      2. 栈的作用：待探索的候选列表
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#3_4" class="md-nav__link">
    <span class="md-ellipsis">
      3. 前驱的作用：路径记忆
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_49" class="md-nav__link">
    <span class="md-ellipsis">
      完整的思维转换示例
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_50" class="md-nav__link">
    <span class="md-ellipsis">
      总结
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#06_stack" class="md-nav__link">
    <span class="md-ellipsis">
      06_stack 问题解答与代码改进
    </span>
  </a>
  
    <nav class="md-nav" aria-label="06_stack 问题解答与代码改进">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_51" class="md-nav__link">
    <span class="md-ellipsis">
      问题一：从起点到终点正向打印路线
    </span>
  </a>
  
    <nav class="md-nav" aria-label="问题一：从起点到终点正向打印路线">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#1_1" class="md-nav__link">
    <span class="md-ellipsis">
      方法1：使用临时数组存储路径
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#2_3" class="md-nav__link">
    <span class="md-ellipsis">
      方法2：递归打印
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#3_5" class="md-nav__link">
    <span class="md-ellipsis">
      方法3：使用双向链表
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#predecessor" class="md-nav__link">
    <span class="md-ellipsis">
      问题二：优化predecessor的存储空间
    </span>
  </a>
  
    <nav class="md-nav" aria-label="问题二：优化predecessor的存储空间">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#1_2" class="md-nav__link">
    <span class="md-ellipsis">
      优化方案1：使用方向编码
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#2_4" class="md-nav__link">
    <span class="md-ellipsis">
      优化方案2：使用单字节存储坐标
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#dfs_2" class="md-nav__link">
    <span class="md-ellipsis">
      问题三：改写为递归DFS程序
    </span>
  </a>
  
    <nav class="md-nav" aria-label="问题三：改写为递归DFS程序">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#dfspredecessor" class="md-nav__link">
    <span class="md-ellipsis">
      递归DFS实现（避免使用predecessor）
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#dfs_3" class="md-nav__link">
    <span class="md-ellipsis">
      递归DFS的优势
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#dfs_4" class="md-nav__link">
    <span class="md-ellipsis">
      递归DFS的注意事项
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_52" class="md-nav__link">
    <span class="md-ellipsis">
      完整整合版本
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_53" class="md-nav__link">
    <span class="md-ellipsis">
      总结
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#07_queue_maze" class="md-nav__link">
    <span class="md-ellipsis">
      07_queue_maze
    </span>
  </a>
  
    <nav class="md-nav" aria-label="07_queue_maze">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#dfs_5" class="md-nav__link">
    <span class="md-ellipsis">
      问题一：为什么DFS不能采用队列的这种前驱表示方法？
    </span>
  </a>
  
    <nav class="md-nav" aria-label="问题一：为什么DFS不能采用队列的这种前驱表示方法？">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#vs" class="md-nav__link">
    <span class="md-ellipsis">
      关键差异：栈 vs 队列的访问特性
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_54" class="md-nav__link">
    <span class="md-ellipsis">
      具体例子说明
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_55" class="md-nav__link">
    <span class="md-ellipsis">
      问题二：队列空间分配与迷宫大小的关系
    </span>
  </a>
  
    <nav class="md-nav" aria-label="问题二：队列空间分配与迷宫大小的关系">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_56" class="md-nav__link">
    <span class="md-ellipsis">
      队列最小空间计算
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#bfs" class="md-nav__link">
    <span class="md-ellipsis">
      BFS的层次扩展特性
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_57" class="md-nav__link">
    <span class="md-ellipsis">
      通用公式
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#bfs_1" class="md-nav__link">
    <span class="md-ellipsis">
      改进的BFS实现（优化空间）
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_58" class="md-nav__link">
    <span class="md-ellipsis">
      关键洞察总结
    </span>
  </a>
  
    <nav class="md-nav" aria-label="关键洞察总结">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#1_3" class="md-nav__link">
    <span class="md-ellipsis">
      1. 前驱表示方法的差异
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#2_5" class="md-nav__link">
    <span class="md-ellipsis">
      2. 队列空间与迷宫大小的关系
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#3_6" class="md-nav__link">
    <span class="md-ellipsis">
      3. 你的思考是正确的！
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_59" class="md-nav__link">
    <span class="md-ellipsis">
      实际应用建议
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#11_command_interpreter" class="md-nav__link">
    <span class="md-ellipsis">
      11_command_interpreter
    </span>
  </a>
  
    <nav class="md-nav" aria-label="11_command_interpreter">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_60" class="md-nav__link">
    <span class="md-ellipsis">
      代码
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_61" class="md-nav__link">
    <span class="md-ellipsis">
      指针梳理
    </span>
  </a>
  
    <nav class="md-nav" aria-label="指针梳理">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_62" class="md-nav__link">
    <span class="md-ellipsis">
      初始状态
    </span>
  </a>
  
    <nav class="md-nav" aria-label="初始状态">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#a" class="md-nav__link">
    <span class="md-ellipsis">
      第一步：遇到字符'a'
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_63" class="md-nav__link">
    <span class="md-ellipsis">
      第二步：继续扫描到空格
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#argvargc-start" class="md-nav__link">
    <span class="md-ellipsis">
      关键理解：为什么argv[argc++] = start可行？
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_64" class="md-nav__link">
    <span class="md-ellipsis">
      内存布局变化：
    </span>
  </a>
  
    <nav class="md-nav" aria-label="内存布局变化：">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_65" class="md-nav__link">
    <span class="md-ellipsis">
      指针赋值原理：
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#defg" class="md-nav__link">
    <span class="md-ellipsis">
      第三步：处理"defg"
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_66" class="md-nav__link">
    <span class="md-ellipsis">
      最终结果
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_67" class="md-nav__link">
    <span class="md-ellipsis">
      与你想法"一个个字符赋值"的对比
    </span>
  </a>
  
    <nav class="md-nav" aria-label="与你想法"一个个字符赋值"的对比">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_68" class="md-nav__link">
    <span class="md-ellipsis">
      优势
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#bug" class="md-nav__link">
    <span class="md-ellipsis">
      bug
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#_69" class="md-nav__link">
    <span class="md-ellipsis">
      原代码的核心问题
    </span>
  </a>
  
    <nav class="md-nav" aria-label="原代码的核心问题">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#1-state_init" class="md-nav__link">
    <span class="md-ellipsis">
      1. STATE_INIT 状态的逻辑错误
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#2_6" class="md-nav__link">
    <span class="md-ellipsis">
      2. 缺少字符串结束处理
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#_70" class="md-nav__link">
    <span class="md-ellipsis">
      修改原理详解
    </span>
  </a>
  
    <nav class="md-nav" aria-label="修改原理详解">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#1_4" class="md-nav__link">
    <span class="md-ellipsis">
      1. 正确的空白字符处理
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#2_7" class="md-nav__link">
    <span class="md-ellipsis">
      2. 字符串结束的特殊处理
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#3_7" class="md-nav__link">
    <span class="md-ellipsis">
      3. 循环外的参数处理
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#_71" class="md-nav__link">
    <span class="md-ellipsis">
      状态机工作流程示例
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#_72" class="md-nav__link">
    <span class="md-ellipsis">
      总结
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#15_url_parser" class="md-nav__link">
    <span class="md-ellipsis">
      15_url_parser
    </span>
  </a>
  
    <nav class="md-nav" aria-label="15_url_parser">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_73" class="md-nav__link">
    <span class="md-ellipsis">
      代码
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#16_mysed" class="md-nav__link">
    <span class="md-ellipsis">
      16_mysed
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#17_myfile" class="md-nav__link">
    <span class="md-ellipsis">
      17_myfile
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#18_mywc" class="md-nav__link">
    <span class="md-ellipsis">
      18_mywc
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#19_mytrans" class="md-nav__link">
    <span class="md-ellipsis">
      19_mytrans
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#20_mybash" class="md-nav__link">
    <span class="md-ellipsis">
      20_mybash
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#todo" class="md-nav__link">
    <span class="md-ellipsis">
      TODO
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#todo_1" class="md-nav__link">
    <span class="md-ellipsis">
      TODO
    </span>
  </a>
  
</li>
      
    </ul>
  
</nav>
                  </div>
                </div>
              </div>
            
          
          
            <div class="md-content" data-md-component="content">
              <article class="md-content__inner md-typeset">
                
                  

  
  


<h1 id="stage-1-basics">Stage 1: Basics</h1>
<h2 id="_1">题目汇总</h2>
<ol>
<li><strong>01_insert_sort</strong> - 插入排序</li>
<li><strong>02_merge_sort</strong> - 归并排序</li>
<li><strong>03_quick_sort</strong> - 快速排序</li>
<li><strong>04_linear_search</strong> - 线性查找</li>
<li><strong>05_binary_search</strong> - 折半查找</li>
<li><strong>06_stack_maze</strong> - 栈解决迷宫问题</li>
<li><strong>07_queue_maze</strong> - 队列实现广度搜索迷宫问题</li>
<li><strong>08_circular_queue</strong> - 环形队列实现约瑟夫环问题</li>
<li><strong>09_word_counter</strong> - 统计单词个数</li>
<li><strong>10_my_strcpy</strong> - 字符串拷贝</li>
<li><strong>11_command_interpreter</strong> - 字符指针数组 命令解释器</li>
<li><strong>12_student_management</strong> - 结构体指针 学生信息管理</li>
<li><strong>13_universal_sorter</strong> - 函数指针实现通用排序接口</li>
<li><strong>14_calculator</strong> - 函数指针数组实现四则运算</li>
<li><strong>15_url_parser</strong> - http 超链传递参数分析器</li>
<li><strong>16_mysed</strong> - sed 简单流处理器实现</li>
<li><strong>17_myfile</strong> - file命令查看ELF文件头</li>
<li><strong>18_mywc</strong> - MyWC 词频统计器项目</li>
<li><strong>19_mytrans</strong> - MyTrans 查字典翻译项目</li>
<li><strong>20_mybash</strong> - MyBash 命令解释器项目</li>
</ol>
<h2 id="01_insert_sort-">01_insert_sort - 插入排序</h2>
<h3 id="_2">第一层：建立牢固的直觉认知（像打扑克牌一样）</h3>
<p>想象一下你在打扑克牌，你是怎么整理手中的牌的？</p>
<ol>
<li>你左手一开始是空的（<strong>已排序区</strong>）。</li>
<li>你用右手从牌堆里（<strong>未排序区</strong>）拿起一张新牌。</li>
<li>然后，你用这张新牌，从右往左（或从左往右）跟你左手上<strong>已经排好序</strong>的牌<strong>依次比较</strong>。</li>
<li>找到它应该插入的位置（比如，一张 <code>7</code> 应该插在 <code>6</code> 和 <code>8</code> 之间）。</li>
<li>为了给 <code>7</code> 腾出位置，你需要把 <code>8</code>、<code>9</code>、<code>10</code> 这些比它大的牌都<strong>向右移动一个位置</strong>，然后把 <code>7</code> 放进去。</li>
</ol>
<p><strong>这个全过程，就是插入排序！</strong> 它模拟的是最符合人类直觉的排序方式。</p>
<hr />
<h3 id="_3">第二层：图文并茂，一步步“慢放”</h3>
<p>我们用一个具体数组来“慢放”这个动画：<code>[5, 2, 4, 6, 1, 3]</code></p>
<p>我们用 <code>|</code> 来分隔已排序区和未排序区。</p>
<p><strong>初始状态：</strong> <code>5 | 2, 4, 6, 1, 3</code> （我们认为第一个元素 <code>5</code> 自己就是有序的）</p>
<p><strong>第一轮（处理 2）：</strong>
- 取出 <code>2</code>。
- <code>2</code> 与 <code>5</code> 比较，<code>2 &lt; 5</code>，所以 <code>5</code> 向右移动一位。
- 找到位置，插入 <code>2</code>。
- <strong>结果：</strong> <code>2, 5 | 4, 6, 1, 3</code></p>
<p><strong>第二轮（处理 4）：</strong>
- 取出 <code>4</code>。
- <code>4</code> 与 <code>5</code> 比较，<code>4 &lt; 5</code>，<code>5</code> 右移。
- <code>4</code> 与 <code>2</code> 比较，<code>4 &gt; 2</code>，停止比较，插入 <code>4</code>。
- <strong>结果：</strong> <code>2, 4, 5 | 6, 1, 3</code></p>
<p><strong>第三轮（处理 6）：</strong>
- 取出 <code>6</code>。
- <code>6</code> 与 <code>5</code> 比较，<code>6 &gt; 5</code>，停止比较，原地插入（不用移动）。
- <strong>结果：</strong> <code>2, 4, 5, 6 | 1, 3</code></p>
<p><strong>第四轮（处理 1）：</strong>
- 取出 <code>1</code>。
- <code>1</code> 与 <code>6</code> 比较，<code>1 &lt; 6</code>，<code>6</code> 右移。
- <code>1</code> 与 <code>5</code> 比较，<code>1 &lt; 5</code>，<code>5</code> 右移。
- <code>1</code> 与 <code>4</code> 比较，<code>1 &lt; 4</code>，<code>4</code> 右移。
- <code>1</code> 与 <code>2</code> 比较，<code>1 &lt; 2</code>，<code>2</code> 右移。
- 到达开头，插入 <code>1</code>。
- <strong>结果：</strong> <code>1, 2, 4, 5, 6 | 3</code></p>
<p><strong>第五轮（处理 3）：</strong>
- 取出 <code>3</code>。
- <code>3</code> 与 <code>6</code> 比较，<code>3 &lt; 6</code>，<code>6</code> 右移。
- <code>3</code> 与 <code>5</code> 比较，<code>3 &lt; 5</code>，<code>5</code> 右移。
- <code>3</code> 与 <code>4</code> 比较，<code>3 &lt; 4</code>，<code>4</code> 右移。
- <code>3</code> 与 <code>2</code> 比较，<code>3 &gt; 2</code>，停止比较，插入 <code>3</code>。
- <strong>结果：</strong> <code>1, 2, 3, 4, 5, 6 |</code> （排序完成）</p>
<p><strong>核心洞察：</strong> 在每一轮中，<strong>已排序区</strong>始终是有序的，我们只是在不断扩大这个有序区的边界。</p>
<hr />
<h3 id="c">第三层：写出带详细追踪的C语言代码</h3>
<p>现在，我们把上面的步骤翻译成C语言。关键是要在代码里反映出每一步的思考。</p>
<div class="highlight"><pre><span></span><code><span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;stdio.h&gt;</span>

<span class="c1">// 插入排序函数</span>
<span class="kt">void</span><span class="w"> </span><span class="nf">insertionSort</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">arr</span><span class="p">[],</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">n</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="p">,</span><span class="w"> </span><span class="n">key</span><span class="p">,</span><span class="w"> </span><span class="n">j</span><span class="p">;</span>

<span class="w">    </span><span class="c1">// 从第二个元素开始（索引1），因为第一个元素默认已排序</span>
<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">n</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">++</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="c1">// ‘key’ 就是我们当前要插入的“新牌”</span>
<span class="w">        </span><span class="n">key</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">arr</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>

<span class="w">        </span><span class="c1">// j 从 ‘key’ 的前一个位置开始，指向已排序区的“最右端”</span>
<span class="w">        </span><span class="n">j</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span>

<span class="w">        </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;第%d轮：取出 key = %d，与已排序区 [&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">i</span><span class="p">,</span><span class="w"> </span><span class="n">key</span><span class="p">);</span>
<span class="w">        </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">k</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">k</span><span class="w"> </span><span class="o">&lt;=</span><span class="w"> </span><span class="n">j</span><span class="p">;</span><span class="w"> </span><span class="n">k</span><span class="o">++</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;%d &quot;</span><span class="p">,</span><span class="w"> </span><span class="n">arr</span><span class="p">[</span><span class="n">k</span><span class="p">]);</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">        </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;] 从右往左比较</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

<span class="w">        </span><span class="c1">// 将 arr[0..i-1]（已排序区）中所有比 ‘key’ 大的元素</span>
<span class="w">        </span><span class="c1">// 都向右移动一个位置，为 ‘key’ 腾地方</span>
<span class="w">        </span><span class="k">while</span><span class="w"> </span><span class="p">(</span><span class="n">j</span><span class="w"> </span><span class="o">&gt;=</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">arr</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="n">key</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;  -&gt; %d &gt; %d，将 %d 向右移动一位</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">arr</span><span class="p">[</span><span class="n">j</span><span class="p">],</span><span class="w"> </span><span class="n">key</span><span class="p">,</span><span class="w"> </span><span class="n">arr</span><span class="p">[</span><span class="n">j</span><span class="p">]);</span>
<span class="w">            </span><span class="n">arr</span><span class="p">[</span><span class="n">j</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">arr</span><span class="p">[</span><span class="n">j</span><span class="p">];</span>
<span class="w">            </span><span class="n">j</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">j</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span><span class="w"> </span><span class="c1">// 继续向左比较</span>
<span class="w">        </span><span class="p">}</span>

<span class="w">        </span><span class="c1">// 当循环停止时，j+1 就是 ‘key’ 的正确位置</span>
<span class="w">        </span><span class="c1">// 因为此时要么 j=-1（key是最小的），要么 arr[j] &lt;= key（找到了不比key大的元素）</span>
<span class="w">        </span><span class="n">arr</span><span class="p">[</span><span class="n">j</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">key</span><span class="p">;</span>

<span class="w">        </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;  -&gt; 将 key(%d) 插入到位置 %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">key</span><span class="p">,</span><span class="w"> </span><span class="n">j</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="p">);</span>
<span class="w">        </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;  -&gt; 当前数组： &quot;</span><span class="p">);</span>
<span class="w">        </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">k</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">k</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">n</span><span class="p">;</span><span class="w"> </span><span class="n">k</span><span class="o">++</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;%d &quot;</span><span class="p">,</span><span class="w"> </span><span class="n">arr</span><span class="p">[</span><span class="n">k</span><span class="p">]);</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">        </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;</span><span class="se">\n\n</span><span class="s">&quot;</span><span class="p">);</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">}</span>

<span class="c1">// 主函数来测试</span>
<span class="kt">int</span><span class="w"> </span><span class="nf">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">arr</span><span class="p">[]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="mi">5</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="mi">4</span><span class="p">,</span><span class="w"> </span><span class="mi">6</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">3</span><span class="p">};</span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">sizeof</span><span class="p">(</span><span class="n">arr</span><span class="p">)</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="k">sizeof</span><span class="p">(</span><span class="n">arr</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>

<span class="w">    </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;原始数组： &quot;</span><span class="p">);</span>
<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">n</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">++</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;%d &quot;</span><span class="p">,</span><span class="w"> </span><span class="n">arr</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;</span><span class="se">\n\n</span><span class="s">开始排序过程：</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

<span class="w">    </span><span class="n">insertionSort</span><span class="p">(</span><span class="n">arr</span><span class="p">,</span><span class="w"> </span><span class="n">n</span><span class="p">);</span>

<span class="w">    </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;排序后数组： &quot;</span><span class="p">);</span>
<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">n</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">++</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;%d &quot;</span><span class="p">,</span><span class="w"> </span><span class="n">arr</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>
<p><strong>请你一定要运行这段代码！</strong> 看看控制台输出，它会完美重现我们上面“慢放”的每一步。这是理解算法执行流程最有效的方式。</p>
<hr />
<h3 id="_4">第四层：专业角度的深度分析（这才是“专业”的体现）</h3>
<p>一个专业的程序员不仅要会写，更要会分析。</p>
<ol>
<li>
<p><strong>时间复杂度</strong></p>
<ul>
<li><strong>最坏情况</strong>：数组完全逆序（如 <code>[5,4,3,2,1]</code>）。每一个新元素 <code>key</code> 都需要和之前所有的元素比较并移动。内层循环会执行 <code>1 + 2 + ... + (n-1) ≈ n²/2</code> 次。所以是 <strong>O(n²)</strong>。这是它的主要缺点。</li>
<li><strong>最好情况</strong>：数组已经有序（如 <code>[1,2,3,4,5]</code>）。每个 <code>key</code> 只需要和它前一个元素比较一次（因为 <code>arr[j] &gt; key</code> 条件立刻为假）。所以是 <strong>O(n)</strong>。这是它的一大优点！</li>
<li><strong>平均情况</strong>：也是 <strong>O(n²)</strong>。</li>
</ul>
</li>
<li>
<p><strong>空间复杂度</strong></p>
<ul>
<li>我们只用了 <code>i</code>, <code>key</code>, <code>j</code> 等固定数量的额外变量。所以是 <strong>O(1)</strong>，是一种 <strong>原地排序</strong> 算法。</li>
</ul>
</li>
<li>
<p><strong>稳定性</strong></p>
<ul>
<li><strong>插入排序是稳定的</strong>。当两个元素相等时（比如两个 <code>5</code>），我们只在 <code>arr[j] &gt; key</code> 时才移动，对于相等的元素，我们不移动，所以它们原始的相对顺序会被保留。</li>
</ul>
</li>
<li>
<p><strong>适用场景</strong></p>
<ul>
<li><strong>小规模数据</strong>：非常高效，常数项因子小。</li>
<li><strong>数据基本有序</strong>：因为最好情况是 O(n)，接近线性时间。</li>
<li><strong>作为高级排序算法的优化子过程</strong>：比如在快速排序或归并排序中，当递归到小数组时，改用插入排序可以提升整体性能。</li>
</ul>
</li>
</ol>
<hr />
<h3 id="_5">总结：如何达到“专业理解”</h3>
<ol>
<li><strong>生活化类比</strong>：用扑克牌建立牢固的直觉。</li>
<li><strong>手动模拟</strong>：拿笔在纸上一步步画出来，理解每一步在做什么。</li>
<li><strong>代码与追踪</strong>：写出带有详细打印信息的代码，让计算机帮你“慢放”整个过程。</li>
<li><strong>复杂度分析</strong>：从时间（最好、最坏、平均）、空间、稳定性等角度定量分析算法的性能。</li>
<li><strong>场景思考</strong>：知道它在哪里用得好，在哪里不行。</li>
</ol>
<p>当你完成以上所有步骤，你就不再是“只知道概念”，而是真正<strong>内化</strong>了插入排序。你可以清晰地在大脑中描绘出它的执行画面，可以准确地分析它的优劣，并能在合适的场景下 confidently（自信地）使用它。</p>
<p>这就是专业的态度和方法。祝你学习愉快，在算法的世界里不断精进！</p>
<h2 id="02_merge_sort">02_merge_sort</h2>
<h3 id="_6">第一阶段：建立直观理解</h3>
<h4 id="11-">1.1 核心思想 - "分而治之"</h4>
<p>想象你要整理一副乱序的扑克牌：
- <strong>分</strong>：把整副牌分成两半，再把每一半继续分成两半...直到每堆只有1张牌
- <strong>治</strong>：把只有1张牌的堆（自然有序）两两合并成有序的堆，再合并这些有序堆...</p>
<h4 id="12">1.2 为什么"合并"是关键？</h4>
<p><strong>关键洞察</strong>：合并两个<strong>已经有序</strong>的数组是非常容易的！而归并排序的智慧就在于，它先把问题分解到最简单的状态（单个元素自然有序），然后通过不断合并来构建更大的有序数组。</p>
<hr />
<h3 id="_7">第二阶段：详细分解合并过程</h3>
<p>让我们用具体的例子来理解。假设我们要合并两个已经有序的数组：</p>
<div class="highlight"><pre><span></span><code>左数组: [2, 5, 8]   右数组: [1, 4, 7, 9]
</code></pre></div>
<h4 id="_8">合并的详细步骤：</h4>
<p><strong>步骤1：初始化指针</strong></p>
<div class="highlight"><pre><span></span><code>左数组: [2, 5, 8]    ← i=0 (指向2)
右数组: [1, 4, 7, 9] ← j=0 (指向1)
临时数组: []         ← k=0
</code></pre></div>
<p><strong>步骤2：比较第一个元素</strong>
- 比较 <code>2</code> vs <code>1</code>
- <code>1 &lt; 2</code>，所以把 <code>1</code> 放入临时数组
- 移动右指针 j++
<div class="highlight"><pre><span></span><code>临时数组: [1]
左数组: [2, 5, 8]    ← i=0
右数组: [1, 4, 7, 9] ← j=1 (指向4)
</code></pre></div></p>
<p><strong>步骤3：继续比较</strong>
- 比较 <code>2</code> vs <code>4</code>
- <code>2 &lt; 4</code>，所以把 <code>2</code> 放入临时数组
- 移动左指针 i++
<div class="highlight"><pre><span></span><code>临时数组: [1, 2]
左数组: [2, 5, 8]    ← i=1 (指向5)
右数组: [1, 4, 7, 9] ← j=1
</code></pre></div></p>
<p><strong>步骤4：继续比较</strong>
- 比较 <code>5</code> vs <code>4</code>
- <code>4 &lt; 5</code>，所以把 <code>4</code> 放入临时数组
- 移动右指针 j++
<div class="highlight"><pre><span></span><code>临时数组: [1, 2, 4]
左数组: [2, 5, 8]    ← i=1
右数组: [1, 4, 7, 9] ← j=2 (指向7)
</code></pre></div></p>
<p><strong>步骤5：继续比较</strong>
- 比较 <code>5</code> vs <code>7</code>
- <code>5 &lt; 7</code>，所以把 <code>5</code> 放入临时数组
- 移动左指针 i++
<div class="highlight"><pre><span></span><code>临时数组: [1, 2, 4, 5]
左数组: [2, 5, 8]    ← i=2 (指向8)
右数组: [1, 4, 7, 9] ← j=2
</code></pre></div></p>
<p><strong>步骤6：继续比较</strong>
- 比较 <code>8</code> vs <code>7</code>
- <code>7 &lt; 8</code>，所以把 <code>7</code> 放入临时数组
- 移动右指针 j++
<div class="highlight"><pre><span></span><code>临时数组: [1, 2, 4, 5, 7]
左数组: [2, 5, 8]    ← i=2
右数组: [1, 4, 7, 9] ← j=3 (指向9)
</code></pre></div></p>
<p><strong>步骤7：继续比较</strong>
- 比较 <code>8</code> vs <code>9</code>
- <code>8 &lt; 9</code>，所以把 <code>8</code> 放入临时数组
- 移动左指针 i++
<div class="highlight"><pre><span></span><code>临时数组: [1, 2, 4, 5, 7, 8]
左数组: [2, 5, 8]    ← i=3 (超出边界)
右数组: [1, 4, 7, 9] ← j=3
</code></pre></div></p>
<p><strong>步骤8：处理剩余元素</strong>
- 左数组已经用完，但右数组还有剩余元素 <code>9</code>
- 直接把剩余元素全部拷贝到临时数组
<div class="highlight"><pre><span></span><code>临时数组: [1, 2, 4, 5, 7, 8, 9]
</code></pre></div></p>
<p><strong>合并完成！</strong> 我们得到了一个完整的有序数组。</p>
<hr />
<h3 id="_9">第三阶段：在归并排序中的完整流程</h3>
<p>现在让我们看整个归并排序的过程，用数组 <code>[5, 2, 4, 6, 1, 3]</code>：</p>
<h4 id="_10">分解阶段（递归拆分）：</h4>
<div class="highlight"><pre><span></span><code>原始: [5, 2, 4, 6, 1, 3]
      ↓ 分成 [5,2,4] 和 [6,1,3]
[5,2,4] → 分成 [5] 和 [2,4] → [2,4] 再分成 [2] 和 [4]
[6,1,3] → 分成 [6] 和 [1,3] → [1,3] 再分成 [1] 和 [3]

最终得到： [5] [2] [4] [6] [1] [3]
</code></pre></div>
<h4 id="_11">合并阶段（从底部开始）：</h4>
<div class="highlight"><pre><span></span><code>第一层合并：
合并 [2] 和 [4] → [2,4]
合并 [1] 和 [3] → [1,3]

第二层合并：
合并 [5] 和 [2,4] → [2,4,5]  # 详细过程见下面
合并 [6] 和 [1,3] → [1,3,6]

第三层合并：
合并 [2,4,5] 和 [1,3,6] → [1,2,3,4,5,6]  # 详细过程就是我们上面演示的
</code></pre></div>
<h4 id="5-24">详细演示合并 <code>[5]</code> 和 <code>[2,4]</code>：</h4>
<div class="highlight"><pre><span></span><code>步骤1: [5] vs [2,4] → 2&lt;5 → 取2 → 结果: [2]
步骤2: [5] vs [4]   → 4&lt;5 → 取4 → 结果: [2,4]  
步骤3: 左数组还有 [5]，直接加入 → 结果: [2,4,5]
</code></pre></div>
<hr />
<h3 id="_12">第四阶段：代码的逐行解释</h3>
<p>让我们再看一遍合并函数的代码，这次我加上极其详细的注释：</p>
<div class="highlight"><pre><span></span><code><span class="kt">void</span><span class="w"> </span><span class="nf">merge</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">start</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">mid</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">end</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">start</span><span class="p">;</span><span class="w">      </span><span class="c1">// 左半部分的起始指针</span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">j</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">mid</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span><span class="w">    </span><span class="c1">// 右半部分的起始指针  </span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">k</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">start</span><span class="p">;</span><span class="w">      </span><span class="c1">// 临时数组的指针</span>

<span class="w">    </span><span class="c1">// 核心循环：比较左右两部分的元素，取较小的放入临时数组</span>
<span class="w">    </span><span class="k">while</span><span class="w"> </span><span class="p">(</span><span class="n">i</span><span class="w"> </span><span class="o">&lt;=</span><span class="w"> </span><span class="n">mid</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">j</span><span class="w"> </span><span class="o">&lt;=</span><span class="w"> </span><span class="n">end</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">students</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">score</span><span class="w"> </span><span class="o">&gt;=</span><span class="w"> </span><span class="n">students</span><span class="p">[</span><span class="n">j</span><span class="p">].</span><span class="n">score</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="c1">// 左半部分的分数 &gt;= 右半部分，取左半部分的元素</span>
<span class="w">            </span><span class="c1">// 使用 &gt;= 保证稳定性（相等时保持原顺序）</span>
<span class="w">            </span><span class="n">temp</span><span class="p">[</span><span class="n">k</span><span class="o">++</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">students</span><span class="p">[</span><span class="n">i</span><span class="o">++</span><span class="p">];</span>
<span class="w">        </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="c1">// 右半部分的分数更大，取右半部分的元素</span>
<span class="w">            </span><span class="n">temp</span><span class="p">[</span><span class="n">k</span><span class="o">++</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">students</span><span class="p">[</span><span class="n">j</span><span class="o">++</span><span class="p">];</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="c1">// 处理左半部分剩余的元素（如果有）</span>
<span class="w">    </span><span class="c1">// 这些元素都比已经放入的所有元素大，直接拷贝</span>
<span class="w">    </span><span class="k">while</span><span class="w"> </span><span class="p">(</span><span class="n">i</span><span class="w"> </span><span class="o">&lt;=</span><span class="w"> </span><span class="n">mid</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">temp</span><span class="p">[</span><span class="n">k</span><span class="o">++</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">students</span><span class="p">[</span><span class="n">i</span><span class="o">++</span><span class="p">];</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="c1">// 处理右半部分剩余的元素（如果有）</span>
<span class="w">    </span><span class="c1">// 这些元素都比已经放入的所有元素大，直接拷贝</span>
<span class="w">    </span><span class="k">while</span><span class="w"> </span><span class="p">(</span><span class="n">j</span><span class="w"> </span><span class="o">&lt;=</span><span class="w"> </span><span class="n">end</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">temp</span><span class="p">[</span><span class="n">k</span><span class="o">++</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">students</span><span class="p">[</span><span class="n">j</span><span class="o">++</span><span class="p">];</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="c1">// 把排好序的临时数组内容复制回原数组</span>
<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="n">k</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">start</span><span class="p">;</span><span class="w"> </span><span class="n">k</span><span class="w"> </span><span class="o">&lt;=</span><span class="w"> </span><span class="n">end</span><span class="p">;</span><span class="w"> </span><span class="n">k</span><span class="o">++</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">students</span><span class="p">[</span><span class="n">k</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">temp</span><span class="p">[</span><span class="n">k</span><span class="p">];</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">}</span>
</code></pre></div>
<h4 id="_13">关键理解点：</h4>
<ol>
<li><strong>三个指针的作用</strong>：</li>
<li><code>i</code>：遍历左半部分</li>
<li><code>j</code>：遍历右半部分  </li>
<li>
<p><code>k</code>：指向临时数组中要放入下一个元素的位置</p>
</li>
<li>
<p><strong>核心循环的条件</strong>：<code>i &lt;= mid &amp;&amp; j &lt;= end</code></p>
</li>
<li>这个条件确保只要左右两部分都还有元素，就继续比较</li>
<li>
<p>一旦某一部分用完，循环就结束</p>
</li>
<li>
<p><strong>两个"清理"循环</strong>：</p>
</li>
<li>第一个 <code>while (i &lt;= mid)</code>：处理左半部分剩余元素</li>
<li>第二个 <code>while (j &lt;= end)</code>：处理右半部分剩余元素</li>
<li>
<p>这两个循环只会执行其中一个（因为核心循环结束时，至少有一个部分已用完）</p>
</li>
<li>
<p><strong>稳定性</strong>：</p>
</li>
<li><code>&gt;=</code> 保证了当分数相等时，我们先取左边的元素</li>
<li>这保持了原始输入的顺序，所以是稳定排序</li>
</ol>
<hr />
<h3 id="_14">第五阶段：可视化类比</h3>
<p>想象你有两叠已经按分数排好序的学生卡片：
- 左手拿一叠（左半部分）
- 右手拿一叠（右半部分）
- 面前有一个空桌子（临时数组）</p>
<p>你的操作：
1. 比较左右手最上面的卡片分数
2. 把分数更高的那张卡片放到桌子上
3. 重复直到某一叠卡片用完
4. 把剩下那叠卡片全部放到桌子上
5. 把桌子上的卡片按顺序放回原处</p>
<p><strong>这就是合并过程的本质！</strong></p>
<hr />
<h3 id="_15">总结：理解合并过程的要点</h3>
<ol>
<li><strong>前提条件</strong>：要合并的两个部分必须各自已经有序</li>
<li><strong>核心操作</strong>：比较两个部分的当前元素，取合适的放入结果</li>
<li><strong>指针移动</strong>：每次放入一个元素后，移动对应部分的指针</li>
<li><strong>剩余处理</strong>：当一个部分用完时，另一个部分的剩余元素直接全部拷贝</li>
<li><strong>稳定性</strong>：通过比较时的等号处理来保持原始相对顺序</li>
</ol>
<p>现在你应该能够：
- 在纸上手动模拟任何数组的合并过程
- 理解代码中每个变量和每个循环的作用
- 解释为什么归并排序是稳定的
- 理解"分而治之"策略的巧妙之处</p>
<p>这个理解是内化的、专业的，而不只是知道概念！</p>
<h3 id="_16">时间/空间</h3>
<p>归并排序并不总是优于插入排序。<strong>在以下几种情况更适合使用插入排序而不是归并排序</strong>：</p>
<ul>
<li><strong>输入规模很小</strong>：当 (n) 很小时，插入排序的常数因子小、实现简单，实际运行往往比归并排序快。许多实际排序库在递归/分治排序（如归并或快速排序）到达小数组时会切换到插入排序（常见阈值例如 10–20）。</li>
<li><strong>数据接近有序</strong>：如果序列已经部分或几乎有序，插入排序接近线性时间 ( \Theta(n + d) )（d 表示逆序对数或需要移动的程度），表现优异，而归并排序仍为 ( \Theta(n\log n) )。</li>
<li><strong>内存或空间受限</strong>：标准自顶向下归并排序需要额外的 (O(n)) 辅助空间（用于合并）；即使有原地归并的变体，常数和实现复杂度也很高。插入排序只需要 (O(1)) 额外空间，适合对内存、堆栈或分配有严格限制的环境（嵌入式、实时系统、某些安全/内存受限场景）。</li>
<li><strong>实现和维护成本</strong>：插入排序实现非常简单且少出错，适用于对代码体积、易审计性或确定性要求高的场合。</li>
<li><strong>稳定性与低开销的场景</strong>：插入排序天然稳定、数据移动成本低（比如元素很小或移动很便宜），在这种情况下优先考虑。</li>
</ul>
<p>关于“递归影响空间”的澄清</p>
<ul>
<li>标准归并排序一般用递归实现，它带来两个方面的额外空间开销：<ul>
<li>递归调用栈：深度为 (O(nlog n))，栈空间通常不是主要问题，但在极端受限的系统上可能重要。</li>
<li>合并时的辅助数组：标准做法需要 (O(n)) 额外内存来暂存元素，这是最主要的空间开销来源。</li>
</ul>
</li>
<li>因此，<strong>空间受限</strong>确实是一个重要原因，使得归并排序不适合某些环境；插入排序由于仅需要常数额外空间，更适合这些场景。</li>
</ul>
<p>什么时候在工程实现里常见的折中做法</p>
<ul>
<li>使用分治排序（归并或快速排序）对大块数据排序，但当子数组长度小于某个阈值（如 10–50）时，改用插入排序来完成最终阶段。这结合了两者优点：大规模时保持 (O(nlog n)) 性能，小规模时利用插入排序常数低的优势。</li>
<li>对内存敏感时，考虑使用<strong>原地排序算法（如堆排序）</strong>或对归并算法做原地/迭代优化，但通常代价是实现复杂度和常数因子增加。</li>
</ul>
<p>总结（要点）</p>
<ul>
<li>插入排序在小规模或几乎有序数据、内存受限或要求实现简单的场合更合适。</li>
<li>归并排序在大规模数据和对时间复杂度有严格要求时更优，但需要额外的空间（通常 (O(n))）。</li>
<li>实际工程中常用“先分治后小数组切换为插入排序”的混合策略以兼顾性能与空间、实现复杂度。</li>
</ul>
<h2 id="03_quick_sort">03_quick_sort</h2>
<h3 id="_17">第一层：建立牢固的直觉认知（像整理书架一样）</h3>
<p>想象你要整理一个杂乱的书架，快速排序的思路是：</p>
<ol>
<li><strong>选择"基准"</strong>：从书架上随便挑一本书作为参考点（比如中间的一本）。</li>
<li><strong>分区</strong>：把其他书分成两堆：</li>
<li>比基准书"小"的放左边（比如按书名顺序，书名在基准书之前的）</li>
<li>比基准书"大"的放右边（书名在基准书之后的）</li>
<li><strong>基准归位</strong>：<strong>把基准书放在左右两堆中间的正确位置。</strong></li>
<li><strong>递归处理</strong>：对左边和右边的两堆书，分别重复上述过程。</li>
</ol>
<p><strong>关键洞察</strong>：快速排序的核心是 <strong>"分治+分区"</strong>——每次分区都能让基准元素到达其最终正确位置！</p>
<hr />
<h3 id="_18">第二层：图文并茂，一步步"慢放"</h3>
<p>让我们用同样的数组来演示：<code>[5, 2, 4, 6, 1, 3]</code></p>
<p>我们选择第一个元素 <code>5</code> 作为基准（pivot）。</p>
<h4 id="_19">第一次分区过程：</h4>
<p><strong>初始状态：</strong> <code>[5, 2, 4, 6, 1, 3]</code> （pivot = 5）</p>
<p><strong>步骤1：</strong> 从右向左找第一个小于5的元素
- 找到 <code>3 &lt; 5</code>，位置5 → <code>[5, 2, 4, 6, 1, 3]</code></p>
<p><strong>步骤2：</strong> 从左向右找第一个大于5的元素<br />
- 找到 <code>6 &gt; 5</code>，位置3 → <code>[5, 2, 4, 6, 1, 3]</code></p>
<p><strong>步骤3：</strong> 交换这两个元素
- 交换6和3 → <code>[5, 2, 4, 3, 1, 6]</code></p>
<p><strong>步骤4：</strong> 继续从右向左找小于5的元素
- 找到 <code>1 &lt; 5</code>，位置4 → <code>[5, 2, 4, 3, 1, 6]</code></p>
<p><strong>步骤5：</strong> 继续从左向右找大于5的元素
- 指针相遇，停止查找</p>
<p><strong>步骤6：</strong> 将基准5与相遇位置的元素交换
- 交换5和1 → <code>[1, 2, 4, 3, 5, 6]</code></p>
<p><strong>分区完成！</strong> 现在：
- 基准 <code>5</code> 已经在最终正确位置
- 左边 <code>[1, 2, 4, 3]</code> 都 ≤ 5
- 右边 <code>[6]</code> 都 ≥ 5</p>
<h4 id="_20">递归处理左右分区：</h4>
<p><strong>处理左边 <code>[1, 2, 4, 3]</code>（pivot = 1）：</strong>
- 分区后：<code>[1, 2, 4, 3]</code>（1已经在正确位置）
- 左边：<code>[]</code>（空）
- 右边：<code>[2, 4, 3]</code></p>
<p><strong>处理 <code>[2, 4, 3]</code>（pivot = 2）：</strong></p>
<ul>
<li>分区后：<code>[2, 4, 3]</code> → 交换后 <code>[2, 3, 4]</code></li>
<li>左边：<code>[]</code></li>
<li>右边：<code>[3, 4]</code></li>
</ul>
<p><strong>处理 <code>[3, 4]</code>（pivot = 3）：</strong></p>
<ul>
<li>分区后：<code>[3, 4]</code></li>
<li>左边：<code>[]</code></li>
<li>右边：<code>[4]</code></li>
</ul>
<p><strong>处理右边 <code>[6]</code>：</strong>
- 单个元素，自然有序</p>
<p><strong>最终结果：</strong> <code>[1, 2, 3, 4, 5, 6]</code></p>
<hr />
<h3 id="c_1">第三层：写出带详细追踪的C语言代码</h3>
<div class="highlight"><pre><span></span><code><span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;stdio.h&gt;</span>

<span class="c1">// 交换两个元素</span>
<span class="kt">void</span><span class="w"> </span><span class="nf">swap</span><span class="p">(</span><span class="kt">int</span><span class="o">*</span><span class="w"> </span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="o">*</span><span class="w"> </span><span class="n">b</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">temp</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">*</span><span class="n">a</span><span class="p">;</span>
<span class="w">    </span><span class="o">*</span><span class="n">a</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">*</span><span class="n">b</span><span class="p">;</span>
<span class="w">    </span><span class="o">*</span><span class="n">b</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">temp</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">// 分区函数 - 快速排序的核心</span>
<span class="kt">int</span><span class="w"> </span><span class="nf">partition</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">arr</span><span class="p">[],</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">low</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">high</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">depth</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">pivot</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">arr</span><span class="p">[</span><span class="n">low</span><span class="p">];</span><span class="w">  </span><span class="c1">// 选择第一个元素作为基准</span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">left</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">low</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">right</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">high</span><span class="p">;</span>

<span class="w">    </span><span class="c1">// 打印当前分区信息</span>
<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">depth</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">++</span><span class="p">)</span><span class="w"> </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;  &quot;</span><span class="p">);</span>
<span class="w">    </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;分区: [&quot;</span><span class="p">);</span>
<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">low</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;=</span><span class="w"> </span><span class="n">high</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">++</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">i</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">low</span><span class="p">)</span><span class="w"> </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;(%d)&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">arr</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span><span class="w">  </span><span class="c1">// 标记基准</span>
<span class="w">        </span><span class="k">else</span><span class="w"> </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;%d&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">arr</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">high</span><span class="p">)</span><span class="w"> </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot; &quot;</span><span class="p">);</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;]</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

<span class="w">    </span><span class="k">while</span><span class="w"> </span><span class="p">(</span><span class="n">left</span><span class="w"> </span><span class="o">&lt;=</span><span class="w"> </span><span class="n">right</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="c1">// 从左向右找第一个大于pivot的元素</span>
<span class="w">        </span><span class="k">while</span><span class="w"> </span><span class="p">(</span><span class="n">left</span><span class="w"> </span><span class="o">&lt;=</span><span class="w"> </span><span class="n">right</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">arr</span><span class="p">[</span><span class="n">left</span><span class="p">]</span><span class="w"> </span><span class="o">&lt;=</span><span class="w"> </span><span class="n">pivot</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="n">left</span><span class="o">++</span><span class="p">;</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">        </span><span class="c1">// 从右向左找第一个小于pivot的元素  </span>
<span class="w">        </span><span class="k">while</span><span class="w"> </span><span class="p">(</span><span class="n">left</span><span class="w"> </span><span class="o">&lt;=</span><span class="w"> </span><span class="n">right</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">arr</span><span class="p">[</span><span class="n">right</span><span class="p">]</span><span class="w"> </span><span class="o">&gt;=</span><span class="w"> </span><span class="n">pivot</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="n">right</span><span class="o">--</span><span class="p">;</span>
<span class="w">        </span><span class="p">}</span>

<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">left</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">right</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">depth</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">++</span><span class="p">)</span><span class="w"> </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;  &quot;</span><span class="p">);</span>
<span class="w">            </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;  交换: %d &lt;-&gt; %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">arr</span><span class="p">[</span><span class="n">left</span><span class="p">],</span><span class="w"> </span><span class="n">arr</span><span class="p">[</span><span class="n">right</span><span class="p">]);</span>
<span class="w">            </span><span class="n">swap</span><span class="p">(</span><span class="o">&amp;</span><span class="n">arr</span><span class="p">[</span><span class="n">left</span><span class="p">],</span><span class="w"> </span><span class="o">&amp;</span><span class="n">arr</span><span class="p">[</span><span class="n">right</span><span class="p">]);</span>
<span class="w">            </span><span class="n">left</span><span class="o">++</span><span class="p">;</span>
<span class="w">            </span><span class="n">right</span><span class="o">--</span><span class="p">;</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="c1">// 将基准放到正确位置</span>
<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">depth</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">++</span><span class="p">)</span><span class="w"> </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;  &quot;</span><span class="p">);</span>
<span class="w">    </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;  基准归位: (%d) 放到位置 %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">pivot</span><span class="p">,</span><span class="w"> </span><span class="n">right</span><span class="p">);</span>
<span class="w">    </span><span class="n">swap</span><span class="p">(</span><span class="o">&amp;</span><span class="n">arr</span><span class="p">[</span><span class="n">low</span><span class="p">],</span><span class="w"> </span><span class="o">&amp;</span><span class="n">arr</span><span class="p">[</span><span class="n">right</span><span class="p">]);</span>

<span class="w">    </span><span class="c1">// 打印分区结果</span>
<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">depth</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">++</span><span class="p">)</span><span class="w"> </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;  &quot;</span><span class="p">);</span>
<span class="w">    </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;  结果: [&quot;</span><span class="p">);</span>
<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">low</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;=</span><span class="w"> </span><span class="n">high</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">++</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">i</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">right</span><span class="p">)</span><span class="w"> </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;[%d]&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">arr</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span><span class="w">  </span><span class="c1">// 标记基准最终位置</span>
<span class="w">        </span><span class="k">else</span><span class="w"> </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;%d&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">arr</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">high</span><span class="p">)</span><span class="w"> </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot; &quot;</span><span class="p">);</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;]</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">right</span><span class="p">;</span><span class="w">  </span><span class="c1">// 返回基准的最终位置</span>
<span class="p">}</span>

<span class="c1">// 快速排序主函数</span>
<span class="kt">void</span><span class="w"> </span><span class="nf">quickSort</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">arr</span><span class="p">[],</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">low</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">high</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">depth</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">low</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">high</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="c1">// pi是分区后基准的索引</span>
<span class="w">        </span><span class="kt">int</span><span class="w"> </span><span class="n">pi</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">partition</span><span class="p">(</span><span class="n">arr</span><span class="p">,</span><span class="w"> </span><span class="n">low</span><span class="p">,</span><span class="w"> </span><span class="n">high</span><span class="p">,</span><span class="w"> </span><span class="n">depth</span><span class="p">);</span>

<span class="w">        </span><span class="c1">// 递归排序左半部分</span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">low</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">pi</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mi">1</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">depth</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">++</span><span class="p">)</span><span class="w"> </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;  &quot;</span><span class="p">);</span>
<span class="w">            </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;递归左: [&quot;</span><span class="p">);</span>
<span class="w">            </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">low</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;=</span><span class="w"> </span><span class="n">pi</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">++</span><span class="p">)</span><span class="w"> </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;%d &quot;</span><span class="p">,</span><span class="w"> </span><span class="n">arr</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
<span class="w">            </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;]</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
<span class="w">            </span><span class="n">quickSort</span><span class="p">(</span><span class="n">arr</span><span class="p">,</span><span class="w"> </span><span class="n">low</span><span class="p">,</span><span class="w"> </span><span class="n">pi</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="n">depth</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="p">);</span>
<span class="w">        </span><span class="p">}</span>

<span class="w">        </span><span class="c1">// 递归排序右半部分  </span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">pi</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">high</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">depth</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">++</span><span class="p">)</span><span class="w"> </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;  &quot;</span><span class="p">);</span>
<span class="w">            </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;递归右: [&quot;</span><span class="p">);</span>
<span class="w">            </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">pi</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;=</span><span class="w"> </span><span class="n">high</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">++</span><span class="p">)</span><span class="w"> </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;%d &quot;</span><span class="p">,</span><span class="w"> </span><span class="n">arr</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
<span class="w">            </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;]</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
<span class="w">            </span><span class="n">quickSort</span><span class="p">(</span><span class="n">arr</span><span class="p">,</span><span class="w"> </span><span class="n">pi</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="n">high</span><span class="p">,</span><span class="w"> </span><span class="n">depth</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="p">);</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">}</span>

<span class="c1">// 包装函数</span>
<span class="kt">void</span><span class="w"> </span><span class="nf">quickSortWrapper</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">arr</span><span class="p">[],</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">n</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;原始数组: [&quot;</span><span class="p">);</span>
<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">n</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">++</span><span class="p">)</span><span class="w"> </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;%d &quot;</span><span class="p">,</span><span class="w"> </span><span class="n">arr</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
<span class="w">    </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;]</span><span class="se">\n\n</span><span class="s">开始快速排序过程:</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

<span class="w">    </span><span class="n">quickSort</span><span class="p">(</span><span class="n">arr</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">);</span>

<span class="w">    </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;</span><span class="se">\n</span><span class="s">排序后数组: [&quot;</span><span class="p">);</span>
<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">n</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">++</span><span class="p">)</span><span class="w"> </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;%d &quot;</span><span class="p">,</span><span class="w"> </span><span class="n">arr</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
<span class="w">    </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;]</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">int</span><span class="w"> </span><span class="nf">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">arr</span><span class="p">[]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="mi">5</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="mi">4</span><span class="p">,</span><span class="w"> </span><span class="mi">6</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">3</span><span class="p">};</span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">sizeof</span><span class="p">(</span><span class="n">arr</span><span class="p">)</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="k">sizeof</span><span class="p">(</span><span class="n">arr</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>

<span class="w">    </span><span class="n">quickSortWrapper</span><span class="p">(</span><span class="n">arr</span><span class="p">,</span><span class="w"> </span><span class="n">n</span><span class="p">);</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>
<p><strong>请运行这段代码！</strong> 观察输出，你会看到：
- 每次分区的详细过程
- 元素的交换和基准的归位
- 递归的深度和范围</p>
<hr />
<h3 id="_21">第四层：专业角度的深度分析</h3>
<h4 id="41">4.1 时间复杂度分析</h4>
<ul>
<li><strong>最好情况</strong>：每次分区都很平衡（基准选中位数）</li>
<li>递归深度：O(log n)</li>
<li>每层工作量：O(n)</li>
<li>
<p><strong>时间复杂度：O(n log n)</strong></p>
</li>
<li>
<p><strong>最坏情况</strong>：每次分区都极度不平衡（数组已有序或逆序）</p>
</li>
<li>递归深度：O(n) </li>
<li>每层工作量：O(n)</li>
<li>
<p><strong>时间复杂度：O(n²)</strong></p>
</li>
<li>
<p><strong>平均情况</strong>：<strong>O(n log n)</strong></p>
</li>
<li>数学期望证明平均性能很好</li>
</ul>
<h4 id="42">4.2 空间复杂度</h4>
<ul>
<li><strong>最好情况</strong>：O(log n) - 递归栈深度</li>
<li><strong>最坏情况</strong>：O(n) - 递归栈深度</li>
<li><strong>是原地排序算法</strong>（除了递归栈，不需要额外空间）</li>
</ul>
<h4 id="43">4.3 稳定性</h4>
<ul>
<li><strong>快速排序是不稳定的</strong></li>
<li>原因：分区过程中的长距离交换可能改变相等元素的相对顺序</li>
</ul>
<h4 id="44">4.4 基准选择策略</h4>
<p>基准选择严重影响性能：</p>
<ol>
<li><strong>第一个/最后一个元素</strong>：简单但可能导致最坏情况</li>
<li><strong>随机选择</strong>：避免最坏情况的简单方法</li>
<li><strong>三数取中</strong>：选择首、中、尾三个元素的中位数</li>
<li><strong>随机化快速排序</strong>：实际应用中常用</li>
</ol>
<h4 id="45">4.5 优化技巧</h4>
<ol>
<li><strong>小数组使用插入排序</strong>：当子数组很小时（如&lt;10个元素），插入排序更高效</li>
<li><strong>尾递归优化</strong>：减少递归栈深度</li>
<li><strong>三路快排</strong>：处理有大量重复元素的情况</li>
</ol>
<h4 id="46">4.6 与归并排序的比较</h4>
<table>
<thead>
<tr>
<th>特性</th>
<th>快速排序</th>
<th>归并排序</th>
</tr>
</thead>
<tbody>
<tr>
<td>平均时间复杂度</td>
<td>O(n log n)</td>
<td>O(n log n)</td>
</tr>
<tr>
<td>最坏时间复杂度</td>
<td>O(n²)</td>
<td>O(n log n)</td>
</tr>
<tr>
<td>空间复杂度</td>
<td>O(log n)</td>
<td>O(n)</td>
</tr>
<tr>
<td>稳定性</td>
<td>不稳定</td>
<td>稳定</td>
</tr>
<tr>
<td>数据访问模式</td>
<td>局部性好，缓存友好</td>
<td>顺序访问</td>
</tr>
<tr>
<td>适用场景</td>
<td>通用内部排序</td>
<td>外部排序、链表排序</td>
</tr>
</tbody>
</table>
<hr />
<h3 id="_22">第五层：关键洞察与记忆技巧</h3>
<h4 id="51">5.1 核心思想总结</h4>
<ol>
<li><strong>"分区+递归"思维</strong>：选择基准 → 分区 → 基准归位 → 递归处理</li>
<li><strong>原地操作</strong>：通过交换在原始数组上操作，空间效率高</li>
<li><strong>平均性能优秀</strong>：实际应用中通常是最快的通用排序算法</li>
</ol>
<h4 id="52">5.2 分区过程的关键点</h4>
<ul>
<li><strong>双指针技巧</strong>：左右指针向中间扫描</li>
<li><strong>交换策略</strong>：找到违规元素就交换</li>
<li><strong>基准归位</strong>：最终将基准放到正确位置</li>
</ul>
<h4 id="53">5.3 实际应用建议</h4>
<ul>
<li><strong>随机化基准</strong>：避免最坏情况</li>
<li><strong>结合插入排序</strong>：小数组优化</li>
<li><strong>注意稳定性需求</strong>：如果需要稳定排序，选择其他算法</li>
</ul>
<hr />
<h3 id="_23">总结：快速排序的专业理解路径</h3>
<ol>
<li><strong>生活化类比</strong>：整理书架的分区过程</li>
<li><strong>手动模拟</strong>：在纸上演练分区和递归的完整流程</li>
<li><strong>代码追踪</strong>：通过详细打印理解每一步的执行</li>
<li><strong>复杂度分析</strong>：理解为什么平均O(n log n)、最坏O(n²)</li>
<li><strong>对比思考</strong>：与归并排序、堆排序等其他O(n log n)算法比较</li>
</ol>
<h3 id="partition">深入理解 partition 函数中的循环条件</h3>
<h4 id="_24">循环条件的意义</h4>
<div class="highlight"><pre><span></span><code><span class="k">while</span><span class="w"> </span><span class="p">(</span><span class="n">i</span><span class="w"> </span><span class="o">&lt;=</span><span class="w"> </span><span class="n">j</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="c1">// ...</span>
<span class="p">}</span>
</code></pre></div>
<p><strong>这个条件的核心目的是：确保两个指针 <code>i</code> 和 <code>j</code> 在相遇或交叉时停止循环。</strong></p>
<p>让我们通过一个具体的例子来理解：</p>
<p>假设数组为：<code>[5, 2, 4, 6, 1, 3]</code>，pivot = 5</p>
<h5 id="_25">执行过程：</h5>
<p><strong>初始状态：</strong></p>
<div class="highlight"><pre><span></span><code>i → 2 (索引1)
j → 3 (索引5)
数组: [5, 2, 4, 6, 1, 3]
</code></pre></div>
<p><strong>步骤1：</strong> i 向右移动，找到第一个 &gt;5 的元素</p>
<ul>
<li>i 停在 6 (索引3)</li>
</ul>
<p><strong>步骤2：</strong> j 向左移动，找到第一个 &lt;5 的元素<br />
- j 停在 1 (索引4)</p>
<p><strong>步骤3：</strong> 交换 6 和 1
<div class="highlight"><pre><span></span><code>数组变为: [5, 2, 4, 1, 6, 3]
i → 6 (索引4)
j → 1 (索引3)
</code></pre></div></p>
<p><strong>此时 i &gt; j，循环应该停止！</strong></p>
<p>如果条件是 <code>i &lt; j</code>，循环会继续，但这是错误的，因为指针已经交叉，继续操作会导致逻辑错误。</p>
<h4 id="i-j-i-j">为什么需要 <code>i &lt;= j</code> 而不是 <code>i &lt; j</code></h4>
<ol>
<li><strong>处理相遇情况</strong>：</li>
<li>当 <code>i == j</code> 时，当前元素还没有被检查</li>
<li>
<p>我们需要确保这个元素也被正确处理</p>
</li>
<li>
<p><strong>防止指针越界</strong>：</p>
</li>
<li>
<p>如果只用 <code>i &lt; j</code>，在某些情况下指针可能会超出数组边界</p>
</li>
<li>
<p><strong>确保分区完整性</strong>：</p>
</li>
<li>只有当 <code>i &gt; j</code> 时，才说明所有元素都已经检查完毕</li>
</ol>
<h4 id="i-j">内层循环中的 <code>i &lt;= j</code> 条件</h4>
<div class="highlight"><pre><span></span><code><span class="k">while</span><span class="w"> </span><span class="p">(</span><span class="n">i</span><span class="w"> </span><span class="o">&lt;=</span><span class="w"> </span><span class="n">j</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="w"> </span><span class="o">&lt;=</span><span class="w"> </span><span class="n">pivot</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">i</span><span class="o">++</span><span class="p">;</span>
<span class="p">}</span>
<span class="k">while</span><span class="w"> </span><span class="p">(</span><span class="n">i</span><span class="w"> </span><span class="o">&lt;=</span><span class="w"> </span><span class="n">j</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">a</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="w"> </span><span class="o">&gt;=</span><span class="w"> </span><span class="n">pivot</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">j</span><span class="o">--</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>
<p><strong>这里的 <code>i &lt;= j</code> 同样重要：</strong></p>
<ol>
<li><strong>防止指针越界</strong>：</li>
<li>
<p>确保在移动指针时不会超出当前分区的范围</p>
</li>
<li>
<p><strong>提前终止</strong>：</p>
</li>
<li>
<p>当指针相遇或交叉时，立即停止内层循环</p>
</li>
<li>
<p><strong>保持逻辑一致性</strong>：</p>
</li>
<li>外层循环检查 <code>i &lt;= j</code>，内层循环也要相应检查</li>
</ol>
<h4 id="_26">完整的执行流程示例</h4>
<p>让我们再看一次完整的执行过程：</p>
<div class="highlight"><pre><span></span><code>初始: [5, 2, 4, 6, 1, 3], pivot=5, i=1, j=5

循环1:
  i 移动: 2≤5 → 4≤5 → 6&gt;5 (停在索引3)
  j 移动: 3≥5? 否 → 停在索引5
  交换 6↔3: [5, 2, 4, 3, 1, 6], i=4, j=4

循环2:
  i 移动: 1≤5? 是 → i=5
  j 移动: 1≥5? 否 → 停在索引4
  现在 i=5, j=4 → i&gt;j → 循环结束

最终交换: a[0]↔a[4]: [1, 2, 4, 3, 5, 6]
</code></pre></div>
<h4 id="i-j_1">如果改为 <code>i &lt; j</code> 会发生什么？</h4>
<p>如果我们将条件改为 <code>while (i &lt; j)</code>：</p>
<div class="highlight"><pre><span></span><code>在最后一次循环时：
i=4, j=4 → i==j → 循环不执行
但此时元素 1 还没有被正确处理！
</code></pre></div>
<p>这样会导致分区不完整，排序结果错误。</p>
<h4 id="_27">总结</h4>
<p><strong><code>i &lt;= j</code> 条件的重要性：</strong></p>
<ol>
<li><strong>完整性</strong>：确保所有元素都被检查</li>
<li><strong>安全性</strong>：防止指针越界</li>
<li><strong>正确性</strong>：保证分区逻辑的正确执行</li>
<li><strong>终止性</strong>：在合适的时机终止循环</li>
</ol>
<p>这个条件是快速排序分区算法的核心，它确保了：
- 左指针 <code>i</code> 找到所有应该放在右边的元素
- 右指针 <code>j</code> 找到所有应该放在左边的元素
- 最终 <code>pivot</code> 被放置到正确的位置</p>
<p>理解了这一点，你就掌握了快速排序分区算法的精髓！</p>
<h3 id="_28">代码</h3>
<div class="highlight"><pre><span></span><code><span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;stdio.h&gt;</span>

<span class="c1">// 基础版本的partition函数</span>
<span class="kt">int</span><span class="w"> </span><span class="nf">partition</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">a</span><span class="p">[],</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">start</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">end</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">pivot</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">a</span><span class="p">[</span><span class="n">start</span><span class="p">];</span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">start</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">j</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">end</span><span class="p">;</span>

<span class="w">    </span><span class="k">while</span><span class="w"> </span><span class="p">(</span><span class="n">i</span><span class="w"> </span><span class="o">&lt;=</span><span class="w"> </span><span class="n">j</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="k">while</span><span class="w"> </span><span class="p">(</span><span class="n">i</span><span class="w"> </span><span class="o">&lt;=</span><span class="w"> </span><span class="n">j</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="w"> </span><span class="o">&lt;=</span><span class="w"> </span><span class="n">pivot</span><span class="p">)</span><span class="w"> </span><span class="n">i</span><span class="o">++</span><span class="p">;</span>
<span class="w">        </span><span class="k">while</span><span class="w"> </span><span class="p">(</span><span class="n">i</span><span class="w"> </span><span class="o">&lt;=</span><span class="w"> </span><span class="n">j</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">a</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="w"> </span><span class="o">&gt;=</span><span class="w"> </span><span class="n">pivot</span><span class="p">)</span><span class="w"> </span><span class="n">j</span><span class="o">--</span><span class="p">;</span>

<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">j</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="kt">int</span><span class="w"> </span><span class="n">temp</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
<span class="w">            </span><span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">a</span><span class="p">[</span><span class="n">j</span><span class="p">];</span>
<span class="w">            </span><span class="n">a</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">temp</span><span class="p">;</span>
<span class="w">            </span><span class="n">i</span><span class="o">++</span><span class="p">;</span>
<span class="w">            </span><span class="n">j</span><span class="o">--</span><span class="p">;</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="n">a</span><span class="p">[</span><span class="n">start</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">a</span><span class="p">[</span><span class="n">j</span><span class="p">];</span>
<span class="w">    </span><span class="n">a</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">pivot</span><span class="p">;</span>

<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">j</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span><span class="w"> </span><span class="nf">quicksort</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">a</span><span class="p">[],</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">start</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">end</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">mid</span><span class="p">;</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">end</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="n">start</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">mid</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">partition</span><span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="n">start</span><span class="p">,</span><span class="w"> </span><span class="n">end</span><span class="p">);</span>
<span class="w">        </span><span class="n">quicksort</span><span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="n">start</span><span class="p">,</span><span class="w"> </span><span class="n">mid</span><span class="mi">-1</span><span class="p">);</span>
<span class="w">        </span><span class="n">quicksort</span><span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="n">mid</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="n">end</span><span class="p">);</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">}</span>

<span class="c1">// 测试函数</span>
<span class="kt">int</span><span class="w"> </span><span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">arr</span><span class="p">[]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="mi">5</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="mi">4</span><span class="p">,</span><span class="w"> </span><span class="mi">6</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">3</span><span class="p">};</span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">sizeof</span><span class="p">(</span><span class="n">arr</span><span class="p">)</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="k">sizeof</span><span class="p">(</span><span class="n">arr</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>

<span class="w">    </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;原始数组: &quot;</span><span class="p">);</span>
<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">n</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">++</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;%d &quot;</span><span class="p">,</span><span class="w"> </span><span class="n">arr</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

<span class="w">    </span><span class="n">quicksort</span><span class="p">(</span><span class="n">arr</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="n">n</span><span class="mi">-1</span><span class="p">);</span>

<span class="w">    </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;排序后数组: &quot;</span><span class="p">);</span>
<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">n</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">++</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;%d &quot;</span><span class="p">,</span><span class="w"> </span><span class="n">arr</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>
<div class="highlight"><pre><span></span><code><span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;stdio.h&gt;</span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;stdlib.h&gt;</span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;string.h&gt;</span>

<span class="cp">#define MAX_STUDENTS 100</span>
<span class="cp">#define NAME_LEN     50</span>

<span class="k">typedef</span><span class="w"> </span><span class="k">struct</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="kt">char</span><span class="w"> </span><span class="n">name</span><span class="p">[</span><span class="n">NAME_LEN</span><span class="p">];</span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">score</span><span class="p">;</span>
<span class="p">}</span><span class="w"> </span><span class="n">Student</span><span class="p">;</span>

<span class="n">Student</span><span class="w"> </span><span class="n">students</span><span class="p">[</span><span class="n">MAX_STUDENTS</span><span class="p">];</span>

<span class="kt">void</span><span class="w"> </span><span class="nf">swap</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">j</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">Student</span><span class="w"> </span><span class="n">temp</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">students</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
<span class="w">    </span><span class="n">students</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">students</span><span class="p">[</span><span class="n">j</span><span class="p">];</span>
<span class="w">    </span><span class="n">students</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">temp</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span><span class="w"> </span><span class="nf">partition</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">left</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">right</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="c1">// 选择第一个元素作为pivot</span>
<span class="w">    </span><span class="n">Student</span><span class="w"> </span><span class="n">pivot</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">students</span><span class="p">[</span><span class="n">left</span><span class="p">];</span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">left</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">j</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">right</span><span class="p">;</span>

<span class="w">    </span><span class="k">while</span><span class="w"> </span><span class="p">(</span><span class="n">i</span><span class="w"> </span><span class="o">&lt;=</span><span class="w"> </span><span class="n">j</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="c1">// 从左边找第一个小于pivot的元素（因为我们是从高到低排序）</span>
<span class="w">        </span><span class="k">while</span><span class="w"> </span><span class="p">(</span><span class="n">i</span><span class="w"> </span><span class="o">&lt;=</span><span class="w"> </span><span class="n">j</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">students</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">score</span><span class="w"> </span><span class="o">&gt;=</span><span class="w"> </span><span class="n">pivot</span><span class="p">.</span><span class="n">score</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="n">i</span><span class="o">++</span><span class="p">;</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">        </span><span class="c1">// 从右边找第一个大于pivot的元素</span>
<span class="w">        </span><span class="k">while</span><span class="w"> </span><span class="p">(</span><span class="n">i</span><span class="w"> </span><span class="o">&lt;=</span><span class="w"> </span><span class="n">j</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">students</span><span class="p">[</span><span class="n">j</span><span class="p">].</span><span class="n">score</span><span class="w"> </span><span class="o">&lt;=</span><span class="w"> </span><span class="n">pivot</span><span class="p">.</span><span class="n">score</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="n">j</span><span class="o">--</span><span class="p">;</span>
<span class="w">        </span><span class="p">}</span>

<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">j</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="n">swap</span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="w"> </span><span class="n">j</span><span class="p">);</span>
<span class="w">            </span><span class="n">i</span><span class="o">++</span><span class="p">;</span>
<span class="w">            </span><span class="n">j</span><span class="o">--</span><span class="p">;</span><span class="w">  </span><span class="c1">// 修正：j--- 改为 j--</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="c1">// 将pivot放到正确位置</span>
<span class="w">    </span><span class="n">swap</span><span class="p">(</span><span class="n">left</span><span class="p">,</span><span class="w"> </span><span class="n">j</span><span class="p">);</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">j</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span><span class="w"> </span><span class="nf">quick_sort</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">left</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">right</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">mid</span><span class="p">;</span><span class="w">  </span><span class="c1">// 修正：改为int类型</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">left</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">right</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">mid</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">partition</span><span class="p">(</span><span class="n">left</span><span class="p">,</span><span class="w"> </span><span class="n">right</span><span class="p">);</span>
<span class="w">        </span><span class="n">quick_sort</span><span class="p">(</span><span class="n">left</span><span class="p">,</span><span class="w"> </span><span class="n">mid</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mi">1</span><span class="p">);</span>
<span class="w">        </span><span class="n">quick_sort</span><span class="p">(</span><span class="n">mid</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="n">right</span><span class="p">);</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">}</span>

<span class="kt">int</span><span class="w"> </span><span class="nf">main</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="kt">FILE</span><span class="w"> </span><span class="o">*</span><span class="n">file</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">fopen</span><span class="p">(</span><span class="s">&quot;03_students.txt&quot;</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;r&quot;</span><span class="p">);</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="o">!</span><span class="n">file</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;错误：无法打开文件 03_students.txt</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">n</span><span class="p">;</span>
<span class="w">    </span><span class="n">fscanf</span><span class="p">(</span><span class="n">file</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;%d&quot;</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">n</span><span class="p">);</span>

<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">n</span><span class="w"> </span><span class="o">&lt;=</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="o">||</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="n">MAX_STUDENTS</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;学生人数无效：%d（应为 1-%d）</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">n</span><span class="p">,</span><span class="w"> </span><span class="n">MAX_STUDENTS</span><span class="p">);</span>
<span class="w">        </span><span class="n">fclose</span><span class="p">(</span><span class="n">file</span><span class="p">);</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">n</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">++</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">fscanf</span><span class="p">(</span><span class="n">file</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;%s %d&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">students</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">name</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">students</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">score</span><span class="p">);</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span><span class="n">fclose</span><span class="p">(</span><span class="n">file</span><span class="p">);</span>

<span class="w">    </span><span class="n">quick_sort</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mi">1</span><span class="p">);</span>

<span class="w">    </span><span class="c1">// 输出结果</span>
<span class="w">    </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;</span><span class="se">\n</span><span class="s">快速排序后按成绩从高到低排序的学生名单：</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">n</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">++</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;%s %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">students</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">name</span><span class="p">,</span><span class="w"> </span><span class="n">students</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">score</span><span class="p">);</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>
<h2 id="04_linear_search">04_linear_search</h2>
<p>省略。主要看快速选择：</p>
<p>现在重点实现找出第k小元素的算法。基于快速排序的partition思想，我们可以在平均情况 Θ(n) 时间内解决这个问题。</p>
<h4 id="k">基于快速选择的第k小元素查找算法</h4>
<p>这个算法（称为快速选择）是快速排序的变种：</p>
<ol>
<li>使用partition函数将数组分成两部分</li>
<li>根据pivot的位置决定继续在哪个部分搜索</li>
<li>只递归处理包含第k小元素的那一半，而不是完全排序</li>
</ol>
<div class="highlight"><pre><span></span><code><span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;stdio.h&gt;</span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;stdlib.h&gt;</span>

<span class="c1">// 交换函数</span>
<span class="kt">void</span><span class="w"> </span><span class="nf">swap</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="o">*</span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="o">*</span><span class="n">b</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">temp</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">*</span><span class="n">a</span><span class="p">;</span>
<span class="w">    </span><span class="o">*</span><span class="n">a</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">*</span><span class="n">b</span><span class="p">;</span>
<span class="w">    </span><span class="o">*</span><span class="n">b</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">temp</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">// 分区函数 - 选择第一个元素作为pivot</span>
<span class="kt">int</span><span class="w"> </span><span class="nf">partition</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">a</span><span class="p">[],</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">start</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">end</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">pivot</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">a</span><span class="p">[</span><span class="n">start</span><span class="p">];</span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">start</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">j</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">end</span><span class="p">;</span>

<span class="w">    </span><span class="k">while</span><span class="w"> </span><span class="p">(</span><span class="n">i</span><span class="w"> </span><span class="o">&lt;=</span><span class="w"> </span><span class="n">j</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="k">while</span><span class="w"> </span><span class="p">(</span><span class="n">i</span><span class="w"> </span><span class="o">&lt;=</span><span class="w"> </span><span class="n">j</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="w"> </span><span class="o">&lt;=</span><span class="w"> </span><span class="n">pivot</span><span class="p">)</span><span class="w"> </span><span class="n">i</span><span class="o">++</span><span class="p">;</span>
<span class="w">        </span><span class="k">while</span><span class="w"> </span><span class="p">(</span><span class="n">i</span><span class="w"> </span><span class="o">&lt;=</span><span class="w"> </span><span class="n">j</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">a</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="w"> </span><span class="o">&gt;=</span><span class="w"> </span><span class="n">pivot</span><span class="p">)</span><span class="w"> </span><span class="n">j</span><span class="o">--</span><span class="p">;</span>

<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">j</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="n">swap</span><span class="p">(</span><span class="o">&amp;</span><span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">],</span><span class="w"> </span><span class="o">&amp;</span><span class="n">a</span><span class="p">[</span><span class="n">j</span><span class="p">]);</span>
<span class="w">            </span><span class="n">i</span><span class="o">++</span><span class="p">;</span>
<span class="w">            </span><span class="n">j</span><span class="o">--</span><span class="p">;</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="c1">// 将pivot放到正确位置</span>
<span class="w">    </span><span class="n">swap</span><span class="p">(</span><span class="o">&amp;</span><span class="n">a</span><span class="p">[</span><span class="n">start</span><span class="p">],</span><span class="w"> </span><span class="o">&amp;</span><span class="n">a</span><span class="p">[</span><span class="n">j</span><span class="p">]);</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">j</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">// 随机选择pivot的分区函数 - 避免最坏情况</span>
<span class="kt">int</span><span class="w"> </span><span class="nf">randomized_partition</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">a</span><span class="p">[],</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">start</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">end</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="c1">// 随机选择pivot</span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">random_index</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">start</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">rand</span><span class="p">()</span><span class="w"> </span><span class="o">%</span><span class="w"> </span><span class="p">(</span><span class="n">end</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">start</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="p">);</span>
<span class="w">    </span><span class="n">swap</span><span class="p">(</span><span class="o">&amp;</span><span class="n">a</span><span class="p">[</span><span class="n">start</span><span class="p">],</span><span class="w"> </span><span class="o">&amp;</span><span class="n">a</span><span class="p">[</span><span class="n">random_index</span><span class="p">]);</span>

<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">partition</span><span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="n">start</span><span class="p">,</span><span class="w"> </span><span class="n">end</span><span class="p">);</span>
<span class="p">}</span>

<span class="c1">// 查找第k小元素的主要函数</span>
<span class="kt">int</span><span class="w"> </span><span class="nf">order_statistic</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">a</span><span class="p">[],</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">start</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">end</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">k</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">start</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">end</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="n">a</span><span class="p">[</span><span class="n">start</span><span class="p">];</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="c1">// 使用随机化partition避免最坏情况</span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">pivot_index</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">randomized_partition</span><span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="n">start</span><span class="p">,</span><span class="w"> </span><span class="n">end</span><span class="p">);</span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">pivot_index</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">start</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span><span class="w">  </span><span class="c1">// pivot是当前范围内的第i小元素</span>

<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">k</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">i</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="c1">// 找到了第k小的元素</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="n">a</span><span class="p">[</span><span class="n">pivot_index</span><span class="p">];</span>
<span class="w">    </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">k</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">i</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="c1">// 在第k小的元素在前半部分</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="n">order_statistic</span><span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="n">start</span><span class="p">,</span><span class="w"> </span><span class="n">pivot_index</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="n">k</span><span class="p">);</span>
<span class="w">    </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="c1">// 在第k小的元素在后半部分</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="n">order_statistic</span><span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="n">pivot_index</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="n">end</span><span class="p">,</span><span class="w"> </span><span class="n">k</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">i</span><span class="p">);</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">}</span>

<span class="c1">// 包装函数，简化调用</span>
<span class="kt">int</span><span class="w"> </span><span class="nf">find_kth_smallest</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">a</span><span class="p">[],</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">n</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">k</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">k</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="o">||</span><span class="w"> </span><span class="n">k</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="n">n</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;错误：k 必须在 1 到 %d 之间</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">n</span><span class="p">);</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="mi">-1</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">order_statistic</span><span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="n">k</span><span class="p">);</span>
<span class="p">}</span>

<span class="c1">// 测试函数</span>
<span class="kt">int</span><span class="w"> </span><span class="nf">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">arr</span><span class="p">[]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="mi">5</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="mi">4</span><span class="p">,</span><span class="w"> </span><span class="mi">6</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">3</span><span class="p">};</span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">sizeof</span><span class="p">(</span><span class="n">arr</span><span class="p">)</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="k">sizeof</span><span class="p">(</span><span class="n">arr</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>

<span class="w">    </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;原始数组: &quot;</span><span class="p">);</span>
<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">n</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">++</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;%d &quot;</span><span class="p">,</span><span class="w"> </span><span class="n">arr</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;</span><span class="se">\n\n</span><span class="s">&quot;</span><span class="p">);</span>

<span class="w">    </span><span class="c1">// 测试查找各种顺序统计量</span>
<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">k</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span><span class="w"> </span><span class="n">k</span><span class="w"> </span><span class="o">&lt;=</span><span class="w"> </span><span class="n">n</span><span class="p">;</span><span class="w"> </span><span class="n">k</span><span class="o">++</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="kt">int</span><span class="w"> </span><span class="n">result</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">find_kth_smallest</span><span class="p">(</span><span class="n">arr</span><span class="p">,</span><span class="w"> </span><span class="n">n</span><span class="p">,</span><span class="w"> </span><span class="n">k</span><span class="p">);</span>
<span class="w">        </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;第 %d 小的元素是: %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">k</span><span class="p">,</span><span class="w"> </span><span class="n">result</span><span class="p">);</span>

<span class="w">        </span><span class="c1">// 重新复制数组，因为order_statistic会修改原数组</span>
<span class="w">        </span><span class="kt">int</span><span class="w"> </span><span class="n">temp_arr</span><span class="p">[]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="mi">5</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="mi">4</span><span class="p">,</span><span class="w"> </span><span class="mi">6</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">3</span><span class="p">};</span>
<span class="w">        </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">n</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">++</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="n">arr</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">temp_arr</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="c1">// 单独测试一些边界情况</span>
<span class="w">    </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;</span><span class="se">\n</span><span class="s">--- 边界情况测试 ---</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">test_arr</span><span class="p">[]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="mi">5</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="mi">4</span><span class="p">,</span><span class="w"> </span><span class="mi">6</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">3</span><span class="p">};</span>

<span class="w">    </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;最小值 (k=1): %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">find_kth_smallest</span><span class="p">(</span><span class="n">test_arr</span><span class="p">,</span><span class="w"> </span><span class="n">n</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">));</span>

<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">n</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">++</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">test_arr</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">5</span><span class="p">;</span><span class="w">  </span><span class="c1">// 所有元素相同</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;所有元素相同时的第3小元素: %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">find_kth_smallest</span><span class="p">(</span><span class="n">test_arr</span><span class="p">,</span><span class="w"> </span><span class="n">n</span><span class="p">,</span><span class="w"> </span><span class="mi">3</span><span class="p">));</span>

<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>
<h2 id="05_binary_search">05_binary_search</h2>
<div class="highlight"><pre><span></span><code><span class="kt">int</span><span class="w"> </span><span class="nf">binarysearch</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">number</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">mid</span><span class="p">,</span><span class="w"> </span><span class="n">start</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="n">end</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">LEN</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span>

<span class="w">    </span><span class="cm">/* 假定a是排好序的 */</span>
<span class="w">    </span><span class="c1">// 左开右开：a[0...LEN-1]</span>
<span class="w">    </span><span class="c1">// 左开右闭：a[0...LEN]</span>
<span class="w">    </span><span class="cm">/* mustbe(start, end, number)，因为a[start..end]就是整个数组a[0..LEN-1] */</span>
<span class="w">    </span><span class="k">while</span><span class="w"> </span><span class="p">(</span><span class="n">start</span><span class="w"> </span><span class="o">&lt;=</span><span class="w"> </span><span class="n">end</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="cm">/* mustbe(start, end, number)，因为一开始进入循环时是正确的，每次循环也都维护了这个条件 */</span>
<span class="w">        </span><span class="n">mid</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">start</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">end</span><span class="p">)</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="mi">2</span><span class="p">;</span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">a</span><span class="p">[</span><span class="n">mid</span><span class="p">]</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">number</span><span class="p">)</span>
<span class="w">            </span><span class="cm">/* 既然a是排好序的，a[start..mid]应该都比number小，所以mustbe(mid+1, end, number) */</span>
<span class="w">            </span><span class="n">start</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">mid</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span>
<span class="w">            </span><span class="cm">/* 维护了mustbe(start, end, number) */</span>
<span class="w">        </span><span class="k">else</span><span class="w"> </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">a</span><span class="p">[</span><span class="n">mid</span><span class="p">]</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="n">number</span><span class="p">)</span>
<span class="w">            </span><span class="cm">/* 既然a是排好序的，a[mid..end]应该都比number大，所以mustbe(start, mid-1, number) */</span>
<span class="w">            </span><span class="n">end</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">mid</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span>
<span class="w">            </span><span class="cm">/* 维护了mustbe(start, end, number) */</span>
<span class="w">        </span><span class="k">else</span>
<span class="w">            </span><span class="cm">/* a[mid] == number，说明找到了 */</span>
<span class="w">            </span><span class="k">return</span><span class="w"> </span><span class="n">mid</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span><span class="cm">/* </span>
<span class="cm">     * mustbe(start, end, number)一直被循环维护着，到这里应该仍然成立，在a[start..end]范围之外一定不存在number，</span>
<span class="cm">     * 但现在a[start..end]是空序列，在这个范围之外的正是整个数组a，因此整个数组a中都不存在number</span>
<span class="cm">     */</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="mi">-1</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>
<p>见algorithm目录的题目。这里关注一些里面的拓展。</p>
<blockquote>
<p>1、本节的折半查找算法有一个特点：如果待查找的元素在数组中有多个则返回其中任意一个，以本节定义的数组<code>int a[8] = { 1, 2, 2, 2, 5, 6, 8, 9 };</code>为例，如果调用<code>binarysearch(2)</code>则返回3，即<code>a[3]</code>，而有些场合下要求这样的查找返回<code>a[1]</code>，也就是说，如果待查找的元素在数组中有多个则返回第一个。请修改折半查找算法实现这一特性。</p>
<p>2、编写一个函数<code>double mysqrt(double y);</code>求<code>y</code>的正平方根，参数<code>y</code>是正实数。我们用折半查找来找这个平方根，在从0到<code>y</code>之间必定有一个取值是<code>y</code>的平方根，如果我们查找的数<code>x</code>比<code>y</code>的平方根小，则x2<y，如果我们查找的数<code>x</code>比<code>y</code>的平方根大，则x2>y，我们可以据此缩小查找范围，当我们查找的数足够准确时（比如满足|x2-y|&lt;0.001），就可以认为找到了<code>y</code>的平方根。思考一下这个算法需要迭代多少次？迭代次数的多少由什么因素决定？</p>
<p>3、编写一个函数<code>double mypow(double x, int n);</code>求<code>x</code>的<code>n</code>次方，参数<code>n</code>是正整数。最简单的算法是：</p>
<div class="highlight"><pre><span></span><code>double product = 1;
for (i = 0; i &lt; n; i++)
  product *= x;
</code></pre></div>
<p>这个算法的时间复杂度是Θ(n)。其实有更好的办法，比如<code>mypow(x, 8)</code>，第一次循环算出x·x=x2，第二次循环算出x2·x2=x4，第三次循环算出4·x4=x8。这样只需要三次循环，时间复杂度是Θ(lgn)。思考一下如果<code>n</code>不是2的整数次幂应该怎么处理。请分别用递归和循环实现这个算法。</p>
<p>从以上几题可以看出，折半查找的思想有非常广泛的应用，不仅限于从一组排好序的元素中找出某个元素的位置，还可以解决很多类似的问题。[<a href="https://akaedu.github.io/book/bi01.html#bibli.pearls">编程珠玑]</a>对于折半查找的各种应用和优化技巧有非常详细的介绍。</p>
</blockquote>
<h3 id="_29">问题一：返回第一个匹配元素的二分查找</h3>
<h4 id="_30">算法思路</h4>
<p>要返回第一个匹配元素，我们需要在找到目标值时继续向左搜索，直到找到第一个出现的位置。</p>
<h4 id="_31">代码实现</h4>
<div class="highlight"><pre><span></span><code><span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;stdio.h&gt;</span>

<span class="c1">// 返回第一个匹配元素的二分查找</span>
<span class="kt">int</span><span class="w"> </span><span class="nf">binarysearch_first</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">a</span><span class="p">[],</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">n</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">target</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">start</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">end</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">result</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">-1</span><span class="p">;</span><span class="w">  </span><span class="c1">// 记录找到的位置</span>

<span class="w">    </span><span class="k">while</span><span class="w"> </span><span class="p">(</span><span class="n">start</span><span class="w"> </span><span class="o">&lt;=</span><span class="w"> </span><span class="n">end</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="kt">int</span><span class="w"> </span><span class="n">mid</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">start</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="p">(</span><span class="n">end</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">start</span><span class="p">)</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="mi">2</span><span class="p">;</span><span class="w">  </span><span class="c1">// 防止溢出</span>

<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">a</span><span class="p">[</span><span class="n">mid</span><span class="p">]</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">target</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="n">result</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">mid</span><span class="p">;</span><span class="w">      </span><span class="c1">// 记录当前位置</span>
<span class="w">            </span><span class="n">end</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">mid</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span><span class="w">     </span><span class="c1">// 继续在左半部分查找</span>
<span class="w">        </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">a</span><span class="p">[</span><span class="n">mid</span><span class="p">]</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">target</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="n">start</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">mid</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span><span class="w">   </span><span class="c1">// 目标在右半部分</span>
<span class="w">        </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="n">end</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">mid</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span><span class="w">     </span><span class="c1">// 目标在左半部分</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">result</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">// 测试函数</span>
<span class="kt">int</span><span class="w"> </span><span class="nf">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">a</span><span class="p">[</span><span class="mi">8</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="mi">5</span><span class="p">,</span><span class="w"> </span><span class="mi">6</span><span class="p">,</span><span class="w"> </span><span class="mi">8</span><span class="p">,</span><span class="w"> </span><span class="mi">9</span><span class="p">};</span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">8</span><span class="p">;</span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">target</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">2</span><span class="p">;</span>

<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">index</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">binarysearch_first</span><span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="n">n</span><span class="p">,</span><span class="w"> </span><span class="n">target</span><span class="p">);</span>

<span class="w">    </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;数组: &quot;</span><span class="p">);</span>
<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">n</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">++</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;%d &quot;</span><span class="p">,</span><span class="w"> </span><span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">index</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="mi">-1</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;元素 %d 第一次出现的位置: a[%d] = %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">target</span><span class="p">,</span><span class="w"> </span><span class="n">index</span><span class="p">,</span><span class="w"> </span><span class="n">a</span><span class="p">[</span><span class="n">index</span><span class="p">]);</span>
<span class="w">    </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;元素 %d 未找到</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">target</span><span class="p">);</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>
<h4 id="_32">算法分析</h4>
<p><strong>时间复杂度</strong>：O(log n)
- 每次迭代将搜索范围减半
- 即使需要继续搜索，总体时间复杂度仍为对数级</p>
<p><strong>关键改进</strong>：
- 找到目标时不立即返回，而是记录位置并继续向左搜索
- 最终返回第一个匹配的位置</p>
<hr />
<h3 id="_33">问题二：用二分查找求平方根</h3>
<h4 id="_34">算法思路</h4>
<p>利用二分查找在区间 [0, y] 中寻找平方根：
- 如果 mid² &lt; y，说明平方根在右半部分
- 如果 mid² &gt; y，说明平方根在左半部分
- 当 |mid² - y| &lt; 精度要求时停止</p>
<h4 id="_35">代码实现</h4>
<div class="highlight"><pre><span></span><code><span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;stdio.h&gt;</span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;math.h&gt;</span>

<span class="cp">#define EPSILON 0.001  </span><span class="c1">// 精度要求</span>

<span class="kt">double</span><span class="w"> </span><span class="nf">mysqrt</span><span class="p">(</span><span class="kt">double</span><span class="w"> </span><span class="n">y</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">y</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;错误：y 必须是非负数</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="mi">-1</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="c1">// 处理特殊情况</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">y</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="o">||</span><span class="w"> </span><span class="n">y</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">1</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="n">y</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="kt">double</span><span class="w"> </span><span class="n">low</span><span class="p">,</span><span class="w"> </span><span class="n">high</span><span class="p">;</span>

<span class="w">    </span><span class="c1">// 确定搜索区间</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">y</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="mi">1</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">low</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">y</span><span class="p">;</span>
<span class="w">        </span><span class="n">high</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">low</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="w">        </span><span class="n">high</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">y</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="kt">double</span><span class="w"> </span><span class="n">mid</span><span class="p">;</span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">iterations</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>

<span class="w">    </span><span class="k">while</span><span class="w"> </span><span class="p">(</span><span class="n">high</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">low</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="n">EPSILON</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">mid</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">low</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">high</span><span class="p">)</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="mi">2</span><span class="p">;</span>
<span class="w">        </span><span class="kt">double</span><span class="w"> </span><span class="n">square</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">mid</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">mid</span><span class="p">;</span>

<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">square</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">y</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="n">low</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">mid</span><span class="p">;</span>
<span class="w">        </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="n">high</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">mid</span><span class="p">;</span>
<span class="w">        </span><span class="p">}</span>

<span class="w">        </span><span class="n">iterations</span><span class="o">++</span><span class="p">;</span>
<span class="w">        </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;迭代 %d: mid = %.6f, mid² = %.6f, 误差 = %.6f</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span><span class="w"> </span>
<span class="w">               </span><span class="n">iterations</span><span class="p">,</span><span class="w"> </span><span class="n">mid</span><span class="p">,</span><span class="w"> </span><span class="n">square</span><span class="p">,</span><span class="w"> </span><span class="n">fabs</span><span class="p">(</span><span class="n">square</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">y</span><span class="p">));</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;总共迭代次数: %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">iterations</span><span class="p">);</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="p">(</span><span class="n">low</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">high</span><span class="p">)</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="mi">2</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">// 测试函数</span>
<span class="kt">int</span><span class="w"> </span><span class="nf">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="kt">double</span><span class="w"> </span><span class="n">test_cases</span><span class="p">[]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="mf">2.0</span><span class="p">,</span><span class="w"> </span><span class="mf">4.0</span><span class="p">,</span><span class="w"> </span><span class="mf">10.0</span><span class="p">,</span><span class="w"> </span><span class="mf">0.25</span><span class="p">,</span><span class="w"> </span><span class="mf">100.0</span><span class="p">};</span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">sizeof</span><span class="p">(</span><span class="n">test_cases</span><span class="p">)</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="k">sizeof</span><span class="p">(</span><span class="n">test_cases</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>

<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">n</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">++</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="kt">double</span><span class="w"> </span><span class="n">y</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">test_cases</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
<span class="w">        </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;</span><span class="se">\n</span><span class="s">计算 sqrt(%.2f):</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">y</span><span class="p">);</span>
<span class="w">        </span><span class="kt">double</span><span class="w"> </span><span class="n">result</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">mysqrt</span><span class="p">(</span><span class="n">y</span><span class="p">);</span>
<span class="w">        </span><span class="kt">double</span><span class="w"> </span><span class="n">actual</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">sqrt</span><span class="p">(</span><span class="n">y</span><span class="p">);</span>
<span class="w">        </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;计算结果: %.6f</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">result</span><span class="p">);</span>
<span class="w">        </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;标准库结果: %.6f</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">actual</span><span class="p">);</span>
<span class="w">        </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;绝对误差: %.6f</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">fabs</span><span class="p">(</span><span class="n">result</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">actual</span><span class="p">));</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>
<h4 id="_36">迭代次数分析</h4>
<p><strong>迭代次数由以下因素决定</strong>：
1. <strong>初始区间大小</strong>：区间越大，需要更多迭代
2. <strong>精度要求</strong>：精度越高（EPSILON越小），需要更多迭代
3. <strong>目标值的大小</strong>：值越大，需要的迭代次数可能越多</p>
<p><strong>数学推导</strong>：
- 每次迭代区间减半
- 初始区间大小：max(1, y)
- 需要的迭代次数：log₂(初始区间大小 / EPSILON)</p>
<p><strong>示例计算</strong>：
对于 y = 100, EPSILON = 0.001：
- 初始区间大小 = 100
- 迭代次数 ≈ log₂(100 / 0.001) ≈ log₂(100000) ≈ 17次</p>
<hr />
<h3 id="_37">问题三：快速幂算法</h3>
<h4 id="_38">算法原理</h4>
<p>利用分治思想：
- xⁿ = (x^(n/2))² （当n为偶数）
- xⁿ = x · (x^((n-1)/2))² （当n为奇数）</p>
<h4 id="_39">递归实现</h4>
<div class="highlight"><pre><span></span><code><span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;stdio.h&gt;</span>

<span class="c1">// 递归实现的快速幂</span>
<span class="kt">double</span><span class="w"> </span><span class="nf">mypow_recursive</span><span class="p">(</span><span class="kt">double</span><span class="w"> </span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">n</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="c1">// 基本情况</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">n</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span><span class="w"> </span><span class="k">return</span><span class="w"> </span><span class="mf">1.0</span><span class="p">;</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">n</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">1</span><span class="p">)</span><span class="w"> </span><span class="k">return</span><span class="w"> </span><span class="n">x</span><span class="p">;</span>

<span class="w">    </span><span class="c1">// 递归计算一半的幂</span>
<span class="w">    </span><span class="kt">double</span><span class="w"> </span><span class="n">half</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">mypow_recursive</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="mi">2</span><span class="p">);</span>

<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">n</span><span class="w"> </span><span class="o">%</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="c1">// n为偶数：xⁿ = (x^(n/2))²</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="n">half</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">half</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="c1">// n为奇数：xⁿ = x · (x^((n-1)/2))²</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">half</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">half</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">}</span>
</code></pre></div>
<h4 id="_40">循环实现</h4>
<div class="highlight"><pre><span></span><code><span class="c1">// 循环实现的快速幂</span>
<span class="kt">double</span><span class="w"> </span><span class="nf">mypow_iterative</span><span class="p">(</span><span class="kt">double</span><span class="w"> </span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">n</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="kt">double</span><span class="w"> </span><span class="n">result</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">1.0</span><span class="p">;</span>
<span class="w">    </span><span class="kt">double</span><span class="w"> </span><span class="n">base</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">x</span><span class="p">;</span>

<span class="w">    </span><span class="k">while</span><span class="w"> </span><span class="p">(</span><span class="n">n</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">n</span><span class="w"> </span><span class="o">%</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">1</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="c1">// 如果当前位为1，乘到结果中</span>
<span class="w">            </span><span class="n">result</span><span class="w"> </span><span class="o">*=</span><span class="w"> </span><span class="n">base</span><span class="p">;</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">        </span><span class="c1">// 基数平方</span>
<span class="w">        </span><span class="n">base</span><span class="w"> </span><span class="o">*=</span><span class="w"> </span><span class="n">base</span><span class="p">;</span>
<span class="w">        </span><span class="c1">// 指数右移一位</span>
<span class="w">        </span><span class="n">n</span><span class="w"> </span><span class="o">/=</span><span class="w"> </span><span class="mi">2</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">result</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>
<h4 id="_41">完整测试代码</h4>
<div class="highlight"><pre><span></span><code><span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;stdio.h&gt;</span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;math.h&gt;</span>

<span class="c1">// 朴素实现 - 时间复杂度 O(n)</span>
<span class="kt">double</span><span class="w"> </span><span class="nf">mypow_naive</span><span class="p">(</span><span class="kt">double</span><span class="w"> </span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">n</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="kt">double</span><span class="w"> </span><span class="n">result</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">1.0</span><span class="p">;</span>
<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">n</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">++</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">result</span><span class="w"> </span><span class="o">*=</span><span class="w"> </span><span class="n">x</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">result</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">// 递归实现的快速幂</span>
<span class="kt">double</span><span class="w"> </span><span class="nf">mypow_recursive</span><span class="p">(</span><span class="kt">double</span><span class="w"> </span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">n</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">n</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span><span class="w"> </span><span class="k">return</span><span class="w"> </span><span class="mf">1.0</span><span class="p">;</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">n</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">1</span><span class="p">)</span><span class="w"> </span><span class="k">return</span><span class="w"> </span><span class="n">x</span><span class="p">;</span>

<span class="w">    </span><span class="kt">double</span><span class="w"> </span><span class="n">half</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">mypow_recursive</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="mi">2</span><span class="p">);</span>

<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">n</span><span class="w"> </span><span class="o">%</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="n">half</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">half</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">half</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">half</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">}</span>

<span class="c1">// 循环实现的快速幂</span>
<span class="kt">double</span><span class="w"> </span><span class="nf">mypow_iterative</span><span class="p">(</span><span class="kt">double</span><span class="w"> </span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">n</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="kt">double</span><span class="w"> </span><span class="n">result</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">1.0</span><span class="p">;</span>
<span class="w">    </span><span class="kt">double</span><span class="w"> </span><span class="n">base</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">x</span><span class="p">;</span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">exponent</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">n</span><span class="p">;</span>

<span class="w">    </span><span class="k">while</span><span class="w"> </span><span class="p">(</span><span class="n">exponent</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">exponent</span><span class="w"> </span><span class="o">%</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">1</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="n">result</span><span class="w"> </span><span class="o">*=</span><span class="w"> </span><span class="n">base</span><span class="p">;</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">        </span><span class="n">base</span><span class="w"> </span><span class="o">*=</span><span class="w"> </span><span class="n">base</span><span class="p">;</span>
<span class="w">        </span><span class="n">exponent</span><span class="w"> </span><span class="o">/=</span><span class="w"> </span><span class="mi">2</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">result</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">// 性能测试</span>
<span class="kt">void</span><span class="w"> </span><span class="nf">performance_test</span><span class="p">(</span><span class="kt">double</span><span class="w"> </span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">n</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;</span><span class="se">\n</span><span class="s">测试: %.2f^%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="n">n</span><span class="p">);</span>

<span class="w">    </span><span class="c1">// 朴素方法</span>
<span class="w">    </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;朴素方法: &quot;</span><span class="p">);</span>
<span class="w">    </span><span class="kt">double</span><span class="w"> </span><span class="n">result1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">mypow_naive</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="n">n</span><span class="p">);</span>
<span class="w">    </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;%.6f</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">result1</span><span class="p">);</span>

<span class="w">    </span><span class="c1">// 递归快速幂</span>
<span class="w">    </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;递归快速幂: &quot;</span><span class="p">);</span>
<span class="w">    </span><span class="kt">double</span><span class="w"> </span><span class="n">result2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">mypow_recursive</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="n">n</span><span class="p">);</span>
<span class="w">    </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;%.6f</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">result2</span><span class="p">);</span>

<span class="w">    </span><span class="c1">// 循环快速幂</span>
<span class="w">    </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;循环快速幂: &quot;</span><span class="p">);</span>
<span class="w">    </span><span class="kt">double</span><span class="w"> </span><span class="n">result3</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">mypow_iterative</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="n">n</span><span class="p">);</span>
<span class="w">    </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;%.6f</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">result3</span><span class="p">);</span>

<span class="w">    </span><span class="c1">// 标准库（参考）</span>
<span class="w">    </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;标准库pow: &quot;</span><span class="p">);</span>
<span class="w">    </span><span class="kt">double</span><span class="w"> </span><span class="n">result4</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">pow</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="n">n</span><span class="p">);</span>
<span class="w">    </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;%.6f</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">result4</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">int</span><span class="w"> </span><span class="nf">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="c1">// 测试各种情况</span>
<span class="w">    </span><span class="kt">double</span><span class="w"> </span><span class="n">bases</span><span class="p">[]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="mf">2.0</span><span class="p">,</span><span class="w"> </span><span class="mf">3.0</span><span class="p">,</span><span class="w"> </span><span class="mf">1.5</span><span class="p">};</span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">exponents</span><span class="p">[]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="mi">10</span><span class="p">,</span><span class="w"> </span><span class="mi">15</span><span class="p">,</span><span class="w"> </span><span class="mi">20</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">7</span><span class="p">};</span><span class="w"> </span><span class="c1">// 包括非2的幂次</span>

<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="k">sizeof</span><span class="p">(</span><span class="n">bases</span><span class="p">)</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="k">sizeof</span><span class="p">(</span><span class="n">bases</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span><span class="w"> </span><span class="n">i</span><span class="o">++</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">j</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">j</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="k">sizeof</span><span class="p">(</span><span class="n">exponents</span><span class="p">)</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="k">sizeof</span><span class="p">(</span><span class="n">exponents</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span><span class="w"> </span><span class="n">j</span><span class="o">++</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="n">performance_test</span><span class="p">(</span><span class="n">bases</span><span class="p">[</span><span class="n">i</span><span class="p">],</span><span class="w"> </span><span class="n">exponents</span><span class="p">[</span><span class="n">j</span><span class="p">]);</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="c1">// 大数测试</span>
<span class="w">    </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;</span><span class="se">\n</span><span class="s">=== 大数性能测试 ===</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
<span class="w">    </span><span class="n">performance_test</span><span class="p">(</span><span class="mf">1.0001</span><span class="p">,</span><span class="w"> </span><span class="mi">10000</span><span class="p">);</span>

<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>
<h4 id="2">处理非2的整数次幂</h4>
<p><strong>关键洞察</strong>：任何正整数都可以表示为2的幂次之和</p>
<p><strong>处理方法</strong>：
- 将指数n用二进制表示
- xⁿ = x^(二进制表示的加权和) = ∏ x<sup>(2</sup>i) （对于所有二进制位为1的i）</p>
<p><strong>示例</strong>：计算 x¹³
- 13的二进制：1101 = 8 + 4 + 1
- x¹³ = x⁸ · x⁴ · x¹</p>
<h4 id="_42">时间复杂度分析</h4>
<ul>
<li><strong>朴素算法</strong>：O(n) - 需要n次乘法</li>
<li><strong>快速幂算法</strong>：O(log n) - 只需要log₂n次乘法</li>
</ul>
<p><strong>优势对比</strong>：
<div class="highlight"><pre><span></span><code>指数大小   朴素算法乘法次数   快速幂乘法次数
   16          16                4
  1024        1024              10
 10000       10000              14
</code></pre></div></p>
<hr />
<h3 id="_43">二分查找思想的广泛应用</h3>
<p>从以上问题可以看出，二分查找的核心思想——<strong>通过比较不断将问题规模减半</strong>——具有广泛的应用：</p>
<ol>
<li><strong>搜索问题</strong>：在有序集合中查找元素</li>
<li><strong>数值计算</strong>：求平方根、立方根等</li>
<li><strong>优化问题</strong>：寻找函数的最优解</li>
<li><strong>分治算法</strong>：快速幂、归并排序等</li>
</ol>
<h4 id="_44">二分查找的应用模式</h4>
<div class="highlight"><pre><span></span><code><span class="c1">// 二分查找的通用模式</span>
<span class="n">type</span><span class="w"> </span><span class="nf">binary_search</span><span class="p">(</span><span class="n">type</span><span class="w"> </span><span class="n">lower</span><span class="p">,</span><span class="w"> </span><span class="n">type</span><span class="w"> </span><span class="n">upper</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">while</span><span class="w"> </span><span class="p">(</span><span class="n">满足精度要求</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">type</span><span class="w"> </span><span class="n">mid</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">lower</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">upper</span><span class="p">)</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="mi">2</span><span class="p">;</span>

<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">满足条件</span><span class="p">(</span><span class="n">mid</span><span class="p">))</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="c1">// 根据问题调整搜索方向</span>
<span class="w">            </span><span class="n">lower</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">mid</span><span class="p">;</span><span class="w">  </span><span class="c1">// 或 upper = mid</span>
<span class="w">        </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="c1">// 调整另一个边界</span>
<span class="w">            </span><span class="n">upper</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">mid</span><span class="p">;</span><span class="w">  </span><span class="c1">// 或 lower = mid</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">最终结果</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>
<p>这种"减半治理"的思想是计算机科学中最重要的算法范式之一，体现了分而治之的智慧。</p>
<h2 id="06_stack_maze">06_stack_maze</h2>
<h3 id="_45">代码</h3>
<div class="highlight"><pre><span></span><code><span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;stdio.h&gt;</span>

<span class="cp">#define MAX_ROW 5</span>
<span class="cp">#define MAX_COL 5</span>

<span class="c1">// 坐标结构体</span>
<span class="k">struct</span><span class="w"> </span><span class="nc">point</span><span class="w"> </span><span class="p">{</span><span class="w"> </span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">row</span><span class="p">,</span><span class="w"> </span><span class="n">col</span><span class="p">;</span><span class="w"> </span>
<span class="p">}</span><span class="w"> </span><span class="n">stack</span><span class="p">[</span><span class="mi">512</span><span class="p">];</span>
<span class="kt">int</span><span class="w"> </span><span class="n">top</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>

<span class="c1">// 栈操作函数</span>
<span class="kt">void</span><span class="w"> </span><span class="nf">push</span><span class="p">(</span><span class="k">struct</span><span class="w"> </span><span class="nc">point</span><span class="w"> </span><span class="n">p</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">stack</span><span class="p">[</span><span class="n">top</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">p</span><span class="p">;</span>
<span class="w">    </span><span class="n">top</span><span class="o">++</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">struct</span><span class="w"> </span><span class="nc">point</span><span class="w"> </span><span class="n">pop</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">top</span><span class="o">--</span><span class="p">;</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">stack</span><span class="p">[</span><span class="n">top</span><span class="p">];</span>
<span class="p">}</span>

<span class="kt">int</span><span class="w"> </span><span class="n">is_empty</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">top</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">// 迷宫定义：0=通路，1=墙</span>
<span class="kt">int</span><span class="w"> </span><span class="n">maze</span><span class="p">[</span><span class="n">MAX_ROW</span><span class="p">][</span><span class="n">MAX_COL</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="p">{</span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">},</span>
<span class="w">    </span><span class="p">{</span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">},</span>
<span class="w">    </span><span class="p">{</span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">},</span>
<span class="w">    </span><span class="p">{</span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">},</span>
<span class="w">    </span><span class="p">{</span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">}</span>
<span class="p">};</span>

<span class="c1">// 前驱记录数组</span>
<span class="k">struct</span><span class="w"> </span><span class="nc">point</span><span class="w"> </span><span class="n">predecessor</span><span class="p">[</span><span class="n">MAX_ROW</span><span class="p">][</span><span class="n">MAX_COL</span><span class="p">];</span>

<span class="c1">// 初始化前驱数组</span>
<span class="kt">void</span><span class="w"> </span><span class="nf">init_predecessor</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">MAX_ROW</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">++</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">j</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">j</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">MAX_COL</span><span class="p">;</span><span class="w"> </span><span class="n">j</span><span class="o">++</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="n">predecessor</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">].</span><span class="n">row</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">-1</span><span class="p">;</span>
<span class="w">            </span><span class="n">predecessor</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">].</span><span class="n">col</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">-1</span><span class="p">;</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">}</span>

<span class="c1">// 可视化打印迷宫</span>
<span class="kt">void</span><span class="w"> </span><span class="nf">print_maze</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">MAX_ROW</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">++</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">j</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">j</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">MAX_COL</span><span class="p">;</span><span class="w"> </span><span class="n">j</span><span class="o">++</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">maze</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span>
<span class="w">                </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;. &quot;</span><span class="p">);</span><span class="w">  </span><span class="c1">// 未访问的通路</span>
<span class="w">            </span><span class="k">else</span><span class="w"> </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">maze</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">1</span><span class="p">)</span>
<span class="w">                </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;█ &quot;</span><span class="p">);</span><span class="w">  </span><span class="c1">// 墙</span>
<span class="w">            </span><span class="k">else</span><span class="w"> </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">maze</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">2</span><span class="p">)</span>
<span class="w">                </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;* &quot;</span><span class="p">);</span><span class="w">  </span><span class="c1">// 已访问的路径</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">        </span><span class="n">putchar</span><span class="p">(</span><span class="sc">&#39;\n&#39;</span><span class="p">);</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;*********</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
<span class="p">}</span>

<span class="c1">// 访问函数：标记访问、记录前驱、压入栈</span>
<span class="kt">void</span><span class="w"> </span><span class="nf">visit</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">row</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">col</span><span class="p">,</span><span class="w"> </span><span class="k">struct</span><span class="w"> </span><span class="nc">point</span><span class="w"> </span><span class="n">pre</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">struct</span><span class="w"> </span><span class="nc">point</span><span class="w"> </span><span class="n">visit_point</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">row</span><span class="p">,</span><span class="w"> </span><span class="n">col</span><span class="w"> </span><span class="p">};</span>
<span class="w">    </span><span class="n">maze</span><span class="p">[</span><span class="n">row</span><span class="p">][</span><span class="n">col</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">2</span><span class="p">;</span><span class="w">                    </span><span class="c1">// 标记为已访问</span>
<span class="w">    </span><span class="n">predecessor</span><span class="p">[</span><span class="n">row</span><span class="p">][</span><span class="n">col</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">pre</span><span class="p">;</span><span class="w">           </span><span class="c1">// 记录从哪里来的</span>
<span class="w">    </span><span class="n">push</span><span class="p">(</span><span class="n">visit_point</span><span class="p">);</span><span class="w">                     </span><span class="c1">// 加入路径栈</span>

<span class="w">    </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;访问(%d,%d)，前驱是(%d,%d)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span><span class="w"> </span>
<span class="w">           </span><span class="n">row</span><span class="p">,</span><span class="w"> </span><span class="n">col</span><span class="p">,</span><span class="w"> </span><span class="n">pre</span><span class="p">.</span><span class="n">row</span><span class="p">,</span><span class="w"> </span><span class="n">pre</span><span class="p">.</span><span class="n">col</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">int</span><span class="w"> </span><span class="nf">main</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">struct</span><span class="w"> </span><span class="nc">point</span><span class="w"> </span><span class="n">p</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="p">};</span><span class="w">  </span><span class="c1">// 起点</span>

<span class="w">    </span><span class="c1">// 初始化前驱数组</span>
<span class="w">    </span><span class="n">init_predecessor</span><span class="p">();</span>

<span class="w">    </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;开始DFS迷宫求解...</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
<span class="w">    </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;初始迷宫:</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
<span class="w">    </span><span class="n">print_maze</span><span class="p">();</span>

<span class="w">    </span><span class="n">maze</span><span class="p">[</span><span class="n">p</span><span class="p">.</span><span class="n">row</span><span class="p">][</span><span class="n">p</span><span class="p">.</span><span class="n">col</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">2</span><span class="p">;</span><span class="w">     </span><span class="c1">// 标记起点为已访问</span>
<span class="w">    </span><span class="n">predecessor</span><span class="p">[</span><span class="n">p</span><span class="p">.</span><span class="n">row</span><span class="p">][</span><span class="n">p</span><span class="p">.</span><span class="n">col</span><span class="p">].</span><span class="n">row</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">-1</span><span class="p">;</span><span class="w">  </span><span class="c1">// 起点没有前驱</span>
<span class="w">    </span><span class="n">predecessor</span><span class="p">[</span><span class="n">p</span><span class="p">.</span><span class="n">row</span><span class="p">][</span><span class="n">p</span><span class="p">.</span><span class="n">col</span><span class="p">].</span><span class="n">col</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">-1</span><span class="p">;</span>
<span class="w">    </span><span class="n">push</span><span class="p">(</span><span class="n">p</span><span class="p">);</span><span class="w">                    </span><span class="c1">// 起点入栈</span>

<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">step</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span>

<span class="w">    </span><span class="k">while</span><span class="w"> </span><span class="p">(</span><span class="o">!</span><span class="n">is_empty</span><span class="p">())</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">p</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">pop</span><span class="p">();</span><span class="w">  </span><span class="c1">// 弹出栈顶（最近访问的点）</span>
<span class="w">        </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;</span><span class="se">\n</span><span class="s">步骤%d: 从栈中弹出(%d,%d)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">step</span><span class="p">,</span><span class="w"> </span><span class="n">p</span><span class="p">.</span><span class="n">row</span><span class="p">,</span><span class="w"> </span><span class="n">p</span><span class="p">.</span><span class="n">col</span><span class="p">);</span>

<span class="w">        </span><span class="c1">// 检查是否到达终点</span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">p</span><span class="p">.</span><span class="n">row</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">MAX_ROW</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">p</span><span class="p">.</span><span class="n">col</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">MAX_COL</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mi">1</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;找到终点！</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
<span class="w">            </span><span class="k">break</span><span class="p">;</span>
<span class="w">        </span><span class="p">}</span>

<span class="w">        </span><span class="c1">// 尝试四个方向：右、下、左、上</span>
<span class="w">        </span><span class="c1">// 注意：由于栈是LIFO，实际搜索顺序是上、左、下、右</span>

<span class="w">        </span><span class="c1">// 右</span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">p</span><span class="p">.</span><span class="n">col</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">MAX_COL</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">maze</span><span class="p">[</span><span class="n">p</span><span class="p">.</span><span class="n">row</span><span class="p">][</span><span class="n">p</span><span class="p">.</span><span class="n">col</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="p">]</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;  向右探索到(%d,%d)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">p</span><span class="p">.</span><span class="n">row</span><span class="p">,</span><span class="w"> </span><span class="n">p</span><span class="p">.</span><span class="n">col</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="p">);</span>
<span class="w">            </span><span class="n">visit</span><span class="p">(</span><span class="n">p</span><span class="p">.</span><span class="n">row</span><span class="p">,</span><span class="w"> </span><span class="n">p</span><span class="p">.</span><span class="n">col</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="n">p</span><span class="p">);</span>
<span class="w">        </span><span class="p">}</span>

<span class="w">        </span><span class="c1">// 下</span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">p</span><span class="p">.</span><span class="n">row</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">MAX_ROW</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">maze</span><span class="p">[</span><span class="n">p</span><span class="p">.</span><span class="n">row</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="p">][</span><span class="n">p</span><span class="p">.</span><span class="n">col</span><span class="p">]</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;  向下探索到(%d,%d)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">p</span><span class="p">.</span><span class="n">row</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="n">p</span><span class="p">.</span><span class="n">col</span><span class="p">);</span>
<span class="w">            </span><span class="n">visit</span><span class="p">(</span><span class="n">p</span><span class="p">.</span><span class="n">row</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="n">p</span><span class="p">.</span><span class="n">col</span><span class="p">,</span><span class="w"> </span><span class="n">p</span><span class="p">);</span>
<span class="w">        </span><span class="p">}</span>

<span class="w">        </span><span class="c1">// 左</span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">p</span><span class="p">.</span><span class="n">col</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="o">&gt;=</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">maze</span><span class="p">[</span><span class="n">p</span><span class="p">.</span><span class="n">row</span><span class="p">][</span><span class="n">p</span><span class="p">.</span><span class="n">col</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mi">1</span><span class="p">]</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;  向左探索到(%d,%d)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">p</span><span class="p">.</span><span class="n">row</span><span class="p">,</span><span class="w"> </span><span class="n">p</span><span class="p">.</span><span class="n">col</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mi">1</span><span class="p">);</span>
<span class="w">            </span><span class="n">visit</span><span class="p">(</span><span class="n">p</span><span class="p">.</span><span class="n">row</span><span class="p">,</span><span class="w"> </span><span class="n">p</span><span class="p">.</span><span class="n">col</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="n">p</span><span class="p">);</span>
<span class="w">        </span><span class="p">}</span>

<span class="w">        </span><span class="c1">// 上</span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">p</span><span class="p">.</span><span class="n">row</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="o">&gt;=</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">maze</span><span class="p">[</span><span class="n">p</span><span class="p">.</span><span class="n">row</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mi">1</span><span class="p">][</span><span class="n">p</span><span class="p">.</span><span class="n">col</span><span class="p">]</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;  向上探索到(%d,%d)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">p</span><span class="p">.</span><span class="n">row</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="n">p</span><span class="p">.</span><span class="n">col</span><span class="p">);</span>
<span class="w">            </span><span class="n">visit</span><span class="p">(</span><span class="n">p</span><span class="p">.</span><span class="n">row</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="n">p</span><span class="p">.</span><span class="n">col</span><span class="p">,</span><span class="w"> </span><span class="n">p</span><span class="p">);</span>
<span class="w">        </span><span class="p">}</span>

<span class="w">        </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;当前迷宫状态:</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
<span class="w">        </span><span class="n">print_maze</span><span class="p">();</span>
<span class="w">        </span><span class="n">step</span><span class="o">++</span><span class="p">;</span>

<span class="w">        </span><span class="c1">// 防止无限循环</span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">step</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="mi">50</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;步数过多，可能陷入循环，退出</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
<span class="w">            </span><span class="k">break</span><span class="p">;</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="c1">// 输出最终路径</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">p</span><span class="p">.</span><span class="n">row</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">MAX_ROW</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">p</span><span class="p">.</span><span class="n">col</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">MAX_COL</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mi">1</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;</span><span class="se">\n</span><span class="s">=== 找到路径 ===</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
<span class="w">        </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;路径(从终点到起点):</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

<span class="w">        </span><span class="c1">// 使用前驱数组回溯路径</span>
<span class="w">        </span><span class="k">while</span><span class="w"> </span><span class="p">(</span><span class="n">p</span><span class="p">.</span><span class="n">row</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="mi">-1</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">p</span><span class="p">.</span><span class="n">col</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="mi">-1</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;(%d, %d)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">p</span><span class="p">.</span><span class="n">row</span><span class="p">,</span><span class="w"> </span><span class="n">p</span><span class="p">.</span><span class="n">col</span><span class="p">);</span>
<span class="w">            </span><span class="k">struct</span><span class="w"> </span><span class="nc">point</span><span class="w"> </span><span class="n">prev</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">predecessor</span><span class="p">[</span><span class="n">p</span><span class="p">.</span><span class="n">row</span><span class="p">][</span><span class="n">p</span><span class="p">.</span><span class="n">col</span><span class="p">];</span>
<span class="w">            </span><span class="n">p</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">prev</span><span class="p">;</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">    </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;</span><span class="se">\n</span><span class="s">没有找到路径！</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

<span class="w">        </span><span class="c1">// 打印当前栈状态用于调试</span>
<span class="w">        </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;栈中剩余点: &quot;</span><span class="p">);</span>
<span class="w">        </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">top</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">++</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;(%d,%d) &quot;</span><span class="p">,</span><span class="w"> </span><span class="n">stack</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">row</span><span class="p">,</span><span class="w"> </span><span class="n">stack</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">col</span><span class="p">);</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">        </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>
<h3 id="dfs">深入理解访问点、前驱点和DFS搜索过程</h3>
<h4 id="1-vs">1. 访问点 vs 前驱点</h4>
<ul>
<li><strong>访问点</strong>：当前正在探索的位置</li>
<li><strong>前驱点</strong>：当前点是从哪个点<strong>走过来</strong>的</li>
</ul>
<p><strong>生活化比喻</strong>：
想象你在迷宫中走，每走一步就在地上：
- 放一个标记（<strong>访问点</strong>：表示你来过这里）
- 画一个箭头指向你来的方向（<strong>前驱点</strong>：记录你从哪里来）</p>
<h4 id="2_1">2. 为什么一个点可以探索多个地方？</h4>
<p>这是<strong>深度优先搜索的核心特性</strong>！</p>
<div class="highlight"><pre><span></span><code><span class="c1">// 在(2,0)这个位置，可以往多个方向走</span>
<span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">可以向右走</span><span class="p">)</span><span class="w"> </span><span class="n">visit</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">);</span>
<span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">可以向下走</span><span class="p">)</span><span class="w"> </span><span class="n">visit</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span><span class="mi">0</span><span class="p">);</span>
<span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">可以向左走</span><span class="p">)</span><span class="w"> </span><span class="n">visit</span><span class="p">(...);</span>
<span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">可以向上走</span><span class="p">)</span><span class="w"> </span><span class="n">visit</span><span class="p">(...);</span>
</code></pre></div>
<p><strong>关键理解</strong>：DFS不是一次只走一条路，而是<strong>把所有的可能性都先记录下来</strong>，然后一条条尝试。</p>
<h3 id="3">详细分解步骤3的执行过程</h3>
<p>让我们一步步分析你说的这个场景：</p>
<h4 id="3_1">步骤3开始前的状态</h4>
<div class="highlight"><pre><span></span><code>栈: [(0,0), (1,0), (2,0)]  ← 即将弹出(2,0)
迷宫:
* █ . . .    * = 已访问
* █ . █ .    
* . . . .    . = 未访问  
. █ █ █ .    █ = 墙
. . . █ .
</code></pre></div>
<h4 id="3_2">步骤3执行过程</h4>
<div class="highlight"><pre><span></span><code><span class="n">p</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">pop</span><span class="p">();</span><span class="w">  </span><span class="c1">// 弹出(2,0)，现在p=(2,0)</span>
</code></pre></div>
<p><strong>(2,0)这个位置可以往哪些方向走？</strong></p>
<ol>
<li><strong>向右检查 (2,1)</strong>：</li>
<li><code>(2,1)</code> 是 <code>.</code>（通路，未访问）</li>
<li>✅ 可以走！调用 <code>visit(2,1, (2,0))</code></li>
<li>
<p>含义：从(2,0)走到(2,1)，记录(2,0)是(2,1)的前驱</p>
</li>
<li>
<p><strong>向下检查 (3,0)</strong>：</p>
</li>
<li><code>(3,0)</code> 是 <code>.</code>（通路，未访问）  </li>
<li>✅ 可以走！调用 <code>visit(3,0, (2,0))</code></li>
<li>
<p>含义：从(2,0)走到(3,0)，记录(2,0)是(3,0)的前驱</p>
</li>
<li>
<p><strong>向左检查 (2,-1)</strong>：越界 ❌</p>
</li>
<li><strong>向上检查 (1,0)</strong>：已访问 ❌</li>
</ol>
<h4 id="3_3">步骤3结束后的状态</h4>
<div class="highlight"><pre><span></span><code>栈: [(0,0), (1,0), (2,1), (3,0)]  ← 新加入两个点
迷宫:
* █ . . .    
* █ . █ .    
* * . . .    // (2,1)变成*
* █ █ █ .    // (3,0)变成*  
. . . █ .
</code></pre></div>
<h3 id="dfs-">为什么这样设计？DFS的"探索-回溯"机制</h3>
<h4 id="dfs_1">DFS的核心思想：一条路走到黑，不行就回头</h4>
<div class="highlight"><pre><span></span><code><span class="c1">// 伪代码说明DFS策略</span>
<span class="k">while</span><span class="w"> </span><span class="p">(</span><span class="n">栈不为空</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">当前位置</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">弹出栈顶</span><span class="p">();</span>

<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">到达终点</span><span class="p">)</span><span class="w"> </span><span class="k">break</span><span class="p">;</span>

<span class="w">    </span><span class="c1">// 记录所有可能的下一步</span>
<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="n">每个方向</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">可以走</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="n">标记为已访问</span><span class="p">;</span>
<span class="w">            </span><span class="n">记录前驱</span><span class="p">(</span><span class="n">从哪来的</span><span class="p">);</span>
<span class="w">            </span><span class="n">入栈</span><span class="p">;</span><span class="w">  </span><span class="c1">// 先记录，稍后探索</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span><span class="c1">// 注意：由于栈是LIFO，最后入栈的会先被探索</span>
<span class="p">}</span>
</code></pre></div>
<h4 id="_46">搜索路径的可视化</h4>
<p>让我们跟踪实际的搜索顺序：</p>
<div class="highlight"><pre><span></span><code>开始: (0,0)
↓
(0,0) → 只能向下 → (1,0)
↓  
(1,0) → 只能向下 → (2,0)
↓
(2,0) → 可以向右和向下
        ↓
        先探索最后入栈的: (3,0) ← 栈顶
        ↓
        (3,0) → 只能向下 → (4,0)
        ↓
        (4,0) → 可以向右 → (4,1)
        ↓
        (4,1) → 可以向右 → (4,2)
        ↓
        (4,2) → 遇到墙，死路！回溯到(2,1)
        ↓
        (2,1) → 继续探索...
</code></pre></div>
<h3 id="_47">前驱点的关键作用：重建路径</h3>
<p>前驱点就像"面包屑"，让我们能找到回家的路：</p>
<div class="highlight"><pre><span></span><code><span class="c1">// 找到终点后，通过前驱链回溯</span>
<span class="n">终点</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span><span class="mi">4</span><span class="p">)</span><span class="w"> </span><span class="err">←</span><span class="w"> </span><span class="n">前驱是</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">)</span>
<span class="w">        </span><span class="p">(</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">)</span><span class="w"> </span><span class="err">←</span><span class="w"> </span><span class="n">前驱是</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">4</span><span class="p">)</span><span class="w">  </span>
<span class="w">        </span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">4</span><span class="p">)</span><span class="w"> </span><span class="err">←</span><span class="w"> </span><span class="n">前驱是</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">)</span>
<span class="w">        </span><span class="p">...</span><span class="w"> </span><span class="err">←</span><span class="w"> </span><span class="n">一直回溯到起点</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">)</span>
</code></pre></div>
<h3 id="_48">从思维转换到代码的关键突破</h3>
<h4 id="1">1. 理解"探索"与"访问"的区别</h4>
<ul>
<li><strong>探索</strong>：检查一个位置能不能走</li>
<li><strong>访问</strong>：实际走到那个位置并做记录</li>
</ul>
<h4 id="2_2">2. 栈的作用：待探索的候选列表</h4>
<p>把栈想象成你的"待办事项清单"：
<div class="highlight"><pre><span></span><code><span class="n">栈</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">[</span><span class="n">要探索的位置1</span><span class="p">,</span><span class="w"> </span><span class="n">位置2</span><span class="p">,</span><span class="w"> </span><span class="n">位置3</span><span class="p">,</span><span class="w"> </span><span class="p">...]</span>
</code></pre></div></p>
<h4 id="3_4">3. 前驱的作用：路径记忆</h4>
<p>前驱数组就像你的"足迹记录"：
<div class="highlight"><pre><span></span><code><span class="n">前驱</span><span class="p">[</span><span class="n">当前位置</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">从哪个位置来的</span>
</code></pre></div></p>
<h3 id="_49">完整的思维转换示例</h3>
<p><strong>人类思维</strong>："我从A点走到B点，再走到C点..."</p>
<p><strong>代码思维</strong>：
<div class="highlight"><pre><span></span><code><span class="c1">// 1. 把起点加入待探索列表</span>
<span class="n">栈</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">[</span><span class="n">起点</span><span class="p">]</span>

<span class="c1">// 2. 循环处理待探索列表</span>
<span class="k">while</span><span class="w"> </span><span class="p">(</span><span class="n">栈不为空</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="c1">// 3. 取出一个位置探索</span>
<span class="w">    </span><span class="n">当前位置</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">弹出栈顶</span><span class="p">()</span>

<span class="w">    </span><span class="c1">// 4. 如果是终点，结束</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">当前位置</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">终点</span><span class="p">)</span><span class="w"> </span><span class="k">break</span><span class="p">;</span>

<span class="w">    </span><span class="c1">// 5. 检查所有邻居</span>
<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="n">每个邻居</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">邻居可走且未访问</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="c1">// 6. 标记访问，记录从哪里来的，加入待探索列表</span>
<span class="w">            </span><span class="n">标记邻居为已访问</span>
<span class="w">            </span><span class="n">记录</span><span class="p">[</span><span class="n">邻居</span><span class="p">]</span><span class="n">的前驱</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">当前位置</span>
<span class="w">            </span><span class="n">栈</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="n">邻居</span><span class="p">)</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">}</span>

<span class="c1">// 7. 通过前驱链重建路径</span>
</code></pre></div></p>
<h3 id="_50">总结</h3>
<p>理解这个算法的关键是：</p>
<ol>
<li><strong>栈管理探索顺序</strong>：决定下一步探索哪里</li>
<li><strong>前驱记录来源</strong>：知道每个点是从哪里来的  </li>
<li><strong>DFS策略</strong>：深度优先，一条路走到底再回溯</li>
<li><strong>多方向记录</strong>：一个点可以同时记录多个可行的下一步</li>
</ol>
<p>现在你应该能理解为什么(2,0)可以探索两个地方了：它不是在同时走两条路，而是<strong>把两条路都记录下来</strong>，然后按照栈的顺序（后进先出）一条条尝试。</p>
<p>这种"记录所有可能性，然后系统性地尝试"正是DFS的精髓！</p>
<h2 id="06_stack">06_stack 问题解答与代码改进</h2>
<blockquote>
<p>1、修改本节的程序，要求从起点到终点正向打印路线。你能想到几种办法？</p>
<p>2、本节程序中<code>predecessor</code>这个数据结构占用的存储空间太多了，改变它的存储方式可以节省空间，想想该怎么改。</p>
<p>3、上一节我们实现了一个基于堆栈的程序，然后改写成递归程序，用函数调用的栈帧替代自己实现的堆栈。本节的DFS算法也是基于堆栈的，请把它改写成递归程序，这样改写可以避免使用<code>predecessor</code>数据结构，想想该怎么做。</p>
</blockquote>
<h3 id="_51">问题一：从起点到终点正向打印路线</h3>
<p>有几种方法可以实现正向打印路线：</p>
<h4 id="1_1">方法1：使用临时数组存储路径</h4>
<div class="highlight"><pre><span></span><code><span class="c1">// 正向打印路径</span>
<span class="kt">void</span><span class="w"> </span><span class="nf">print_path_forward</span><span class="p">(</span><span class="k">struct</span><span class="w"> </span><span class="nc">point</span><span class="w"> </span><span class="n">end_point</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">struct</span><span class="w"> </span><span class="nc">point</span><span class="w"> </span><span class="n">path</span><span class="p">[</span><span class="mi">512</span><span class="p">];</span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">path_len</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="w">    </span><span class="k">struct</span><span class="w"> </span><span class="nc">point</span><span class="w"> </span><span class="n">p</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">end_point</span><span class="p">;</span>

<span class="w">    </span><span class="c1">// 收集路径（从终点到起点）</span>
<span class="w">    </span><span class="k">while</span><span class="w"> </span><span class="p">(</span><span class="n">p</span><span class="p">.</span><span class="n">row</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="mi">-1</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">p</span><span class="p">.</span><span class="n">col</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="mi">-1</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">path</span><span class="p">[</span><span class="n">path_len</span><span class="o">++</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">p</span><span class="p">;</span>
<span class="w">        </span><span class="n">p</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">predecessor</span><span class="p">[</span><span class="n">p</span><span class="p">.</span><span class="n">row</span><span class="p">][</span><span class="n">p</span><span class="p">.</span><span class="n">col</span><span class="p">];</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="c1">// 正向打印（从起点到终点）</span>
<span class="w">    </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;路径(从起点到终点):</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">path_len</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&gt;=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">--</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;(%d, %d)&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">path</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">row</span><span class="p">,</span><span class="w"> </span><span class="n">path</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">col</span><span class="p">);</span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">i</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span><span class="w"> </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot; -&gt; &quot;</span><span class="p">);</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div>
<h4 id="2_3">方法2：递归打印</h4>
<div class="highlight"><pre><span></span><code><span class="c1">// 递归正向打印</span>
<span class="kt">void</span><span class="w"> </span><span class="nf">print_path_recursive</span><span class="p">(</span><span class="k">struct</span><span class="w"> </span><span class="nc">point</span><span class="w"> </span><span class="n">p</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">p</span><span class="p">.</span><span class="n">row</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">-1</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">p</span><span class="p">.</span><span class="n">col</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">-1</span><span class="p">)</span><span class="w"> </span><span class="k">return</span><span class="p">;</span>

<span class="w">    </span><span class="k">struct</span><span class="w"> </span><span class="nc">point</span><span class="w"> </span><span class="n">prev</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">predecessor</span><span class="p">[</span><span class="n">p</span><span class="p">.</span><span class="n">row</span><span class="p">][</span><span class="n">p</span><span class="p">.</span><span class="n">col</span><span class="p">];</span>
<span class="w">    </span><span class="n">print_path_recursive</span><span class="p">(</span><span class="n">prev</span><span class="p">);</span>

<span class="w">    </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;(%d, %d)&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">p</span><span class="p">.</span><span class="n">row</span><span class="p">,</span><span class="w"> </span><span class="n">p</span><span class="p">.</span><span class="n">col</span><span class="p">);</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">p</span><span class="p">.</span><span class="n">row</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="n">MAX_ROW</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="o">||</span><span class="w"> </span><span class="n">p</span><span class="p">.</span><span class="n">col</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="n">MAX_COL</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mi">1</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot; -&gt; &quot;</span><span class="p">);</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">}</span>
</code></pre></div>
<h4 id="3_5">方法3：使用双向链表</h4>
<div class="highlight"><pre><span></span><code><span class="k">struct</span><span class="w"> </span><span class="nc">path_node</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">struct</span><span class="w"> </span><span class="nc">point</span><span class="w"> </span><span class="n">p</span><span class="p">;</span>
<span class="w">    </span><span class="k">struct</span><span class="w"> </span><span class="nc">path_node</span><span class="w"> </span><span class="o">*</span><span class="n">next</span><span class="p">;</span>
<span class="p">};</span>

<span class="kt">void</span><span class="w"> </span><span class="nf">print_path_linked_list</span><span class="p">(</span><span class="k">struct</span><span class="w"> </span><span class="nc">point</span><span class="w"> </span><span class="n">end_point</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">struct</span><span class="w"> </span><span class="nc">path_node</span><span class="w"> </span><span class="o">*</span><span class="n">head</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">NULL</span><span class="p">;</span>
<span class="w">    </span><span class="k">struct</span><span class="w"> </span><span class="nc">point</span><span class="w"> </span><span class="n">p</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">end_point</span><span class="p">;</span>

<span class="w">    </span><span class="c1">// 构建链表（从终点到起点）</span>
<span class="w">    </span><span class="k">while</span><span class="w"> </span><span class="p">(</span><span class="n">p</span><span class="p">.</span><span class="n">row</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="mi">-1</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">p</span><span class="p">.</span><span class="n">col</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="mi">-1</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="k">struct</span><span class="w"> </span><span class="nc">path_node</span><span class="w"> </span><span class="o">*</span><span class="n">new_node</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">malloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span><span class="w"> </span><span class="nc">path_node</span><span class="p">));</span>
<span class="w">        </span><span class="n">new_node</span><span class="o">-&gt;</span><span class="n">p</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">p</span><span class="p">;</span>
<span class="w">        </span><span class="n">new_node</span><span class="o">-&gt;</span><span class="n">next</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">head</span><span class="p">;</span>
<span class="w">        </span><span class="n">head</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">new_node</span><span class="p">;</span>
<span class="w">        </span><span class="n">p</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">predecessor</span><span class="p">[</span><span class="n">p</span><span class="p">.</span><span class="n">row</span><span class="p">][</span><span class="n">p</span><span class="p">.</span><span class="n">col</span><span class="p">];</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="c1">// 正向打印</span>
<span class="w">    </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;路径(从起点到终点):</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
<span class="w">    </span><span class="k">struct</span><span class="w"> </span><span class="nc">path_node</span><span class="w"> </span><span class="o">*</span><span class="n">current</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">head</span><span class="p">;</span>
<span class="w">    </span><span class="k">while</span><span class="w"> </span><span class="p">(</span><span class="n">current</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="nb">NULL</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;(%d, %d)&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">current</span><span class="o">-&gt;</span><span class="n">p</span><span class="p">.</span><span class="n">row</span><span class="p">,</span><span class="w"> </span><span class="n">current</span><span class="o">-&gt;</span><span class="n">p</span><span class="p">.</span><span class="n">col</span><span class="p">);</span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">current</span><span class="o">-&gt;</span><span class="n">next</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="nb">NULL</span><span class="p">)</span><span class="w"> </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot; -&gt; &quot;</span><span class="p">);</span>
<span class="w">        </span><span class="n">current</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">current</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

<span class="w">    </span><span class="c1">// 释放内存</span>
<span class="w">    </span><span class="k">while</span><span class="w"> </span><span class="p">(</span><span class="n">head</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="nb">NULL</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="k">struct</span><span class="w"> </span><span class="nc">path_node</span><span class="w"> </span><span class="o">*</span><span class="n">temp</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">head</span><span class="p">;</span>
<span class="w">        </span><span class="n">head</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">head</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
<span class="w">        </span><span class="n">free</span><span class="p">(</span><span class="n">temp</span><span class="p">);</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">}</span>
</code></pre></div>
<h3 id="predecessor">问题二：优化predecessor的存储空间</h3>
<h4 id="1_2">优化方案1：使用方向编码</h4>
<div class="highlight"><pre><span></span><code><span class="c1">// 方向编码：0=右, 1=下, 2=左, 3=上, -1=无前驱</span>
<span class="kt">char</span><span class="w"> </span><span class="n">predecessor_dir</span><span class="p">[</span><span class="n">MAX_ROW</span><span class="p">][</span><span class="n">MAX_COL</span><span class="p">];</span>

<span class="kt">void</span><span class="w"> </span><span class="nf">init_predecessor_dir</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">MAX_ROW</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">++</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">j</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">j</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">MAX_COL</span><span class="p">;</span><span class="w"> </span><span class="n">j</span><span class="o">++</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="n">predecessor_dir</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">-1</span><span class="p">;</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">}</span>

<span class="c1">// 修改visit函数</span>
<span class="kt">void</span><span class="w"> </span><span class="nf">visit_dir</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">row</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">col</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">from_dir</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">struct</span><span class="w"> </span><span class="nc">point</span><span class="w"> </span><span class="n">visit_point</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">row</span><span class="p">,</span><span class="w"> </span><span class="n">col</span><span class="w"> </span><span class="p">};</span>
<span class="w">    </span><span class="n">maze</span><span class="p">[</span><span class="n">row</span><span class="p">][</span><span class="n">col</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">2</span><span class="p">;</span>
<span class="w">    </span><span class="n">predecessor_dir</span><span class="p">[</span><span class="n">row</span><span class="p">][</span><span class="n">col</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">from_dir</span><span class="p">;</span><span class="w">  </span><span class="c1">// 只存储方向</span>
<span class="w">    </span><span class="n">push</span><span class="p">(</span><span class="n">visit_point</span><span class="p">);</span>
<span class="p">}</span>

<span class="c1">// 根据方向编码重建路径</span>
<span class="kt">void</span><span class="w"> </span><span class="nf">print_path_from_dir</span><span class="p">(</span><span class="k">struct</span><span class="w"> </span><span class="nc">point</span><span class="w"> </span><span class="n">end_point</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">struct</span><span class="w"> </span><span class="nc">point</span><span class="w"> </span><span class="n">path</span><span class="p">[</span><span class="mi">512</span><span class="p">];</span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">path_len</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="w">    </span><span class="k">struct</span><span class="w"> </span><span class="nc">point</span><span class="w"> </span><span class="n">p</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">end_point</span><span class="p">;</span>

<span class="w">    </span><span class="c1">// 收集路径</span>
<span class="w">    </span><span class="k">while</span><span class="w"> </span><span class="p">(</span><span class="n">predecessor_dir</span><span class="p">[</span><span class="n">p</span><span class="p">.</span><span class="n">row</span><span class="p">][</span><span class="n">p</span><span class="p">.</span><span class="n">col</span><span class="p">]</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="mi">-1</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">path</span><span class="p">[</span><span class="n">path_len</span><span class="o">++</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">p</span><span class="p">;</span>

<span class="w">        </span><span class="c1">// 根据方向找到前驱点</span>
<span class="w">        </span><span class="kt">int</span><span class="w"> </span><span class="n">dir</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">predecessor_dir</span><span class="p">[</span><span class="n">p</span><span class="p">.</span><span class="n">row</span><span class="p">][</span><span class="n">p</span><span class="p">.</span><span class="n">col</span><span class="p">];</span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">dir</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span><span class="w"> </span><span class="n">p</span><span class="p">.</span><span class="n">col</span><span class="o">--</span><span class="p">;</span><span class="w">      </span><span class="c1">// 来自左边</span>
<span class="w">        </span><span class="k">else</span><span class="w"> </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">dir</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">1</span><span class="p">)</span><span class="w"> </span><span class="n">p</span><span class="p">.</span><span class="n">row</span><span class="o">--</span><span class="p">;</span><span class="w"> </span><span class="c1">// 来自上面</span>
<span class="w">        </span><span class="k">else</span><span class="w"> </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">dir</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">2</span><span class="p">)</span><span class="w"> </span><span class="n">p</span><span class="p">.</span><span class="n">col</span><span class="o">++</span><span class="p">;</span><span class="w"> </span><span class="c1">// 来自右边</span>
<span class="w">        </span><span class="k">else</span><span class="w"> </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">dir</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">3</span><span class="p">)</span><span class="w"> </span><span class="n">p</span><span class="p">.</span><span class="n">row</span><span class="o">++</span><span class="p">;</span><span class="w"> </span><span class="c1">// 来自下面</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span><span class="n">path</span><span class="p">[</span><span class="n">path_len</span><span class="o">++</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">p</span><span class="p">;</span><span class="w">  </span><span class="c1">// 起点</span>

<span class="w">    </span><span class="c1">// 正向打印</span>
<span class="w">    </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;路径(从起点到终点):</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">path_len</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&gt;=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">--</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;(%d, %d)&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">path</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">row</span><span class="p">,</span><span class="w"> </span><span class="n">path</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">col</span><span class="p">);</span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">i</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span><span class="w"> </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot; -&gt; &quot;</span><span class="p">);</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div>
<h4 id="2_4">优化方案2：使用单字节存储坐标</h4>
<div class="highlight"><pre><span></span><code><span class="c1">// 将(row,col)编码为一个字节：高4位存row，低4位存col</span>
<span class="kt">unsigned</span><span class="w"> </span><span class="kt">char</span><span class="w"> </span><span class="n">predecessor_byte</span><span class="p">[</span><span class="n">MAX_ROW</span><span class="p">][</span><span class="n">MAX_COL</span><span class="p">];</span>

<span class="kt">void</span><span class="w"> </span><span class="nf">init_predecessor_byte</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">MAX_ROW</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">++</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">j</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">j</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">MAX_COL</span><span class="p">;</span><span class="w"> </span><span class="n">j</span><span class="o">++</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="n">predecessor_byte</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mh">0xFF</span><span class="p">;</span><span class="w">  </span><span class="c1">// 0xFF表示无前驱</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">}</span>

<span class="c1">// 编码坐标</span>
<span class="kt">unsigned</span><span class="w"> </span><span class="kt">char</span><span class="w"> </span><span class="nf">encode_point</span><span class="p">(</span><span class="k">struct</span><span class="w"> </span><span class="nc">point</span><span class="w"> </span><span class="n">p</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="p">(</span><span class="n">p</span><span class="p">.</span><span class="n">row</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="mi">4</span><span class="p">)</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="n">p</span><span class="p">.</span><span class="n">col</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">// 解码坐标</span>
<span class="k">struct</span><span class="w"> </span><span class="nc">point</span><span class="w"> </span><span class="n">decode_point</span><span class="p">(</span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">char</span><span class="w"> </span><span class="n">code</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">struct</span><span class="w"> </span><span class="nc">point</span><span class="w"> </span><span class="n">p</span><span class="p">;</span>
<span class="w">    </span><span class="n">p</span><span class="p">.</span><span class="n">row</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">code</span><span class="w"> </span><span class="o">&gt;&gt;</span><span class="w"> </span><span class="mi">4</span><span class="p">)</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span><span class="mh">0x0F</span><span class="p">;</span>
<span class="w">    </span><span class="n">p</span><span class="p">.</span><span class="n">col</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">code</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span><span class="mh">0x0F</span><span class="p">;</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">p</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span><span class="w"> </span><span class="n">visit_byte</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">row</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">col</span><span class="p">,</span><span class="w"> </span><span class="k">struct</span><span class="w"> </span><span class="nc">point</span><span class="w"> </span><span class="n">pre</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">struct</span><span class="w"> </span><span class="nc">point</span><span class="w"> </span><span class="n">visit_point</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">row</span><span class="p">,</span><span class="w"> </span><span class="n">col</span><span class="w"> </span><span class="p">};</span>
<span class="w">    </span><span class="n">maze</span><span class="p">[</span><span class="n">row</span><span class="p">][</span><span class="n">col</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">2</span><span class="p">;</span>
<span class="w">    </span><span class="n">predecessor_byte</span><span class="p">[</span><span class="n">row</span><span class="p">][</span><span class="n">col</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">encode_point</span><span class="p">(</span><span class="n">pre</span><span class="p">);</span>
<span class="w">    </span><span class="n">push</span><span class="p">(</span><span class="n">visit_point</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div>
<h3 id="dfs_2">问题三：改写为递归DFS程序</h3>
<h4 id="dfspredecessor">递归DFS实现（避免使用predecessor）</h4>
<div class="highlight"><pre><span></span><code><span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;stdio.h&gt;</span>

<span class="cp">#define MAX_ROW 5</span>
<span class="cp">#define MAX_COL 5</span>

<span class="c1">// 迷宫定义</span>
<span class="kt">int</span><span class="w"> </span><span class="n">maze</span><span class="p">[</span><span class="n">MAX_ROW</span><span class="p">][</span><span class="n">MAX_COL</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="p">{</span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">},</span>
<span class="w">    </span><span class="p">{</span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">},</span>
<span class="w">    </span><span class="p">{</span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">},</span>
<span class="w">    </span><span class="p">{</span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">},</span>
<span class="w">    </span><span class="p">{</span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">}</span>
<span class="p">};</span>

<span class="c1">// 路径栈（用于存储找到的路径）</span>
<span class="k">struct</span><span class="w"> </span><span class="nc">point</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">row</span><span class="p">,</span><span class="w"> </span><span class="n">col</span><span class="p">;</span>
<span class="p">};</span>
<span class="k">struct</span><span class="w"> </span><span class="nc">point</span><span class="w"> </span><span class="n">path_stack</span><span class="p">[</span><span class="mi">512</span><span class="p">];</span>
<span class="kt">int</span><span class="w"> </span><span class="n">path_top</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>

<span class="kt">void</span><span class="w"> </span><span class="nf">path_push</span><span class="p">(</span><span class="k">struct</span><span class="w"> </span><span class="nc">point</span><span class="w"> </span><span class="n">p</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">path_stack</span><span class="p">[</span><span class="n">path_top</span><span class="o">++</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">p</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span><span class="w"> </span><span class="nf">path_pop</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">path_top</span><span class="o">--</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">// 递归DFS函数</span>
<span class="kt">int</span><span class="w"> </span><span class="nf">dfs_recursive</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">row</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">col</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">target_row</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">target_col</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="c1">// 越界检查</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">row</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="o">||</span><span class="w"> </span><span class="n">row</span><span class="w"> </span><span class="o">&gt;=</span><span class="w"> </span><span class="n">MAX_ROW</span><span class="w"> </span><span class="o">||</span><span class="w"> </span><span class="n">col</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="o">||</span><span class="w"> </span><span class="n">col</span><span class="w"> </span><span class="o">&gt;=</span><span class="w"> </span><span class="n">MAX_COL</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="c1">// 墙或已访问检查</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">maze</span><span class="p">[</span><span class="n">row</span><span class="p">][</span><span class="n">col</span><span class="p">]</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="o">||</span><span class="w"> </span><span class="n">maze</span><span class="p">[</span><span class="n">row</span><span class="p">][</span><span class="n">col</span><span class="p">]</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">2</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="c1">// 标记为已访问并加入路径</span>
<span class="w">    </span><span class="n">maze</span><span class="p">[</span><span class="n">row</span><span class="p">][</span><span class="n">col</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">2</span><span class="p">;</span>
<span class="w">    </span><span class="k">struct</span><span class="w"> </span><span class="nc">point</span><span class="w"> </span><span class="n">current</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="n">row</span><span class="p">,</span><span class="w"> </span><span class="n">col</span><span class="p">};</span>
<span class="w">    </span><span class="n">path_push</span><span class="p">(</span><span class="n">current</span><span class="p">);</span>

<span class="w">    </span><span class="c1">// 检查是否到达终点</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">row</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">target_row</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">col</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">target_col</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span><span class="w">  </span><span class="c1">// 找到路径</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="c1">// 递归探索四个方向</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">dfs_recursive</span><span class="p">(</span><span class="n">row</span><span class="p">,</span><span class="w"> </span><span class="n">col</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="n">target_row</span><span class="p">,</span><span class="w"> </span><span class="n">target_col</span><span class="p">)</span><span class="w"> </span><span class="o">||</span><span class="w">  </span><span class="c1">// 右</span>
<span class="w">        </span><span class="n">dfs_recursive</span><span class="p">(</span><span class="n">row</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="n">col</span><span class="p">,</span><span class="w"> </span><span class="n">target_row</span><span class="p">,</span><span class="w"> </span><span class="n">target_col</span><span class="p">)</span><span class="w"> </span><span class="o">||</span><span class="w">  </span><span class="c1">// 下</span>
<span class="w">        </span><span class="n">dfs_recursive</span><span class="p">(</span><span class="n">row</span><span class="p">,</span><span class="w"> </span><span class="n">col</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="n">target_row</span><span class="p">,</span><span class="w"> </span><span class="n">target_col</span><span class="p">)</span><span class="w"> </span><span class="o">||</span><span class="w">  </span><span class="c1">// 左</span>
<span class="w">        </span><span class="n">dfs_recursive</span><span class="p">(</span><span class="n">row</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="n">col</span><span class="p">,</span><span class="w"> </span><span class="n">target_row</span><span class="p">,</span><span class="w"> </span><span class="n">target_col</span><span class="p">))</span><span class="w"> </span><span class="p">{</span><span class="w">  </span><span class="c1">// 上</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span><span class="w">  </span><span class="c1">// 某个方向找到了路径</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="c1">// 如果所有方向都没找到路径，回溯</span>
<span class="w">    </span><span class="n">path_pop</span><span class="p">();</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">// 打印路径</span>
<span class="kt">void</span><span class="w"> </span><span class="nf">print_recursive_path</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;递归DFS找到的路径(从起点到终点):</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">path_top</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">++</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;(%d, %d)&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">path_stack</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">row</span><span class="p">,</span><span class="w"> </span><span class="n">path_stack</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">col</span><span class="p">);</span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">path_top</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mi">1</span><span class="p">)</span><span class="w"> </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot; -&gt; &quot;</span><span class="p">);</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">int</span><span class="w"> </span><span class="nf">main</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;递归DFS迷宫求解...</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

<span class="w">    </span><span class="c1">// 保存原始迷宫状态（用于重置）</span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">original_maze</span><span class="p">[</span><span class="n">MAX_ROW</span><span class="p">][</span><span class="n">MAX_COL</span><span class="p">];</span>
<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">MAX_ROW</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">++</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">j</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">j</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">MAX_COL</span><span class="p">;</span><span class="w"> </span><span class="n">j</span><span class="o">++</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="n">original_maze</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">maze</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">];</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="c1">// 执行递归DFS</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">dfs_recursive</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="n">MAX_ROW</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="n">MAX_COL</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mi">1</span><span class="p">))</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">print_recursive_path</span><span class="p">();</span>
<span class="w">    </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;没有找到路径！</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="c1">// 恢复迷宫状态</span>
<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">MAX_ROW</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">++</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">j</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">j</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">MAX_COL</span><span class="p">;</span><span class="w"> </span><span class="n">j</span><span class="o">++</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="n">maze</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">original_maze</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">];</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>
<h4 id="dfs_3">递归DFS的优势</h4>
<ol>
<li><strong>代码更简洁</strong>：不需要显式管理栈</li>
<li><strong>自动路径记录</strong>：函数调用栈自动记录路径</li>
<li><strong>无需predecessor</strong>：通过递归调用自动维护路径信息</li>
<li><strong>更符合思维模式</strong>：深度优先的自然表达</li>
</ol>
<h4 id="dfs_4">递归DFS的注意事项</h4>
<ol>
<li><strong>栈溢出风险</strong>：对于大型迷宫可能导致栈溢出</li>
<li><strong>性能考虑</strong>：函数调用有一定开销</li>
<li><strong>状态管理</strong>：需要小心管理全局状态</li>
</ol>
<h3 id="_52">完整整合版本</h3>
<div class="highlight"><pre><span></span><code><span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;stdio.h&gt;</span>

<span class="cp">#define MAX_ROW 5</span>
<span class="cp">#define MAX_COL 5</span>

<span class="c1">// 迷宫定义</span>
<span class="kt">int</span><span class="w"> </span><span class="n">maze</span><span class="p">[</span><span class="n">MAX_ROW</span><span class="p">][</span><span class="n">MAX_COL</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="p">{</span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">},</span>
<span class="w">    </span><span class="p">{</span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">},</span>
<span class="w">    </span><span class="p">{</span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">},</span>
<span class="w">    </span><span class="p">{</span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">},</span>
<span class="w">    </span><span class="p">{</span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">}</span>
<span class="p">};</span>

<span class="c1">// 优化后的前驱存储（方向编码）</span>
<span class="kt">char</span><span class="w"> </span><span class="n">predecessor_dir</span><span class="p">[</span><span class="n">MAX_ROW</span><span class="p">][</span><span class="n">MAX_COL</span><span class="p">];</span>

<span class="kt">void</span><span class="w"> </span><span class="nf">init_predecessor_dir</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">MAX_ROW</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">++</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">j</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">j</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">MAX_COL</span><span class="p">;</span><span class="w"> </span><span class="n">j</span><span class="o">++</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="n">predecessor_dir</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">-1</span><span class="p">;</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">}</span>

<span class="c1">// 栈实现</span>
<span class="k">struct</span><span class="w"> </span><span class="nc">point</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">row</span><span class="p">,</span><span class="w"> </span><span class="n">col</span><span class="p">;</span><span class="w"> </span><span class="p">}</span><span class="w"> </span><span class="n">stack</span><span class="p">[</span><span class="mi">512</span><span class="p">];</span>
<span class="kt">int</span><span class="w"> </span><span class="n">top</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>

<span class="kt">void</span><span class="w"> </span><span class="nf">push</span><span class="p">(</span><span class="k">struct</span><span class="w"> </span><span class="nc">point</span><span class="w"> </span><span class="n">p</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">stack</span><span class="p">[</span><span class="n">top</span><span class="o">++</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">p</span><span class="p">;</span><span class="w"> </span><span class="p">}</span>
<span class="k">struct</span><span class="w"> </span><span class="nc">point</span><span class="w"> </span><span class="n">pop</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="k">return</span><span class="w"> </span><span class="n">stack</span><span class="p">[</span><span class="o">--</span><span class="n">top</span><span class="p">];</span><span class="w"> </span><span class="p">}</span>
<span class="kt">int</span><span class="w"> </span><span class="n">is_empty</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="k">return</span><span class="w"> </span><span class="n">top</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="p">}</span>

<span class="kt">void</span><span class="w"> </span><span class="n">visit</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">row</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">col</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">from_dir</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">struct</span><span class="w"> </span><span class="nc">point</span><span class="w"> </span><span class="n">visit_point</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">row</span><span class="p">,</span><span class="w"> </span><span class="n">col</span><span class="w"> </span><span class="p">};</span>
<span class="w">    </span><span class="n">maze</span><span class="p">[</span><span class="n">row</span><span class="p">][</span><span class="n">col</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">2</span><span class="p">;</span>
<span class="w">    </span><span class="n">predecessor_dir</span><span class="p">[</span><span class="n">row</span><span class="p">][</span><span class="n">col</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">from_dir</span><span class="p">;</span>
<span class="w">    </span><span class="n">push</span><span class="p">(</span><span class="n">visit_point</span><span class="p">);</span>
<span class="p">}</span>

<span class="c1">// 从方向编码重建并正向打印路径</span>
<span class="kt">void</span><span class="w"> </span><span class="n">print_path_forward</span><span class="p">(</span><span class="k">struct</span><span class="w"> </span><span class="nc">point</span><span class="w"> </span><span class="n">end_point</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">struct</span><span class="w"> </span><span class="nc">point</span><span class="w"> </span><span class="n">path</span><span class="p">[</span><span class="mi">512</span><span class="p">];</span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">path_len</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="w">    </span><span class="k">struct</span><span class="w"> </span><span class="nc">point</span><span class="w"> </span><span class="n">p</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">end_point</span><span class="p">;</span>

<span class="w">    </span><span class="c1">// 收集路径（从终点到起点）</span>
<span class="w">    </span><span class="k">while</span><span class="w"> </span><span class="p">(</span><span class="n">predecessor_dir</span><span class="p">[</span><span class="n">p</span><span class="p">.</span><span class="n">row</span><span class="p">][</span><span class="n">p</span><span class="p">.</span><span class="n">col</span><span class="p">]</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="mi">-1</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">path</span><span class="p">[</span><span class="n">path_len</span><span class="o">++</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">p</span><span class="p">;</span>
<span class="w">        </span><span class="kt">int</span><span class="w"> </span><span class="n">dir</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">predecessor_dir</span><span class="p">[</span><span class="n">p</span><span class="p">.</span><span class="n">row</span><span class="p">][</span><span class="n">p</span><span class="p">.</span><span class="n">col</span><span class="p">];</span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">dir</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span><span class="w"> </span><span class="n">p</span><span class="p">.</span><span class="n">col</span><span class="o">--</span><span class="p">;</span><span class="w">      </span><span class="c1">// 来自左边</span>
<span class="w">        </span><span class="k">else</span><span class="w"> </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">dir</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">1</span><span class="p">)</span><span class="w"> </span><span class="n">p</span><span class="p">.</span><span class="n">row</span><span class="o">--</span><span class="p">;</span><span class="w"> </span><span class="c1">// 来自上面</span>
<span class="w">        </span><span class="k">else</span><span class="w"> </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">dir</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">2</span><span class="p">)</span><span class="w"> </span><span class="n">p</span><span class="p">.</span><span class="n">col</span><span class="o">++</span><span class="p">;</span><span class="w"> </span><span class="c1">// 来自右边</span>
<span class="w">        </span><span class="k">else</span><span class="w"> </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">dir</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">3</span><span class="p">)</span><span class="w"> </span><span class="n">p</span><span class="p">.</span><span class="n">row</span><span class="o">++</span><span class="p">;</span><span class="w"> </span><span class="c1">// 来自下面</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span><span class="n">path</span><span class="p">[</span><span class="n">path_len</span><span class="o">++</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">p</span><span class="p">;</span><span class="w">  </span><span class="c1">// 起点</span>

<span class="w">    </span><span class="c1">// 正向打印</span>
<span class="w">    </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;路径(从起点到终点):</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">path_len</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&gt;=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">--</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;(%d, %d)&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">path</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">row</span><span class="p">,</span><span class="w"> </span><span class="n">path</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">col</span><span class="p">);</span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">i</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span><span class="w"> </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot; -&gt; &quot;</span><span class="p">);</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
<span class="p">}</span>

<span class="c1">// 迭代DFS主函数</span>
<span class="kt">void</span><span class="w"> </span><span class="n">dfs_iterative</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">struct</span><span class="w"> </span><span class="nc">point</span><span class="w"> </span><span class="n">p</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">};</span>
<span class="w">    </span><span class="n">init_predecessor_dir</span><span class="p">();</span>

<span class="w">    </span><span class="n">maze</span><span class="p">[</span><span class="n">p</span><span class="p">.</span><span class="n">row</span><span class="p">][</span><span class="n">p</span><span class="p">.</span><span class="n">col</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">2</span><span class="p">;</span>
<span class="w">    </span><span class="n">predecessor_dir</span><span class="p">[</span><span class="n">p</span><span class="p">.</span><span class="n">row</span><span class="p">][</span><span class="n">p</span><span class="p">.</span><span class="n">col</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">-1</span><span class="p">;</span><span class="w">  </span><span class="c1">// 起点无前驱</span>
<span class="w">    </span><span class="n">push</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>

<span class="w">    </span><span class="k">while</span><span class="w"> </span><span class="p">(</span><span class="o">!</span><span class="n">is_empty</span><span class="p">())</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">p</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">pop</span><span class="p">();</span>

<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">p</span><span class="p">.</span><span class="n">row</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">MAX_ROW</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">p</span><span class="p">.</span><span class="n">col</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">MAX_COL</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mi">1</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;找到路径！</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
<span class="w">            </span><span class="n">print_path_forward</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>
<span class="w">            </span><span class="k">return</span><span class="p">;</span>
<span class="w">        </span><span class="p">}</span>

<span class="w">        </span><span class="c1">// 探索四个方向</span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">p</span><span class="p">.</span><span class="n">col</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">MAX_COL</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">maze</span><span class="p">[</span><span class="n">p</span><span class="p">.</span><span class="n">row</span><span class="p">][</span><span class="n">p</span><span class="p">.</span><span class="n">col</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="p">]</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="n">visit</span><span class="p">(</span><span class="n">p</span><span class="p">.</span><span class="n">row</span><span class="p">,</span><span class="w"> </span><span class="n">p</span><span class="p">.</span><span class="n">col</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="p">);</span><span class="w">  </span><span class="c1">// 2表示来自左边</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">p</span><span class="p">.</span><span class="n">row</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">MAX_ROW</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">maze</span><span class="p">[</span><span class="n">p</span><span class="p">.</span><span class="n">row</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="p">][</span><span class="n">p</span><span class="p">.</span><span class="n">col</span><span class="p">]</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="n">visit</span><span class="p">(</span><span class="n">p</span><span class="p">.</span><span class="n">row</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="n">p</span><span class="p">.</span><span class="n">col</span><span class="p">,</span><span class="w"> </span><span class="mi">3</span><span class="p">);</span><span class="w">  </span><span class="c1">// 3表示来自上面</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">p</span><span class="p">.</span><span class="n">col</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="o">&gt;=</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">maze</span><span class="p">[</span><span class="n">p</span><span class="p">.</span><span class="n">row</span><span class="p">][</span><span class="n">p</span><span class="p">.</span><span class="n">col</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mi">1</span><span class="p">]</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="n">visit</span><span class="p">(</span><span class="n">p</span><span class="p">.</span><span class="n">row</span><span class="p">,</span><span class="w"> </span><span class="n">p</span><span class="p">.</span><span class="n">col</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">);</span><span class="w">  </span><span class="c1">// 0表示来自右边</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">p</span><span class="p">.</span><span class="n">row</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="o">&gt;=</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">maze</span><span class="p">[</span><span class="n">p</span><span class="p">.</span><span class="n">row</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mi">1</span><span class="p">][</span><span class="n">p</span><span class="p">.</span><span class="n">col</span><span class="p">]</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="n">visit</span><span class="p">(</span><span class="n">p</span><span class="p">.</span><span class="n">row</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="n">p</span><span class="p">.</span><span class="n">col</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">);</span><span class="w">  </span><span class="c1">// 1表示来自下面</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;没有找到路径！</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">int</span><span class="w"> </span><span class="n">main</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;=== 优化后的DFS迷宫求解 ===</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
<span class="w">    </span><span class="n">dfs_iterative</span><span class="p">();</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>
<h3 id="_53">总结</h3>
<p>通过这三种改进，我们实现了：</p>
<ol>
<li><strong>正向打印路径</strong>：更直观的路径显示</li>
<li><strong>空间优化</strong>：将predecessor从8字节/点优化到1字节/点</li>
<li><strong>递归实现</strong>：更简洁的代码，自动路径管理</li>
</ol>
<p>这些改进展示了算法优化的重要思路：在保持正确性的前提下，不断追求更好的用户体验、更高的空间效率和更简洁的代码结构。</p>
<h2 id="07_queue_maze">07_queue_maze</h2>
<div class="highlight"><pre><span></span><code><span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;stdio.h&gt;</span>

<span class="cp">#define MAX_ROW 5</span>
<span class="cp">#define MAX_COL 5</span>

<span class="k">struct</span><span class="w"> </span><span class="nc">point</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">row</span><span class="p">,</span><span class="w"> </span><span class="n">col</span><span class="p">,</span><span class="w"> </span><span class="n">predecessor</span><span class="p">;</span><span class="w"> </span><span class="p">}</span><span class="w"> </span><span class="n">queue</span><span class="p">[</span><span class="mi">512</span><span class="p">];</span>
<span class="kt">int</span><span class="w"> </span><span class="n">head</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="n">tail</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>

<span class="kt">void</span><span class="w"> </span><span class="nf">enqueue</span><span class="p">(</span><span class="k">struct</span><span class="w"> </span><span class="nc">point</span><span class="w"> </span><span class="n">p</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">    </span><span class="n">queue</span><span class="p">[</span><span class="n">tail</span><span class="o">++</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">p</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">struct</span><span class="w"> </span><span class="nc">point</span><span class="w"> </span><span class="n">dequeue</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">queue</span><span class="p">[</span><span class="n">head</span><span class="o">++</span><span class="p">];</span>
<span class="p">}</span>

<span class="kt">int</span><span class="w"> </span><span class="n">is_empty</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">head</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">tail</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span><span class="w"> </span><span class="n">maze</span><span class="p">[</span><span class="n">MAX_ROW</span><span class="p">][</span><span class="n">MAX_COL</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span>
<span class="w">    </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span>
<span class="w">    </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span>
<span class="w">    </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span>
<span class="w">    </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span>
<span class="p">};</span>

<span class="kt">void</span><span class="w"> </span><span class="nf">print_maze</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="p">,</span><span class="w"> </span><span class="n">j</span><span class="p">;</span>
<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">MAX_ROW</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">++</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="n">j</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">j</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">MAX_COL</span><span class="p">;</span><span class="w"> </span><span class="n">j</span><span class="o">++</span><span class="p">)</span>
<span class="w">            </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;%d &quot;</span><span class="p">,</span><span class="w"> </span><span class="n">maze</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]);</span>
<span class="w">        </span><span class="n">putchar</span><span class="p">(</span><span class="sc">&#39;\n&#39;</span><span class="p">);</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;*********</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">void</span><span class="w"> </span><span class="nf">visit</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">row</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">col</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">    </span><span class="k">struct</span><span class="w"> </span><span class="nc">point</span><span class="w"> </span><span class="n">visit_point</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">row</span><span class="p">,</span><span class="w"> </span><span class="n">col</span><span class="p">,</span><span class="w"> </span><span class="n">head</span><span class="mi">-1</span><span class="w"> </span><span class="p">};</span>
<span class="w">    </span><span class="n">maze</span><span class="p">[</span><span class="n">row</span><span class="p">][</span><span class="n">col</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">2</span><span class="p">;</span>
<span class="w">    </span><span class="n">enqueue</span><span class="p">(</span><span class="n">visit_point</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">int</span><span class="w"> </span><span class="nf">main</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">    </span><span class="k">struct</span><span class="w"> </span><span class="nc">point</span><span class="w"> </span><span class="n">p</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">-1</span><span class="w"> </span><span class="p">};</span>

<span class="w">    </span><span class="n">maze</span><span class="p">[</span><span class="n">p</span><span class="p">.</span><span class="n">row</span><span class="p">][</span><span class="n">p</span><span class="p">.</span><span class="n">col</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">2</span><span class="p">;</span>
<span class="w">    </span><span class="n">enqueue</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>

<span class="w">    </span><span class="k">while</span><span class="w"> </span><span class="p">(</span><span class="o">!</span><span class="n">is_empty</span><span class="p">())</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">p</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">dequeue</span><span class="p">();</span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">p</span><span class="p">.</span><span class="n">row</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">MAX_ROW</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mi">1</span><span class="w">  </span><span class="cm">/* goal */</span>
<span class="w">            </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">p</span><span class="p">.</span><span class="n">col</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">MAX_COL</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mi">1</span><span class="p">)</span>
<span class="w">            </span><span class="k">break</span><span class="p">;</span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">p</span><span class="p">.</span><span class="n">col</span><span class="o">+</span><span class="mi">1</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">MAX_COL</span><span class="w">     </span><span class="cm">/* right */</span>
<span class="w">            </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">maze</span><span class="p">[</span><span class="n">p</span><span class="p">.</span><span class="n">row</span><span class="p">][</span><span class="n">p</span><span class="p">.</span><span class="n">col</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span>
<span class="w">            </span><span class="n">visit</span><span class="p">(</span><span class="n">p</span><span class="p">.</span><span class="n">row</span><span class="p">,</span><span class="w"> </span><span class="n">p</span><span class="p">.</span><span class="n">col</span><span class="o">+</span><span class="mi">1</span><span class="p">);</span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">p</span><span class="p">.</span><span class="n">row</span><span class="o">+</span><span class="mi">1</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">MAX_ROW</span><span class="w">     </span><span class="cm">/* down */</span>
<span class="w">            </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">maze</span><span class="p">[</span><span class="n">p</span><span class="p">.</span><span class="n">row</span><span class="o">+</span><span class="mi">1</span><span class="p">][</span><span class="n">p</span><span class="p">.</span><span class="n">col</span><span class="p">]</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span>
<span class="w">            </span><span class="n">visit</span><span class="p">(</span><span class="n">p</span><span class="p">.</span><span class="n">row</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="n">p</span><span class="p">.</span><span class="n">col</span><span class="p">);</span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">p</span><span class="p">.</span><span class="n">col</span><span class="mi">-1</span><span class="w"> </span><span class="o">&gt;=</span><span class="w"> </span><span class="mi">0</span><span class="w">          </span><span class="cm">/* left */</span>
<span class="w">            </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">maze</span><span class="p">[</span><span class="n">p</span><span class="p">.</span><span class="n">row</span><span class="p">][</span><span class="n">p</span><span class="p">.</span><span class="n">col</span><span class="mi">-1</span><span class="p">]</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span>
<span class="w">            </span><span class="n">visit</span><span class="p">(</span><span class="n">p</span><span class="p">.</span><span class="n">row</span><span class="p">,</span><span class="w"> </span><span class="n">p</span><span class="p">.</span><span class="n">col</span><span class="mi">-1</span><span class="p">);</span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">p</span><span class="p">.</span><span class="n">row</span><span class="mi">-1</span><span class="w"> </span><span class="o">&gt;=</span><span class="w"> </span><span class="mi">0</span><span class="w">          </span><span class="cm">/* up */</span>
<span class="w">            </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">maze</span><span class="p">[</span><span class="n">p</span><span class="p">.</span><span class="n">row</span><span class="mi">-1</span><span class="p">][</span><span class="n">p</span><span class="p">.</span><span class="n">col</span><span class="p">]</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span>
<span class="w">            </span><span class="n">visit</span><span class="p">(</span><span class="n">p</span><span class="p">.</span><span class="n">row</span><span class="mi">-1</span><span class="p">,</span><span class="w"> </span><span class="n">p</span><span class="p">.</span><span class="n">col</span><span class="p">);</span>
<span class="w">        </span><span class="n">print_maze</span><span class="p">();</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">p</span><span class="p">.</span><span class="n">row</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">MAX_ROW</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">p</span><span class="p">.</span><span class="n">col</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">MAX_COL</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mi">1</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;(%d, %d)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">p</span><span class="p">.</span><span class="n">row</span><span class="p">,</span><span class="w"> </span><span class="n">p</span><span class="p">.</span><span class="n">col</span><span class="p">);</span>
<span class="w">        </span><span class="k">while</span><span class="w"> </span><span class="p">(</span><span class="n">p</span><span class="p">.</span><span class="n">predecessor</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="mi">-1</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="n">p</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">queue</span><span class="p">[</span><span class="n">p</span><span class="p">.</span><span class="n">predecessor</span><span class="p">];</span>
<span class="w">            </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;(%d, %d)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">p</span><span class="p">.</span><span class="n">row</span><span class="p">,</span><span class="w"> </span><span class="n">p</span><span class="p">.</span><span class="n">col</span><span class="p">);</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">    </span><span class="p">}</span><span class="w"> </span><span class="k">else</span>
<span class="w">        </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;No path!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>
<p>可以直接改06的stack为queue，然后还用前驱，再切换到这个版本</p>
<blockquote>
<p>1、本节的例子直接在队列元素中加一个指针成员表示前趋，想一想为什么上一节的<a href="https://akaedu.github.io/book/ch12s03.html#stackqueue.dfs">例 12.3 “用深度优先搜索解迷宫问题”</a>不能采用这种方法表示前趋？</p>
<p>2、本节例子中给队列分配的存储空间是512个元素，其实没必要这么多，那么解决这个问题至少要分配多少个元素的队列空间呢？跟什么因素有关？</p>
<p>是因为stack的top只能一直指向栈顶，同时，这个queue的大小也是够支持最大的探索范围是吗？但是具体来说怎么确定最大的大小呢？和什么有关？迷宫大小？</p>
</blockquote>
<h3 id="dfs_5">问题一：为什么DFS不能采用队列的这种前驱表示方法？</h3>
<h4 id="vs">关键差异：栈 vs 队列的访问特性</h4>
<p><strong>队列（BFS）的特性：</strong>
<div class="highlight"><pre><span></span><code><span class="k">struct</span><span class="w"> </span><span class="nc">point</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">row</span><span class="p">,</span><span class="w"> </span><span class="n">col</span><span class="p">,</span><span class="w"> </span><span class="n">predecessor</span><span class="p">;</span><span class="w"> </span><span class="p">}</span><span class="w"> </span><span class="n">queue</span><span class="p">[</span><span class="mi">512</span><span class="p">];</span>
<span class="c1">// predecessor 存储的是前驱点在队列中的索引</span>
</code></pre></div></p>
<p><strong>为什么这在BFS中可行：</strong>
1. <strong>顺序访问</strong>：BFS按层次顺序访问节点，队列中的节点索引是稳定的
2. <strong>前驱保持</strong>：前驱节点在出队后，其索引在队列数组中仍然有效
3. <strong>线性增长</strong>：队列索引单调递增，不会重复使用</p>
<p><strong>DFS（栈）的问题：</strong>
<div class="highlight"><pre><span></span><code><span class="c1">// 如果尝试在DFS中使用类似方法：</span>
<span class="k">struct</span><span class="w"> </span><span class="nc">point</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">row</span><span class="p">,</span><span class="w"> </span><span class="n">col</span><span class="p">,</span><span class="w"> </span><span class="n">predecessor</span><span class="p">;</span><span class="w"> </span><span class="p">}</span><span class="w"> </span><span class="n">stack</span><span class="p">[</span><span class="mi">512</span><span class="p">];</span>
</code></pre></div></p>
<p><strong>为什么这在DFS中不可行：</strong>
1. <strong>回溯破坏</strong>：当DFS回溯时，栈顶元素被弹出，其索引可能被后续节点重用
2. <strong>前驱失效</strong>：前驱节点弹出后，其栈索引可能指向完全不同的节点
3. <strong>索引混乱</strong>：栈索引会不断被重用，无法稳定指向正确的前驱</p>
<h4 id="_54">具体例子说明</h4>
<p><strong>BFS工作方式：</strong>
<div class="highlight"><pre><span></span><code>队列索引: 0   1   2   3   4   5
节点:     A   B   C   D   E   F
前驱:    -1  0   0   1   1   2

A(0) → B(1), C(2)   [前驱=0]
B(1) → D(3), E(4)   [前驱=1]  
C(2) → F(5)         [前驱=2]
</code></pre></div>
即使B、C出队，它们的索引1、2在队列数组中仍然指向正确的节点。</p>
<p><strong>DFS工作方式：</strong>
<div class="highlight"><pre><span></span><code>栈状态1: [A(0), B(1), C(2)]   // A→B→C
弹出C:   [A(0), B(1)]
新入栈: [A(0), B(1), D(2)]   // 索引2被重用！
</code></pre></div>
现在如果D的前驱指向索引1(B)，这是正确的。但如果继续回溯：
<div class="highlight"><pre><span></span><code>弹出D,B: [A(0)]
新入栈: [A(0), E(1)]         // 索引1被重用！
</code></pre></div>
如果E的前驱指向索引0(A)，这是正确的。但如果有节点前驱指向索引1，现在指向的是E而不是原来的B！</p>
<h3 id="_55">问题二：队列空间分配与迷宫大小的关系</h3>
<h4 id="_56">队列最小空间计算</h4>
<p><strong>理论分析：</strong>
- 最坏情况下，队列需要存储所有可达的迷宫位置
- 对于 <code>MAX_ROW × MAX_COL</code> 的迷宫，最大队列大小为迷宫中的通路数量</p>
<p><strong>具体计算：</strong>
<div class="highlight"><pre><span></span><code><span class="c1">// 我们的迷宫：5×5，但包含墙</span>
<span class="kt">int</span><span class="w"> </span><span class="n">maze</span><span class="p">[</span><span class="n">MAX_ROW</span><span class="p">][</span><span class="n">MAX_COL</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="p">{</span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">},</span><span class="w">  </span><span class="c1">// 3个通路</span>
<span class="w">    </span><span class="p">{</span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">},</span><span class="w">  </span><span class="c1">// 2个通路  </span>
<span class="w">    </span><span class="p">{</span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">},</span><span class="w">  </span><span class="c1">// 5个通路</span>
<span class="w">    </span><span class="p">{</span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">},</span><span class="w">  </span><span class="c1">// 2个通路</span>
<span class="w">    </span><span class="p">{</span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">}</span><span class="w">   </span><span class="c1">// 3个通路</span>
<span class="p">};</span>
<span class="c1">// 总通路数 = 3+2+5+2+3 = 15</span>
</code></pre></div></p>
<p><strong>但是！BFS的特性决定了实际需要的空间更少：</strong></p>
<h4 id="bfs">BFS的层次扩展特性</h4>
<p>BFS按层次扩展，队列中同时存在的最大节点数由<strong>迷宫宽度</strong>决定：</p>
<div class="highlight"><pre><span></span><code>层次0: [ (0,0) ]                     → 队列大小: 1
层次1: [ (1,0) ]                     → 队列大小: 1  
层次2: [ (2,0) ]                     → 队列大小: 1
层次3: [ (2,1), (3,0) ]              → 队列大小: 2
层次4: [ (2,2), (3,1), (4,0) ]       → 队列大小: 3
层次5: [ (2,3), (3,2), (4,1) ]       → 队列大小: 3
层次6: [ (2,4), (3,3), (4,2) ]       → 队列大小: 3
层次7: [ (3,4), (4,3) ]              → 队列大小: 2
层次8: [ (4,4) ]                     → 队列大小: 1
</code></pre></div>
<p><strong>关键发现</strong>：队列最大大小为3，远小于总通路数15！</p>
<h4 id="_57">通用公式</h4>
<p>对于 <code>m × n</code> 的迷宫，BFS队列的最大大小为：
<div class="highlight"><pre><span></span><code><span class="n">min</span><span class="p">(</span><span class="n">m</span><span class="p">,</span><span class="w"> </span><span class="n">n</span><span class="p">)</span><span class="w">  </span><span class="c1">// 大致关系，实际取决于迷宫结构</span>
</code></pre></div></p>
<p>更精确地说，最大队列大小由<strong>迷宫的最宽层次</strong>决定。</p>
<h3 id="bfs_1">改进的BFS实现（优化空间）</h3>
<p>基于以上分析，我们可以大幅减少队列空间：</p>
<div class="highlight"><pre><span></span><code><span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;stdio.h&gt;</span>

<span class="cp">#define MAX_ROW 5</span>
<span class="cp">#define MAX_COL 5</span>

<span class="c1">// 计算最小队列大小：迷宫最宽层次 + 安全边界</span>
<span class="c1">// 对于5x5迷宫，最宽层次通常不超过min(5,5)=5，加安全边界</span>
<span class="cp">#define QUEUE_SIZE 10  </span><span class="c1">// 原512 → 10，节省98%空间！</span>

<span class="k">struct</span><span class="w"> </span><span class="nc">point</span><span class="w"> </span><span class="p">{</span><span class="w"> </span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">row</span><span class="p">,</span><span class="w"> </span><span class="n">col</span><span class="p">;</span><span class="w"> </span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">predecessor</span><span class="p">;</span><span class="w">  </span><span class="c1">// 前驱在队列中的索引</span>
<span class="p">}</span><span class="w"> </span><span class="n">queue</span><span class="p">[</span><span class="n">QUEUE_SIZE</span><span class="p">];</span>

<span class="kt">int</span><span class="w"> </span><span class="n">head</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="n">tail</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>

<span class="c1">// 循环队列实现</span>
<span class="kt">void</span><span class="w"> </span><span class="nf">enqueue</span><span class="p">(</span><span class="k">struct</span><span class="w"> </span><span class="nc">point</span><span class="w"> </span><span class="n">p</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">queue</span><span class="p">[</span><span class="n">tail</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">p</span><span class="p">;</span>
<span class="w">    </span><span class="n">tail</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">tail</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="p">)</span><span class="w"> </span><span class="o">%</span><span class="w"> </span><span class="n">QUEUE_SIZE</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">struct</span><span class="w"> </span><span class="nc">point</span><span class="w"> </span><span class="n">dequeue</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">struct</span><span class="w"> </span><span class="nc">point</span><span class="w"> </span><span class="n">p</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">queue</span><span class="p">[</span><span class="n">head</span><span class="p">];</span>
<span class="w">    </span><span class="n">head</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">head</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="p">)</span><span class="w"> </span><span class="o">%</span><span class="w"> </span><span class="n">QUEUE_SIZE</span><span class="p">;</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">p</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span><span class="w"> </span><span class="n">is_empty</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">head</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">tail</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span><span class="w"> </span><span class="n">is_full</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="p">(</span><span class="n">tail</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="p">)</span><span class="w"> </span><span class="o">%</span><span class="w"> </span><span class="n">QUEUE_SIZE</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">head</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span><span class="w"> </span><span class="n">maze</span><span class="p">[</span><span class="n">MAX_ROW</span><span class="p">][</span><span class="n">MAX_COL</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="p">{</span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">},</span>
<span class="w">    </span><span class="p">{</span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">},</span>
<span class="w">    </span><span class="p">{</span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">},</span>
<span class="w">    </span><span class="p">{</span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">},</span>
<span class="w">    </span><span class="p">{</span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">}</span>
<span class="p">};</span>

<span class="kt">void</span><span class="w"> </span><span class="nf">print_maze</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">MAX_ROW</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">++</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">j</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">j</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">MAX_COL</span><span class="p">;</span><span class="w"> </span><span class="n">j</span><span class="o">++</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;%d &quot;</span><span class="p">,</span><span class="w"> </span><span class="n">maze</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]);</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">        </span><span class="n">putchar</span><span class="p">(</span><span class="sc">&#39;\n&#39;</span><span class="p">);</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;*********</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">void</span><span class="w"> </span><span class="nf">visit</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">row</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">col</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">is_full</span><span class="p">())</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;错误：队列已满！可能需要增大QUEUE_SIZE</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
<span class="w">        </span><span class="k">return</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="k">struct</span><span class="w"> </span><span class="nc">point</span><span class="w"> </span><span class="n">visit_point</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">row</span><span class="p">,</span><span class="w"> </span><span class="n">col</span><span class="p">,</span><span class="w"> </span><span class="n">head</span><span class="w"> </span><span class="p">};</span><span class="w"> </span><span class="c1">// 前驱是当前队首</span>
<span class="w">    </span><span class="n">maze</span><span class="p">[</span><span class="n">row</span><span class="p">][</span><span class="n">col</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">2</span><span class="p">;</span>
<span class="w">    </span><span class="n">enqueue</span><span class="p">(</span><span class="n">visit_point</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">int</span><span class="w"> </span><span class="nf">main</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">struct</span><span class="w"> </span><span class="nc">point</span><span class="w"> </span><span class="n">p</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">-1</span><span class="w"> </span><span class="p">};</span>

<span class="w">    </span><span class="n">maze</span><span class="p">[</span><span class="n">p</span><span class="p">.</span><span class="n">row</span><span class="p">][</span><span class="n">p</span><span class="p">.</span><span class="n">col</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">2</span><span class="p">;</span>
<span class="w">    </span><span class="n">enqueue</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>

<span class="w">    </span><span class="k">while</span><span class="w"> </span><span class="p">(</span><span class="o">!</span><span class="n">is_empty</span><span class="p">())</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">p</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">dequeue</span><span class="p">();</span>

<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">p</span><span class="p">.</span><span class="n">row</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">MAX_ROW</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">p</span><span class="p">.</span><span class="n">col</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">MAX_COL</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mi">1</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="k">break</span><span class="p">;</span>
<span class="w">        </span><span class="p">}</span>

<span class="w">        </span><span class="c1">// 探索四个方向</span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">p</span><span class="p">.</span><span class="n">col</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">MAX_COL</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">maze</span><span class="p">[</span><span class="n">p</span><span class="p">.</span><span class="n">row</span><span class="p">][</span><span class="n">p</span><span class="p">.</span><span class="n">col</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="p">]</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="n">visit</span><span class="p">(</span><span class="n">p</span><span class="p">.</span><span class="n">row</span><span class="p">,</span><span class="w"> </span><span class="n">p</span><span class="p">.</span><span class="n">col</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="p">);</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">p</span><span class="p">.</span><span class="n">row</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">MAX_ROW</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">maze</span><span class="p">[</span><span class="n">p</span><span class="p">.</span><span class="n">row</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="p">][</span><span class="n">p</span><span class="p">.</span><span class="n">col</span><span class="p">]</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="n">visit</span><span class="p">(</span><span class="n">p</span><span class="p">.</span><span class="n">row</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="n">p</span><span class="p">.</span><span class="n">col</span><span class="p">);</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">p</span><span class="p">.</span><span class="n">col</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="o">&gt;=</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">maze</span><span class="p">[</span><span class="n">p</span><span class="p">.</span><span class="n">row</span><span class="p">][</span><span class="n">p</span><span class="p">.</span><span class="n">col</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mi">1</span><span class="p">]</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="n">visit</span><span class="p">(</span><span class="n">p</span><span class="p">.</span><span class="n">row</span><span class="p">,</span><span class="w"> </span><span class="n">p</span><span class="p">.</span><span class="n">col</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mi">1</span><span class="p">);</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">p</span><span class="p">.</span><span class="n">row</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="o">&gt;=</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">maze</span><span class="p">[</span><span class="n">p</span><span class="p">.</span><span class="n">row</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mi">1</span><span class="p">][</span><span class="n">p</span><span class="p">.</span><span class="n">col</span><span class="p">]</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="n">visit</span><span class="p">(</span><span class="n">p</span><span class="p">.</span><span class="n">row</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="n">p</span><span class="p">.</span><span class="n">col</span><span class="p">);</span>
<span class="w">        </span><span class="p">}</span>

<span class="w">        </span><span class="n">print_maze</span><span class="p">();</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">p</span><span class="p">.</span><span class="n">row</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">MAX_ROW</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">p</span><span class="p">.</span><span class="n">col</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">MAX_COL</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mi">1</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="c1">// 重建路径</span>
<span class="w">        </span><span class="kt">int</span><span class="w"> </span><span class="n">path</span><span class="p">[</span><span class="mi">512</span><span class="p">];</span>
<span class="w">        </span><span class="kt">int</span><span class="w"> </span><span class="n">path_len</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>

<span class="w">        </span><span class="c1">// 从终点回溯到起点</span>
<span class="w">        </span><span class="kt">int</span><span class="w"> </span><span class="n">current_index</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">head</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">current_index</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span><span class="w"> </span><span class="n">current_index</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">QUEUE_SIZE</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span>

<span class="w">        </span><span class="k">while</span><span class="w"> </span><span class="p">(</span><span class="n">current_index</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="mi">-1</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="n">path</span><span class="p">[</span><span class="n">path_len</span><span class="o">++</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">current_index</span><span class="p">;</span>
<span class="w">            </span><span class="n">current_index</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">queue</span><span class="p">[</span><span class="n">current_index</span><span class="p">].</span><span class="n">predecessor</span><span class="p">;</span>
<span class="w">        </span><span class="p">}</span>

<span class="w">        </span><span class="c1">// 正向打印路径</span>
<span class="w">        </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;路径(从起点到终点):</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
<span class="w">        </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">path_len</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&gt;=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">--</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="kt">int</span><span class="w"> </span><span class="n">idx</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">path</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
<span class="w">            </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;(%d, %d)&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">queue</span><span class="p">[</span><span class="n">idx</span><span class="p">].</span><span class="n">row</span><span class="p">,</span><span class="w"> </span><span class="n">queue</span><span class="p">[</span><span class="n">idx</span><span class="p">].</span><span class="n">col</span><span class="p">);</span>
<span class="w">            </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">i</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span><span class="w"> </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot; -&gt; &quot;</span><span class="p">);</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">        </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
<span class="w">    </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;No path!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>
<h3 id="_58">关键洞察总结</h3>
<h4 id="1_3">1. 前驱表示方法的差异</h4>
<p><strong>BFS能用队列索引表示前驱的原因：</strong>
- 队列顺序访问，索引稳定
- 前驱节点在队列数组中永久存在
- 索引单调递增（或循环），不会混淆</p>
<p><strong>DFS不能用栈索引表示前驱的原因：</strong>
- 栈回溯时索引被重用
- 前驱节点弹出后索引失效
- 索引指向的内容会变化</p>
<h4 id="2_5">2. 队列空间与迷宫大小的关系</h4>
<p><strong>队列最小空间由以下因素决定：</strong>
- <strong>迷宫宽度</strong>：决定BFS每层最大节点数
- <strong>迷宫结构</strong>：墙的分布影响实际扩展
- <strong>安全边界</strong>：防止边界情况下的队列溢出</p>
<p><strong>经验公式：</strong>
<div class="highlight"><pre><span></span><code><span class="c1">// 保守估计</span>
<span class="n">QUEUE_SIZE</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">min</span><span class="p">(</span><span class="n">MAX_ROW</span><span class="p">,</span><span class="w"> </span><span class="n">MAX_COL</span><span class="p">)</span><span class="w"> </span><span class="err">×</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">4</span><span class="p">;</span>

<span class="c1">// 我们的5x5迷宫</span>
<span class="n">QUEUE_SIZE</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">min</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span><span class="mi">5</span><span class="p">)</span><span class="w"> </span><span class="err">×</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">4</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">14</span>
<span class="c1">// 实际测试中8-10就足够了</span>
</code></pre></div></p>
<h4 id="3_6">3. 你的思考是正确的！</h4>
<p>你观察到的关键点：
- ✅ <strong>栈的top只能指向栈顶</strong>：确实，这限制了索引的稳定性
- ✅ <strong>队列大小与迷宫大小相关</strong>：正确，但不是简单的乘法关系
- ✅ <strong>BFS的空间效率比想象中高</strong>：因为按层次扩展，同时存在的节点数有限</p>
<h3 id="_59">实际应用建议</h3>
<ol>
<li><strong>对于BFS</strong>：使用 <code>QUEUE_SIZE = min(m, n) * 2 + 4</code> 作为安全大小</li>
<li><strong>对于DFS</strong>：必须使用独立的前驱数组，不能依赖栈索引</li>
<li><strong>通用规则</strong>：BFS空间复杂度 O(宽度)，DFS空间复杂度 O(深度)</li>
</ol>
<p>这种理解对于优化算法和避免内存浪费非常重要！</p>
<h2 id="11_command_interpreter">11_command_interpreter</h2>
<h3 id="_60">代码</h3>
<div class="highlight"><pre><span></span><code><span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;stdio.h&gt;</span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;string.h&gt;</span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;stdlib.h&gt;</span>

<span class="cp">#define MAX_ARGS 10</span>
<span class="cp">#define MAX_INPUT_LENGTH 256</span>

<span class="kt">int</span><span class="w"> </span><span class="nf">shell_parse</span><span class="p">(</span><span class="kt">char</span><span class="w"> </span><span class="o">*</span><span class="n">buf</span><span class="p">,</span><span class="w"> </span><span class="kt">char</span><span class="w"> </span><span class="o">*</span><span class="n">argv</span><span class="p">[]);</span>
<span class="kt">void</span><span class="w"> </span><span class="nf">execute_command</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">argc</span><span class="p">,</span><span class="w"> </span><span class="kt">char</span><span class="w"> </span><span class="o">*</span><span class="n">argv</span><span class="p">[]);</span>

<span class="c1">// in:  format -&gt; hello world &quot;hello world&quot; 1234567</span>
<span class="c1">// Multiple command parameters entered from the command line (number of parameters does not exceed 10)</span>
<span class="c1">// out:  format -&gt; Parameter X: Content, Length: X</span>
<span class="c1">// Parse the command parameters through a character pointer array, and sequentially display the content and length of each parameter on the screen</span>
<span class="c1">//</span>
<span class="kt">int</span><span class="w"> </span><span class="nf">main</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">    </span><span class="kt">FILE</span><span class="w"> </span><span class="o">*</span><span class="n">file</span><span class="p">;</span>
<span class="w">    </span><span class="kt">char</span><span class="w"> </span><span class="n">input</span><span class="p">[</span><span class="n">MAX_INPUT_LENGTH</span><span class="p">];</span>
<span class="w">    </span><span class="kt">char</span><span class="w"> </span><span class="o">*</span><span class="n">argv</span><span class="p">[</span><span class="n">MAX_ARGS</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="nb">NULL</span><span class="p">};</span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">argc</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>

<span class="w">    </span><span class="n">file</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">fopen</span><span class="p">(</span><span class="s">&quot;command_file.txt&quot;</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;r&quot;</span><span class="p">);</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="o">!</span><span class="n">file</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">fprintf</span><span class="p">(</span><span class="n">stderr</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;❌ Error: Cannot open input file &#39;%s&#39;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;command_file.txt&quot;</span><span class="p">);</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;✅ Reading commands from &#39;%s&#39;:</span><span class="se">\n\n</span><span class="s">&quot;</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;command_file.txt&quot;</span><span class="p">);</span>

<span class="w">    </span><span class="k">while</span><span class="w"> </span><span class="p">(</span><span class="n">fgets</span><span class="p">(</span><span class="n">input</span><span class="p">,</span><span class="w"> </span><span class="n">MAX_INPUT_LENGTH</span><span class="p">,</span><span class="w"> </span><span class="n">file</span><span class="p">)</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="nb">NULL</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">input</span><span class="p">[</span><span class="n">strcspn</span><span class="p">(</span><span class="n">input</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">)]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="sc">&#39;\0&#39;</span><span class="p">;</span>

<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">strlen</span><span class="p">(</span><span class="n">input</span><span class="p">)</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="o">||</span><span class="w"> </span><span class="n">strspn</span><span class="p">(</span><span class="n">input</span><span class="p">,</span><span class="w"> </span><span class="s">&quot; </span><span class="se">\t</span><span class="s">&quot;</span><span class="p">)</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">strlen</span><span class="p">(</span><span class="n">input</span><span class="p">))</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="k">continue</span><span class="p">;</span>
<span class="w">        </span><span class="p">}</span>

<span class="w">        </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;➡️  Input: %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">input</span><span class="p">);</span>

<span class="w">        </span><span class="n">argc</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">shell_parse</span><span class="p">(</span><span class="n">input</span><span class="p">,</span><span class="w"> </span><span class="n">argv</span><span class="p">);</span>

<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">argc</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;⚠️  No valid command parsed.</span><span class="se">\n\n</span><span class="s">&quot;</span><span class="p">);</span>
<span class="w">            </span><span class="k">continue</span><span class="p">;</span>
<span class="w">        </span><span class="p">}</span>

<span class="w">        </span><span class="n">execute_command</span><span class="p">(</span><span class="n">argc</span><span class="p">,</span><span class="w"> </span><span class="n">argv</span><span class="p">);</span>
<span class="w">        </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="n">fclose</span><span class="p">(</span><span class="n">file</span><span class="p">);</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">enum</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">STATE_INIT</span><span class="p">,</span>
<span class="w">    </span><span class="n">STATE_IN_WORD</span>
<span class="p">};</span>

<span class="c1">// shell_parse 和 execute_command 保持不变</span>
<span class="kt">int</span><span class="w"> </span><span class="nf">shell_parse</span><span class="p">(</span><span class="kt">char</span><span class="w"> </span><span class="o">*</span><span class="n">buf</span><span class="p">,</span><span class="w"> </span><span class="kt">char</span><span class="w"> </span><span class="o">*</span><span class="n">argv</span><span class="p">[])</span>
<span class="p">{</span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">argc</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">state</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="w">    </span><span class="kt">char</span><span class="w"> </span><span class="o">*</span><span class="n">current</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">buf</span><span class="p">;</span>
<span class="w">    </span><span class="kt">char</span><span class="w"> </span><span class="o">*</span><span class="n">start</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">buf</span><span class="p">;</span>

<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">buf</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="nb">NULL</span><span class="w"> </span><span class="o">||</span><span class="w"> </span><span class="n">argv</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="nb">NULL</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="k">while</span><span class="w"> </span><span class="p">(</span><span class="o">*</span><span class="n">current</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="sc">&#39;\0&#39;</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">argc</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">MAX_ARGS</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="k">switch</span><span class="w"> </span><span class="p">(</span><span class="n">state</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="k">case</span><span class="w"> </span><span class="no">STATE_INIT</span><span class="p">:</span>
<span class="w">            </span><span class="c1">// 刚开始，遇到正常字符（非空白），存好开始位置，进入下一个状态处理</span>
<span class="w">            </span><span class="c1">// 如果时空格，换行，回车，则跳过，不做处理，跳过即可</span>
<span class="w">            </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="o">*</span><span class="n">current</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="sc">&#39;\0&#39;</span><span class="w"> </span><span class="o">||</span><span class="w"> </span><span class="o">*</span><span class="n">current</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="sc">&#39;\t&#39;</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">                </span><span class="n">current</span><span class="o">++</span><span class="p">;</span>
<span class="w">            </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="p">{</span>
<span class="w">                </span><span class="n">start</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">current</span><span class="p">;</span>
<span class="w">                </span><span class="n">state</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">STATE_IN_WORD</span><span class="p">;</span>
<span class="w">                </span><span class="n">current</span><span class="o">++</span><span class="p">;</span>
<span class="w">            </span><span class="p">}</span>
<span class="w">            </span><span class="k">break</span><span class="p">;</span>
<span class="w">        </span><span class="k">case</span><span class="w"> </span><span class="no">STATE_IN_WORD</span><span class="p">:</span>
<span class="w">            </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="o">*</span><span class="n">current</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="sc">&#39; &#39;</span><span class="w"> </span><span class="o">||</span><span class="w"> </span><span class="o">*</span><span class="n">current</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="sc">&#39;\t&#39;</span><span class="w"> </span><span class="o">||</span><span class="w"> </span><span class="o">*</span><span class="p">(</span><span class="n">current</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="p">)</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="sc">&#39;\0&#39;</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">                </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="o">*</span><span class="p">(</span><span class="n">current</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="p">)</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="sc">&#39;\0&#39;</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="o">*</span><span class="n">current</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="sc">&#39; &#39;</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="o">*</span><span class="n">current</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="sc">&#39;\t&#39;</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">                    </span><span class="c1">// 如果最后一个字符不是空白，需要包含它</span>
<span class="w">                    </span><span class="n">current</span><span class="o">++</span><span class="p">;</span>
<span class="w">                </span><span class="p">}</span>
<span class="w">                </span><span class="c1">// 结束当前参数</span>
<span class="w">                </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="o">*</span><span class="n">current</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="sc">&#39; &#39;</span><span class="w"> </span><span class="o">||</span><span class="w"> </span><span class="o">*</span><span class="n">current</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="sc">&#39;\t&#39;</span><span class="w"> </span><span class="o">||</span><span class="w"> </span><span class="o">*</span><span class="n">current</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="sc">&#39;\0&#39;</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">                    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="o">*</span><span class="n">current</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="sc">&#39; &#39;</span><span class="w"> </span><span class="o">||</span><span class="w"> </span><span class="o">*</span><span class="n">current</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="sc">&#39;\t&#39;</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">                        </span><span class="o">*</span><span class="n">current</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="sc">&#39;\0&#39;</span><span class="p">;</span>
<span class="w">                    </span><span class="p">}</span>
<span class="w">                    </span><span class="c1">// 指针存的是地址，而不是字符串</span>
<span class="w">                    </span><span class="c1">// 指针指向的地址存的是字符串的地址，而不是字符串本身</span>
<span class="w">                    </span><span class="c1">// 自己一开始的想法是一个个字符的复制，</span>
<span class="w">                    </span><span class="c1">// 这种方式低效还需要分配内存</span>
<span class="w">                    </span><span class="n">argv</span><span class="p">[</span><span class="n">argc</span><span class="o">++</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">start</span><span class="p">;</span>
<span class="w">                    </span><span class="n">state</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">STATE_INIT</span><span class="p">;</span>
<span class="w">                </span><span class="p">}</span>
<span class="w">                </span><span class="n">current</span><span class="o">++</span><span class="p">;</span><span class="w">                </span>
<span class="w">            </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="p">{</span>
<span class="w">                </span><span class="n">current</span><span class="o">++</span><span class="p">;</span>
<span class="w">            </span><span class="p">}</span>
<span class="w">            </span><span class="k">break</span><span class="p">;</span>
<span class="w">        </span><span class="k">default</span><span class="o">:</span>
<span class="w">            </span><span class="k">break</span><span class="p">;</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span><span class="c1">// 处理字符串结束时仍在单词状态的情况</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">state</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">STATE_IN_WORD</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">start</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="nb">NULL</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">argv</span><span class="p">[</span><span class="n">argc</span><span class="o">++</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">start</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">argc</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span><span class="w"> </span><span class="nf">execute_command</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">argc</span><span class="p">,</span><span class="w"> </span><span class="kt">char</span><span class="w"> </span><span class="o">*</span><span class="n">argv</span><span class="p">[])</span>
<span class="p">{</span>
<span class="w">    </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;Parsing result: Total %d parameters</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">argc</span><span class="p">);</span>

<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">argc</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">++</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;Parameter %d: Content: %s, Length: %zu</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
<span class="w">               </span><span class="n">i</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="n">argv</span><span class="p">[</span><span class="n">i</span><span class="p">],</span><span class="w"> </span><span class="n">strlen</span><span class="p">(</span><span class="n">argv</span><span class="p">[</span><span class="n">i</span><span class="p">]));</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">strcmp</span><span class="p">(</span><span class="n">argv</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="w"> </span><span class="s">&quot;help&quot;</span><span class="p">)</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;This is help command</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
<span class="w">    </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">strcmp</span><span class="p">(</span><span class="n">argv</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="w"> </span><span class="s">&quot;echo&quot;</span><span class="p">)</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;Echo: &quot;</span><span class="p">);</span>
<span class="w">        </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">argc</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">++</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;%s &quot;</span><span class="p">,</span><span class="w"> </span><span class="n">argv</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">        </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
<span class="w">    </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">strcmp</span><span class="p">(</span><span class="n">argv</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="w"> </span><span class="s">&quot;add&quot;</span><span class="p">)</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">argc</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">3</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="kt">int</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">atoi</span><span class="p">(</span><span class="n">argv</span><span class="p">[</span><span class="mi">1</span><span class="p">]);</span>
<span class="w">        </span><span class="kt">int</span><span class="w"> </span><span class="n">b</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">atoi</span><span class="p">(</span><span class="n">argv</span><span class="p">[</span><span class="mi">2</span><span class="p">]);</span>
<span class="w">        </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;%d + %d = %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="n">b</span><span class="p">,</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">b</span><span class="p">);</span>
<span class="w">    </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;Unknown command: %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">argv</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">}</span>
</code></pre></div>
<h3 id="_61">指针梳理</h3>
<p>你的问题很好！让我用<code>"abc defg"</code>这个例子一步步解析，解释指针操作的原理：</p>
<h4 id="_62">初始状态</h4>
<div class="highlight"><pre><span></span><code><span class="n">buf</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">&quot;abc defg&quot;</span>
<span class="n">argv</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">[</span><span class="nb">NULL</span><span class="p">,</span><span class="w"> </span><span class="nb">NULL</span><span class="p">,</span><span class="w"> </span><span class="nb">NULL</span><span class="p">,</span><span class="w"> </span><span class="p">...]</span><span class="w">  </span><span class="c1">// 初始为空</span>
<span class="n">argc</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span>
<span class="n">state</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">STATE_NORMAL</span>
<span class="n">current</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="err">↑</span><span class="w"> </span><span class="p">(</span><span class="n">指向</span><span class="sc">&#39;a&#39;</span><span class="p">)</span>
<span class="n">start</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">NULL</span>
</code></pre></div>
<h5 id="a">第一步：遇到字符'a'</h5>
<div class="highlight"><pre><span></span><code><span class="c1">// 状态：STATE_NORMAL, *current = &#39;a&#39;</span>
<span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="o">*</span><span class="n">current</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="sc">&#39; &#39;</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="o">*</span><span class="n">current</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="sc">&#39;\t&#39;</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">start</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">current</span><span class="p">;</span><span class="w">  </span><span class="c1">// start现在指向&#39;a&#39;</span>
<span class="p">}</span>
<span class="c1">// 此时：start = ↑ (指向&#39;a&#39;)</span>
</code></pre></div>
<h5 id="_63">第二步：继续扫描到空格</h5>
<div class="highlight"><pre><span></span><code><span class="c1">// 扫描过程：a→b→c→空格</span>
<span class="c1">// 当current指向空格时：</span>
<span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">state</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">STATE_NORMAL</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">start</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="p">(</span><span class="o">*</span><span class="n">current</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="sc">&#39; &#39;</span><span class="p">))</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="o">*</span><span class="n">current</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="sc">&#39;\0&#39;</span><span class="p">;</span><span class="w">        </span><span class="c1">// 把空格变成字符串结束符</span>
<span class="w">    </span><span class="n">argv</span><span class="p">[</span><span class="n">argc</span><span class="o">++</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">start</span><span class="p">;</span><span class="w">   </span><span class="c1">// argv[0] = 指向&quot;abc&quot;的指针</span>
<span class="w">    </span><span class="n">start</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">NULL</span><span class="p">;</span><span class="w">           </span><span class="c1">// 重置start</span>
<span class="p">}</span>
</code></pre></div>
<h5 id="argvargc-start">关键理解：为什么<code>argv[argc++] = start</code>可行？</h5>
<h4 id="_64">内存布局变化：</h4>
<div class="highlight"><pre><span></span><code>处理前： [&#39;a&#39;,&#39;b&#39;,&#39;c&#39;,&#39; &#39;,&#39;d&#39;,&#39;e&#39;,&#39;f&#39;,&#39;g&#39;,&#39;\0&#39;]
         ↑
        start指向这里

处理后： [&#39;a&#39;,&#39;b&#39;,&#39;c&#39;,&#39;\0&#39;,&#39;d&#39;,&#39;e&#39;,&#39;f&#39;,&#39;g&#39;,&#39;\0&#39;]
         ↑
        argv[0]指向这里
</code></pre></div>
<h5 id="_65">指针赋值原理：</h5>
<ul>
<li><code>start</code>保存的是内存地址，不是字符串内容</li>
<li><code>argv[0] = start</code>只是复制了这个地址值</li>
<li>现在<code>argv[0]</code>指向以<code>\0</code>结尾的"abc"字符串</li>
</ul>
<h4 id="defg">第三步：处理"defg"</h4>
<div class="highlight"><pre><span></span><code><span class="c1">// current继续移动到&#39;d&#39;</span>
<span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="o">*</span><span class="n">current</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="sc">&#39; &#39;</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="o">*</span><span class="n">current</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="sc">&#39;\t&#39;</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">start</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">current</span><span class="p">;</span><span class="w">  </span><span class="c1">// start现在指向&#39;d&#39;</span>
<span class="p">}</span>

<span class="c1">// 扫描到字符串结尾时：</span>
<span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">state</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">STATE_NORMAL</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">start</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="o">*</span><span class="p">(</span><span class="n">current</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="p">)</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="sc">&#39;\0&#39;</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="c1">// 注意：此时current指向&#39;g&#39;，下一个字符是&#39;\0&#39;</span>
<span class="w">    </span><span class="n">argv</span><span class="p">[</span><span class="n">argc</span><span class="o">++</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">start</span><span class="p">;</span><span class="w">  </span><span class="c1">// argv[1] = 指向&quot;defg&quot;的指针</span>
<span class="p">}</span>
</code></pre></div>
<h4 id="_66">最终结果</h4>
<div class="highlight"><pre><span></span><code>内存: [&#39;a&#39;,&#39;b&#39;,&#39;c&#39;,&#39;\0&#39;,&#39;d&#39;,&#39;e&#39;,&#39;f&#39;,&#39;g&#39;,&#39;\0&#39;]
              ↑             ↑
         argv[0]       argv[1]

argv = [指向&quot;abc&quot;的指针, 指向&quot;defg&quot;的指针, NULL, ...]
argc = 2
</code></pre></div>
<h4 id="_67">与你想法"一个个字符赋值"的对比</h4>
<p><strong>你的想法（需要复制）：</strong>
<div class="highlight"><pre><span></span><code><span class="c1">// 低效方式</span>
<span class="kt">char</span><span class="w"> </span><span class="n">temp</span><span class="p">[</span><span class="mi">100</span><span class="p">];</span>
<span class="kt">int</span><span class="w"> </span><span class="n">j</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">buf</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="sc">&#39; &#39;</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">++</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">temp</span><span class="p">[</span><span class="n">j</span><span class="o">++</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">buf</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
<span class="p">}</span>
<span class="n">temp</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="sc">&#39;\0&#39;</span><span class="p">;</span>
<span class="n">argv</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">strdup</span><span class="p">(</span><span class="n">temp</span><span class="p">);</span><span class="w">  </span><span class="c1">// 还要分配新内存！</span>
</code></pre></div></p>
<p><strong>指针方式（原地操作）：</strong>
<div class="highlight"><pre><span></span><code><span class="c1">// 高效方式：只是记录位置，不复制内容</span>
<span class="n">start</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">current</span><span class="p">;</span><span class="w">  </span><span class="c1">// 记录开始位置</span>
<span class="c1">// ... 扫描到空格</span>
<span class="o">*</span><span class="n">current</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="sc">&#39;\0&#39;</span><span class="p">;</span><span class="w">  </span><span class="c1">// 插入结束符</span>
<span class="n">argv</span><span class="p">[</span><span class="n">argc</span><span class="o">++</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">start</span><span class="p">;</span><span class="w">  </span><span class="c1">// 记录指针</span>
</code></pre></div></p>
<h5 id="_68">优势</h5>
<ol>
<li><strong>零拷贝</strong>：不复制字符串内容</li>
<li><strong>高效</strong>：O(n)时间复杂度</li>
<li><strong>省内存</strong>：只在原字符串上操作</li>
</ol>
<p>这就是C语言字符串处理的精髓：通过指针和<code>\0</code>来"虚拟"分割字符串，而不是物理复制！</p>
<h3 id="bug">bug</h3>
<blockquote>
<p>很好的问题！让我详细解释为什么要这样修改，以及原代码的问题所在：</p>
<h2 id="_69">原代码的核心问题</h2>
<h3 id="1-state_init">1. STATE_INIT 状态的逻辑错误</h3>
<p><div class="highlight"><pre><span></span><code><span class="c1">// 原代码（错误）</span>
<span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="o">*</span><span class="n">current</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="sc">&#39;\0&#39;</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="o">*</span><span class="n">current</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="sc">&#39;\n&#39;</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="o">*</span><span class="n">current</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="sc">&#39;\r&#39;</span><span class="p">)</span>
</code></pre></div>
<strong>问题分析：</strong>
- 这个条件永远为假，因为一个字符不可能同时等于<code>\0</code>、<code>\n</code>和<code>\r</code>
- 实际上应该检查的是<strong>空白字符</strong>，而不是结束符
- 这导致STATE_INIT状态无法正确跳过空白字符</p>
<h3 id="2_6">2. 缺少字符串结束处理</h3>
<p><strong>问题表现：</strong>
- <code>"help"</code> 被解析为0个参数
- <code>"add 5 3"</code> 只解析出2个参数而不是3个</p>
<p><strong>原因：</strong>
当扫描到字符串结尾时，循环条件 <code>*current != '\0'</code> 为假，循环退出。但如果此时还在 <code>STATE_IN_WORD</code> 状态，最后一个参数没有被添加到 <code>argv</code> 中。</p>
<h2 id="_70">修改原理详解</h2>
<h3 id="1_4">1. 正确的空白字符处理</h3>
<p><div class="highlight"><pre><span></span><code><span class="c1">// 修改后</span>
<span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="o">*</span><span class="n">current</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="sc">&#39; &#39;</span><span class="w"> </span><span class="o">||</span><span class="w"> </span><span class="o">*</span><span class="n">current</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="sc">&#39;\t&#39;</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">current</span><span class="o">++</span><span class="p">;</span><span class="w">  </span><span class="c1">// 跳过空白字符</span>
<span class="p">}</span>
</code></pre></div>
<strong>为什么这样改：</strong>
- 在 <code>STATE_INIT</code> 状态，我们的任务是<strong>寻找参数的开始</strong>
- 遇到空格或制表符时，应该跳过，继续寻找
- 遇到非空白字符时，标记为参数开始，进入 <code>STATE_IN_WORD</code></p>
<h3 id="2_7">2. 字符串结束的特殊处理</h3>
<p><div class="highlight"><pre><span></span><code><span class="c1">// 处理字符串结束的情况</span>
<span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="o">*</span><span class="p">(</span><span class="n">current</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="p">)</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="sc">&#39;\0&#39;</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="o">*</span><span class="n">current</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="sc">&#39; &#39;</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="o">*</span><span class="n">current</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="sc">&#39;\t&#39;</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">current</span><span class="o">++</span><span class="p">;</span><span class="w">  </span><span class="c1">// 包含最后一个字符</span>
<span class="p">}</span>
</code></pre></div>
<strong>为什么需要这个：</strong>
考虑字符串 <code>"help"</code> 的解析过程：
<div class="highlight"><pre><span></span><code>初始: h e l p \0
          ↑
       current指向&#39;p&#39;时，下一个字符是&#39;\0&#39;
</code></pre></div>
如果不特殊处理，<code>current</code> 指向 'p' 时循环继续，但 'p' 不是空白字符，不会结束参数。然后循环检查 <code>*(current+1) == '\0'</code>，循环退出，参数丢失。</p>
<h3 id="3_7">3. 循环外的参数处理</h3>
<p><div class="highlight"><pre><span></span><code><span class="c1">// 处理字符串结束时仍在单词状态的情况</span>
<span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">state</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">STATE_IN_WORD</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">start</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="nb">NULL</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">argv</span><span class="p">[</span><span class="n">argc</span><span class="o">++</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">start</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>
<strong>为什么需要这个：</strong>
这是对上述情况的补充保障。即使前面的特殊处理没覆盖到，这里也能确保最后一个参数被添加。</p>
<h2 id="_71">状态机工作流程示例</h2>
<p>以 <code>"add 5 3"</code> 为例：</p>
<div class="highlight"><pre><span></span><code>初始: a d d   5   3 \0
状态: STATE_INIT
</code></pre></div>
<ol>
<li><strong>STATE_INIT</strong> → 遇到'a'，<code>start</code>指向'a'，进入<code>STATE_IN_WORD</code></li>
<li><strong>STATE_IN_WORD</strong> → 扫描到空格，结束"add"参数</li>
<li><strong>STATE_INIT</strong> → 跳过空格，遇到'5'，<code>start</code>指向'5'，进入<code>STATE_IN_WORD</code></li>
<li><strong>STATE_IN_WORD</strong> → 扫描到空格，结束"5"参数</li>
<li><strong>STATE_INIT</strong> → 跳过空格，遇到'3'，<code>start</code>指向'3'，进入<code>STATE_IN_WORD</code></li>
<li><strong>STATE_IN_WORD</strong> → 发现<code>*(current+1) == '\0'</code>，包含'3'，结束参数</li>
<li><strong>循环外检查</strong> → 确保"3"被添加</li>
</ol>
<h2 id="_72">总结</h2>
<p>这些修改确保了：
1. <strong>完整性</strong>：所有参数都被正确解析
2. <strong>正确性</strong>：空白字符被正确处理
3. <strong>边界安全</strong>：字符串开始和结束的情况都被覆盖
4. <strong>状态一致</strong>：状态机在各种情况下都能正确转换</p>
<p>这就是为什么需要这样修改的原因！</p>
</blockquote>
<h2 id="15_url_parser">15_url_parser</h2>
<h3 id="_73">代码</h3>
<div class="highlight"><pre><span></span><code><span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;stdio.h&gt;</span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;stdlib.h&gt;</span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;string.h&gt;</span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;errno.h&gt;</span>

<span class="cm">/**</span>
<span class="cm"> * URL参数解析器</span>
<span class="cm"> * 输入：包含http/https超链接的字符串</span>
<span class="cm"> * 输出：解析出所有的key-value键值对，每行显示一个</span>
<span class="cm"> */</span>
<span class="c1">// 该版本安全通过</span>
<span class="c1">// 完全避免动态内存分配</span>
<span class="c1">//  int parse_url(const char* url) {</span>
<span class="c1">//     int err = 0;</span>

<span class="c1">//     const char* query_start = strchr(url, &#39;?&#39;);</span>
<span class="c1">//     if (query_start == NULL) {</span>
<span class="c1">//         printf(&quot;没有查询参数\n&quot;);</span>
<span class="c1">//         err = -1;</span>
<span class="c1">//         goto exit;</span>
<span class="c1">//     }</span>

<span class="c1">//     query_start++;</span>

<span class="c1">//     const char* current = query_start;</span>
<span class="c1">//     while (*current != &#39;\0&#39;) {</span>
<span class="c1">//         // 找到当前参数的开始和结束</span>
<span class="c1">//         const char* param_start = current;</span>
<span class="c1">//         const char* param_end = strchr(param_start, &#39;&amp;&#39;);</span>

<span class="c1">//         if (param_end == NULL) {</span>
<span class="c1">//             param_end = param_start + strlen(param_start);</span>
<span class="c1">//         }</span>

<span class="c1">//         // 在当前参数中查找 =</span>
<span class="c1">//         const char* equal_sign = strchr(param_start, &#39;=&#39;);</span>
<span class="c1">//         if (equal_sign != NULL &amp;&amp; equal_sign &lt; param_end) {</span>
<span class="c1">//             printf(&quot;key = %.*s, value = %.*s\n&quot;, </span>
<span class="c1">//                 (int)(equal_sign - param_start), param_start,</span>
<span class="c1">//                 (int)(param_end - equal_sign - 1), equal_sign + 1);</span>
<span class="c1">//         } else {</span>
<span class="c1">//             // 只有 key，没有 value</span>
<span class="c1">//             printf(&quot;%.*s\n&quot;, (int)(param_end - param_start), param_start);</span>
<span class="c1">//         }</span>

<span class="c1">//         // 移动到下一个参数</span>
<span class="c1">//         if (*param_end == &#39;&amp;&#39;) {</span>
<span class="c1">//             current = param_end + 1;</span>
<span class="c1">//         } else {</span>
<span class="c1">//             break;</span>
<span class="c1">//         }</span>
<span class="c1">//     }</span>

<span class="c1">// exit:</span>
<span class="c1">//     return err;</span>
<span class="c1">// }</span>


<span class="c1">// 有问题，为什么这份代码在我对Ubuntu虚拟机上不会出问题？</span>
<span class="c1">// 但是在这里会崩溃？</span>
<span class="c1">// strtok的问题吗？strtok 函数会修改原始字符串，它用 \0 替换分隔符</span>
<span class="c1">// 但是操作的是复制过后的值了呀？</span>
<span class="c1">// 是因为编译器的问题？</span>
<span class="c1">// int parse_url(const char* url) {</span>
<span class="c1">//     int err = 0;</span>

<span class="c1">//     char *query_start  = strchr(url, &#39;?&#39;);</span>
<span class="c1">//     if (query_start == NULL) {</span>
<span class="c1">//         printf(&quot;没有查询参数\n&quot;);</span>
<span class="c1">//         err = -1;</span>
<span class="c1">//         goto exit;</span>
<span class="c1">//     }</span>

<span class="c1">//     query_start++;</span>
<span class="c1">//     // 复制参数字符串到可修改的缓冲区</span>
<span class="c1">//     char* query_str = strdup(query_start);</span>
<span class="c1">//     if (query_str == NULL) {</span>
<span class="c1">//         err = -1;</span>
<span class="c1">//         goto exit;</span>
<span class="c1">//     }</span>

<span class="c1">//     // printf(&quot;...test\n&quot;);</span>
<span class="c1">//     // 一开始怀疑是这里的问题，需要进一步证明</span>
<span class="c1">//     char* token = strtok(query_str, &quot;&amp;&quot;);</span>
<span class="c1">//     // printf(&quot;test...\n&quot;);</span>
<span class="c1">//     while (token != NULL) {</span>
<span class="c1">//         char *equal_sign = strchr(token, &#39;=&#39;);</span>
<span class="c1">//         if (equal_sign == NULL) {</span>
<span class="c1">//             printf(&quot;only key\n&quot;);</span>
<span class="c1">//         } else {</span>
<span class="c1">//             *equal_sign = &#39;\0&#39;;</span>
<span class="c1">//             printf(&quot;key = %s, value = %s\n&quot;, token, equal_sign + 1);</span>
<span class="c1">//         }</span>
<span class="c1">//         token = strtok(NULL, &quot;&amp;&quot;);</span>
<span class="c1">//     }</span>

<span class="c1">//     free(query_str);</span>
<span class="c1">// exit:</span>
<span class="c1">//     return err;</span>
<span class="c1">// }</span>


<span class="c1">// 这个版本也会出问题?</span>
<span class="c1">// 同样也是在这台机器上会有问题，但是在我的电脑上没有问题，在onlinegdb上跑也没问题</span>
<span class="c1">// 看看编译器版本？</span>
<span class="c1">// int parse_url(const char* url) {</span>
<span class="c1">//     int err = 0;</span>

<span class="c1">//     const char* query_start = strchr(url, &#39;?&#39;);</span>
<span class="c1">//     if (query_start == NULL) {</span>
<span class="c1">//         printf(&quot;没有查询参数\n&quot;);</span>
<span class="c1">//         err = -1;</span>
<span class="c1">//         goto exit;</span>
<span class="c1">//     }</span>

<span class="c1">//     query_start++;</span>

<span class="c1">//     // 复制参数字符串</span>
<span class="c1">//     char* query_str = strdup(query_start);</span>
<span class="c1">//     if (query_str == NULL) {</span>
<span class="c1">//         err = -1;</span>
<span class="c1">//         goto exit;</span>
<span class="c1">//     }</span>

<span class="c1">//     // 手动分割参数，避免使用 strtok</span>
<span class="c1">//     char* current = query_str;</span>
<span class="c1">//     while (*current != &#39;\0&#39;) {</span>
<span class="c1">//         // 找到当前参数的结尾（&amp; 或字符串结尾）</span>
<span class="c1">//         char* param_end = strchr(current, &#39;&amp;&#39;);</span>
<span class="c1">//         if (param_end != NULL) {</span>
<span class="c1">//             *param_end = &#39;\0&#39;;  // 临时截断</span>
<span class="c1">//         }</span>

<span class="c1">//         // 在当前参数中查找 =</span>
<span class="c1">//         char* equal_sign = strchr(current, &#39;=&#39;);</span>
<span class="c1">//         if (equal_sign != NULL) {</span>
<span class="c1">//             *equal_sign = &#39;\0&#39;;  // 分割 key 和 value</span>
<span class="c1">//             printf(&quot;key = %s, value = %s\n&quot;, current, equal_sign + 1);</span>
<span class="c1">//         } else {</span>
<span class="c1">//             printf(&quot;%s\n&quot;, current);</span>
<span class="c1">//         }</span>

<span class="c1">//         // 移动到下一个参数</span>
<span class="c1">//         if (param_end != NULL) {</span>
<span class="c1">//             current = param_end + 1;</span>
<span class="c1">//         } else {</span>
<span class="c1">//             break;  // 没有更多参数</span>
<span class="c1">//         }</span>
<span class="c1">//     }</span>

<span class="c1">//     free(query_str);</span>

<span class="c1">// exit:</span>
<span class="c1">//     return err;</span>
<span class="c1">// }</span>


<span class="c1">// 这一版使用malloc就行？</span>
<span class="c1">// 看来是这个云环境的libc库的strdup 有问题？</span>
<span class="kt">int</span><span class="w"> </span><span class="nf">parse_url</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="kt">char</span><span class="o">*</span><span class="w"> </span><span class="n">url</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">err</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>

<span class="w">    </span><span class="k">const</span><span class="w"> </span><span class="kt">char</span><span class="o">*</span><span class="w"> </span><span class="n">query_start</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">strchr</span><span class="p">(</span><span class="n">url</span><span class="p">,</span><span class="w"> </span><span class="sc">&#39;?&#39;</span><span class="p">);</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">query_start</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="nb">NULL</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;没有查询参数</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
<span class="w">        </span><span class="n">err</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">-1</span><span class="p">;</span>
<span class="w">        </span><span class="k">goto</span><span class="w"> </span><span class="n">exit</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="n">query_start</span><span class="o">++</span><span class="p">;</span>

<span class="w">    </span><span class="c1">// 使用 malloc + strcpy 替代 strdup</span>
<span class="w">    </span><span class="kt">size_t</span><span class="w"> </span><span class="n">len</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">strlen</span><span class="p">(</span><span class="n">query_start</span><span class="p">);</span>
<span class="w">    </span><span class="kt">char</span><span class="o">*</span><span class="w"> </span><span class="n">query_str</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="kt">char</span><span class="o">*</span><span class="p">)</span><span class="n">malloc</span><span class="p">(</span><span class="n">len</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="p">);</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">query_str</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="nb">NULL</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;内存分配失败</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
<span class="w">        </span><span class="n">err</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">-1</span><span class="p">;</span>
<span class="w">        </span><span class="k">goto</span><span class="w"> </span><span class="n">exit</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span><span class="n">strcpy</span><span class="p">(</span><span class="n">query_str</span><span class="p">,</span><span class="w"> </span><span class="n">query_start</span><span class="p">);</span>

<span class="w">    </span><span class="c1">// 手动分割参数</span>
<span class="w">    </span><span class="kt">char</span><span class="o">*</span><span class="w"> </span><span class="n">current</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">query_str</span><span class="p">;</span>
<span class="w">    </span><span class="k">while</span><span class="w"> </span><span class="p">(</span><span class="o">*</span><span class="n">current</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="sc">&#39;\0&#39;</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="kt">char</span><span class="o">*</span><span class="w"> </span><span class="n">param_end</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">strchr</span><span class="p">(</span><span class="n">current</span><span class="p">,</span><span class="w"> </span><span class="sc">&#39;&amp;&#39;</span><span class="p">);</span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">param_end</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="nb">NULL</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="o">*</span><span class="n">param_end</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="sc">&#39;\0&#39;</span><span class="p">;</span>
<span class="w">        </span><span class="p">}</span>

<span class="w">        </span><span class="kt">char</span><span class="o">*</span><span class="w"> </span><span class="n">equal_sign</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">strchr</span><span class="p">(</span><span class="n">current</span><span class="p">,</span><span class="w"> </span><span class="sc">&#39;=&#39;</span><span class="p">);</span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">equal_sign</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="nb">NULL</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="o">*</span><span class="n">equal_sign</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="sc">&#39;\0&#39;</span><span class="p">;</span>
<span class="w">            </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;key = %s, value = %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">current</span><span class="p">,</span><span class="w"> </span><span class="n">equal_sign</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="p">);</span>
<span class="w">        </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;%s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">current</span><span class="p">);</span>
<span class="w">        </span><span class="p">}</span>

<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">param_end</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="nb">NULL</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="n">current</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">param_end</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span>
<span class="w">        </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="k">break</span><span class="p">;</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="n">free</span><span class="p">(</span><span class="n">query_str</span><span class="p">);</span>

<span class="nl">exit</span><span class="p">:</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">err</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span><span class="w"> </span><span class="nf">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">const</span><span class="w"> </span><span class="kt">char</span><span class="o">*</span><span class="w"> </span><span class="n">test_url</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">&quot;https://cn.bing.com/search?name=John&amp;age=30&amp;city=New+York&quot;</span><span class="p">;</span>

<span class="w">    </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;Parsing URL: %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">test_url</span><span class="p">);</span>
<span class="w">    </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;Parameters:</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

<span class="w">    </span><span class="n">parse_url</span><span class="p">(</span><span class="n">test_url</span><span class="p">);</span>

<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>
<h2 id="16_mysed">16_mysed</h2>
<h2 id="17_myfile">17_myfile</h2>
<h2 id="18_mywc">18_mywc</h2>
<h2 id="19_mytrans">19_mytrans</h2>
<h2 id="20_mybash">20_mybash</h2>
<h2 id="todo">TODO</h2>
<h2 id="todo_1">TODO</h2>







  
    
  
  
    
  


  <aside class="md-source-file">
    
      
  <span class="md-source-file__fact">
    <span class="md-icon" title="Last update">
      <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M21 13.1c-.1 0-.3.1-.4.2l-1 1 2.1 2.1 1-1c.2-.2.2-.6 0-.8l-1.3-1.3c-.1-.1-.2-.2-.4-.2m-1.9 1.8-6.1 6V23h2.1l6.1-6.1zM12.5 7v5.2l4 2.4-1 1L11 13V7zM11 21.9c-5.1-.5-9-4.8-9-9.9C2 6.5 6.5 2 12 2c5.3 0 9.6 4.1 10 9.3-.3-.1-.6-.2-1-.2s-.7.1-1 .2C19.6 7.2 16.2 4 12 4c-4.4 0-8 3.6-8 8 0 4.1 3.1 7.5 7.1 7.9l-.1.2z"/></svg>
    </span>
    <span class="git-revision-date-localized-plugin git-revision-date-localized-plugin-timeago"><span class="timeago" datetime="2025-10-08T18:45:41+02:00" locale="en"></span></span><span class="git-revision-date-localized-plugin git-revision-date-localized-plugin-iso_date">2025-10-08</span>
  </span>

    
    
      
  <span class="md-source-file__fact">
    <span class="md-icon" title="Created">
      <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M14.47 15.08 11 13V7h1.5v5.25l3.08 1.83c-.41.28-.79.62-1.11 1m-1.39 4.84c-.36.05-.71.08-1.08.08-4.42 0-8-3.58-8-8s3.58-8 8-8 8 3.58 8 8c0 .37-.03.72-.08 1.08.69.1 1.33.32 1.92.64.1-.56.16-1.13.16-1.72 0-5.5-4.5-10-10-10S2 6.5 2 12s4.47 10 10 10c.59 0 1.16-.06 1.72-.16-.32-.59-.54-1.23-.64-1.92M18 15v3h-3v2h3v3h2v-3h3v-2h-3v-3z"/></svg>
    </span>
    <span class="git-revision-date-localized-plugin git-revision-date-localized-plugin-timeago"><span class="timeago" datetime="2025-10-08T18:45:41+02:00" locale="en"></span></span><span class="git-revision-date-localized-plugin git-revision-date-localized-plugin-iso_date">2025-10-08</span>
  </span>

    
    
    
  </aside>





                
              </article>
            </div>
          
          
<script>var target=document.getElementById(location.hash.slice(1));target&&target.name&&(target.checked=target.name.startsWith("__tabbed_"))</script>
        </div>
        
      </main>
      
        <footer class="md-footer">
  
    
  
  <div class="md-footer-meta md-typeset">
    <div class="md-footer-meta__inner md-grid">
      <div class="md-copyright">
  
  
    Made with
    <a href="https://squidfunk.github.io/mkdocs-material/" target="_blank" rel="noopener">
      Material for MkDocs
    </a>
  
</div>
      
        <div class="md-social">
  
    
    
    
    
    <a href="https://github.com/JAILuo" target="_blank" rel="noopener" title="JAILuo" class="md-social__link">
      <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 496 512"><!--! Font Awesome Free 6.7.1 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2024 Fonticons, Inc.--><path d="M165.9 397.4c0 2-2.3 3.6-5.2 3.6-3.3.3-5.6-1.3-5.6-3.6 0-2 2.3-3.6 5.2-3.6 3-.3 5.6 1.3 5.6 3.6m-31.1-4.5c-.7 2 1.3 4.3 4.3 4.9 2.6 1 5.6 0 6.2-2s-1.3-4.3-4.3-5.2c-2.6-.7-5.5.3-6.2 2.3m44.2-1.7c-2.9.7-4.9 2.6-4.6 4.9.3 2 2.9 3.3 5.9 2.6 2.9-.7 4.9-2.6 4.6-4.6-.3-1.9-3-3.2-5.9-2.9M244.8 8C106.1 8 0 113.3 0 252c0 110.9 69.8 205.8 169.5 239.2 12.8 2.3 17.3-5.6 17.3-12.1 0-6.2-.3-40.4-.3-61.4 0 0-70 15-84.7-29.8 0 0-11.4-29.1-27.8-36.6 0 0-22.9-15.7 1.6-15.4 0 0 24.9 2 38.6 25.8 21.9 38.6 58.6 27.5 72.9 20.9 2.3-16 8.8-27.1 16-33.7-55.9-6.2-112.3-14.3-112.3-110.5 0-27.5 7.6-41.3 23.6-58.9-2.6-6.5-11.1-33.3 2.6-67.9 20.9-6.5 69 27 69 27 20-5.6 41.5-8.5 62.8-8.5s42.8 2.9 62.8 8.5c0 0 48.1-33.6 69-27 13.7 34.7 5.2 61.4 2.6 67.9 16 17.7 25.8 31.5 25.8 58.9 0 96.5-58.9 104.2-114.8 110.5 9.2 7.9 17 22.9 17 46.4 0 33.7-.3 75.4-.3 83.6 0 6.5 4.6 14.4 17.3 12.1C428.2 457.8 496 362.9 496 252 496 113.3 383.5 8 244.8 8M97.2 352.9c-1.3 1-1 3.3.7 5.2 1.6 1.6 3.9 2.3 5.2 1 1.3-1 1-3.3-.7-5.2-1.6-1.6-3.9-2.3-5.2-1m-10.8-8.1c-.7 1.3.3 2.9 2.3 3.9 1.6 1 3.6.7 4.3-.7.7-1.3-.3-2.9-2.3-3.9-2-.6-3.6-.3-4.3.7m32.4 35.6c-1.6 1.3-1 4.3 1.3 6.2 2.3 2.3 5.2 2.6 6.5 1 1.3-1.3.7-4.3-1.3-6.2-2.2-2.3-5.2-2.6-6.5-1m-11.4-14.7c-1.6 1-1.6 3.6 0 5.9s4.3 3.3 5.6 2.3c1.6-1.3 1.6-3.9 0-6.2-1.4-2.3-4-3.3-5.6-2"/></svg>
    </a>
  
</div>
      
    </div>
  </div>
</footer>
      
    </div>
    <div class="md-dialog" data-md-component="dialog">
      <div class="md-dialog__inner md-typeset"></div>
    </div>
    
    
    <script id="__config" type="application/json">{"base": "../..", "features": ["navigation.footer"], "search": "../../assets/javascripts/workers/search.6ce7567c.min.js", "translations": {"clipboard.copied": "Copied to clipboard", "clipboard.copy": "Copy to clipboard", "search.result.more.one": "1 more on this page", "search.result.more.other": "# more on this page", "search.result.none": "No matching documents", "search.result.one": "1 matching document", "search.result.other": "# matching documents", "search.result.placeholder": "Type to start searching", "search.result.term.missing": "Missing", "select.version": "Select version"}}</script>
    
    
      <script src="../../assets/javascripts/bundle.83f73b43.min.js"></script>
      
        <script src="../../js/timeago.min.js"></script>
      
        <script src="../../js/timeago_mkdocs_material.js"></script>
      
        <script src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
      
    
  </body>
</html>