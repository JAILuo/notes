
<!doctype html>
<html lang="en" class="no-js">
  <head>
    
      <meta charset="utf-8">
      <meta name="viewport" content="width=device-width,initial-scale=1">
      
      
      
        <link rel="canonical" href="https://jailuo.github.io/notes/Linux/3.%20driver/1.%20high-level/high-level.html">
      
      
      
      
      <link rel="icon" href="../../../assets/images/favicon.png">
      <meta name="generator" content="mkdocs-1.6.1, mkdocs-material-9.5.48">
    
    
      
        <title>High level - Messy Notes</title>
      
    
    
      <link rel="stylesheet" href="../../../assets/stylesheets/main.6f8fc17f.min.css">
      
        
        <link rel="stylesheet" href="../../../assets/stylesheets/palette.06af60db.min.css">
      
      


    
    
      
    
    
      
        
        
        <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
        <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Roboto:300,300i,400,400i,700,700i%7CRoboto+Mono:400,400i,700,700i&display=fallback">
        <style>:root{--md-text-font:"Roboto";--md-code-font:"Roboto Mono"}</style>
      
    
    
      <link rel="stylesheet" href="../../../css/timeago.css">
    
    <script>__md_scope=new URL("../../..",location),__md_hash=e=>[...e].reduce(((e,_)=>(e<<5)-e+_.charCodeAt(0)),0),__md_get=(e,_=localStorage,t=__md_scope)=>JSON.parse(_.getItem(t.pathname+"."+e)),__md_set=(e,_,t=localStorage,a=__md_scope)=>{try{t.setItem(a.pathname+"."+e,JSON.stringify(_))}catch(e){}}</script>
    
      

    
    
    
  </head>
  
  
    
    
      
    
    
    
    
    <body dir="ltr" data-md-color-scheme="default" data-md-color-primary="indigo" data-md-color-accent="indigo">
  
    
    <input class="md-toggle" data-md-toggle="drawer" type="checkbox" id="__drawer" autocomplete="off">
    <input class="md-toggle" data-md-toggle="search" type="checkbox" id="__search" autocomplete="off">
    <label class="md-overlay" for="__drawer"></label>
    <div data-md-component="skip">
      
        
        <a href="#_1" class="md-skip">
          Skip to content
        </a>
      
    </div>
    <div data-md-component="announce">
      
    </div>
    
    
      

  

<header class="md-header md-header--shadow" data-md-component="header">
  <nav class="md-header__inner md-grid" aria-label="Header">
    <a href="../../../index.html" title="Messy Notes" class="md-header__button md-logo" aria-label="Messy Notes" data-md-component="logo">
      
  
  <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M12 8a3 3 0 0 0 3-3 3 3 0 0 0-3-3 3 3 0 0 0-3 3 3 3 0 0 0 3 3m0 3.54C9.64 9.35 6.5 8 3 8v11c3.5 0 6.64 1.35 9 3.54 2.36-2.19 5.5-3.54 9-3.54V8c-3.5 0-6.64 1.35-9 3.54"/></svg>

    </a>
    <label class="md-header__button md-icon" for="__drawer">
      
      <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M3 6h18v2H3zm0 5h18v2H3zm0 5h18v2H3z"/></svg>
    </label>
    <div class="md-header__title" data-md-component="header-title">
      <div class="md-header__ellipsis">
        <div class="md-header__topic">
          <span class="md-ellipsis">
            Messy Notes
          </span>
        </div>
        <div class="md-header__topic" data-md-component="header-topic">
          <span class="md-ellipsis">
            
              High level
            
          </span>
        </div>
      </div>
    </div>
    
      
        <form class="md-header__option" data-md-component="palette">
  
    
    
    
    <input class="md-option" data-md-color-media="" data-md-color-scheme="default" data-md-color-primary="indigo" data-md-color-accent="indigo"  aria-label="Switch to dark mode"  type="radio" name="__palette" id="__palette_0">
    
      <label class="md-header__button md-icon" title="Switch to dark mode" for="__palette_1" hidden>
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="m17.75 4.09-2.53 1.94.91 3.06-2.63-1.81-2.63 1.81.91-3.06-2.53-1.94L12.44 4l1.06-3 1.06 3zm3.5 6.91-1.64 1.25.59 1.98-1.7-1.17-1.7 1.17.59-1.98L15.75 11l2.06-.05L18.5 9l.69 1.95zm-2.28 4.95c.83-.08 1.72 1.1 1.19 1.85-.32.45-.66.87-1.08 1.27C15.17 23 8.84 23 4.94 19.07c-3.91-3.9-3.91-10.24 0-14.14.4-.4.82-.76 1.27-1.08.75-.53 1.93.36 1.85 1.19-.27 2.86.69 5.83 2.89 8.02a9.96 9.96 0 0 0 8.02 2.89m-1.64 2.02a12.08 12.08 0 0 1-7.8-3.47c-2.17-2.19-3.33-5-3.49-7.82-2.81 3.14-2.7 7.96.31 10.98 3.02 3.01 7.84 3.12 10.98.31"/></svg>
      </label>
    
  
    
    
    
    <input class="md-option" data-md-color-media="" data-md-color-scheme="slate" data-md-color-primary="indigo" data-md-color-accent="indigo"  aria-label="Switch to light mode"  type="radio" name="__palette" id="__palette_1">
    
      <label class="md-header__button md-icon" title="Switch to light mode" for="__palette_0" hidden>
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M12 7a5 5 0 0 1 5 5 5 5 0 0 1-5 5 5 5 0 0 1-5-5 5 5 0 0 1 5-5m0 2a3 3 0 0 0-3 3 3 3 0 0 0 3 3 3 3 0 0 0 3-3 3 3 0 0 0-3-3m0-7 2.39 3.42C13.65 5.15 12.84 5 12 5s-1.65.15-2.39.42zM3.34 7l4.16-.35A7.2 7.2 0 0 0 5.94 8.5c-.44.74-.69 1.5-.83 2.29zm.02 10 1.76-3.77a7.131 7.131 0 0 0 2.38 4.14zM20.65 7l-1.77 3.79a7.02 7.02 0 0 0-2.38-4.15zm-.01 10-4.14.36c.59-.51 1.12-1.14 1.54-1.86.42-.73.69-1.5.83-2.29zM12 22l-2.41-3.44c.74.27 1.55.44 2.41.44.82 0 1.63-.17 2.37-.44z"/></svg>
      </label>
    
  
</form>
      
    
    
      <script>var palette=__md_get("__palette");if(palette&&palette.color){if("(prefers-color-scheme)"===palette.color.media){var media=matchMedia("(prefers-color-scheme: light)"),input=document.querySelector(media.matches?"[data-md-color-media='(prefers-color-scheme: light)']":"[data-md-color-media='(prefers-color-scheme: dark)']");palette.color.media=input.getAttribute("data-md-color-media"),palette.color.scheme=input.getAttribute("data-md-color-scheme"),palette.color.primary=input.getAttribute("data-md-color-primary"),palette.color.accent=input.getAttribute("data-md-color-accent")}for(var[key,value]of Object.entries(palette.color))document.body.setAttribute("data-md-color-"+key,value)}</script>
    
    
    
      <label class="md-header__button md-icon" for="__search">
        
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0 1 16 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.52 6.52 0 0 1 9.5 16 6.5 6.5 0 0 1 3 9.5 6.5 6.5 0 0 1 9.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5"/></svg>
      </label>
      <div class="md-search" data-md-component="search" role="dialog">
  <label class="md-search__overlay" for="__search"></label>
  <div class="md-search__inner" role="search">
    <form class="md-search__form" name="search">
      <input type="text" class="md-search__input" name="query" aria-label="Search" placeholder="Search" autocapitalize="off" autocorrect="off" autocomplete="off" spellcheck="false" data-md-component="search-query" required>
      <label class="md-search__icon md-icon" for="__search">
        
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0 1 16 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.52 6.52 0 0 1 9.5 16 6.5 6.5 0 0 1 3 9.5 6.5 6.5 0 0 1 9.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5"/></svg>
        
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 320 512"><!--! Font Awesome Free 6.7.1 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2024 Fonticons, Inc.--><path d="M41.4 233.4c-12.5 12.5-12.5 32.8 0 45.3l160 160c12.5 12.5 32.8 12.5 45.3 0s12.5-32.8 0-45.3L109.3 256l137.3-137.4c12.5-12.5 12.5-32.8 0-45.3s-32.8-12.5-45.3 0l-160 160z"/></svg>
      </label>
      <nav class="md-search__options" aria-label="Search">
        
        <button type="reset" class="md-search__icon md-icon" title="Clear" aria-label="Clear" tabindex="-1">
          
          <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M19 6.41 17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12z"/></svg>
        </button>
      </nav>
      
    </form>
    <div class="md-search__output">
      <div class="md-search__scrollwrap" tabindex="0" data-md-scrollfix>
        <div class="md-search-result" data-md-component="search-result">
          <div class="md-search-result__meta">
            Initializing search
          </div>
          <ol class="md-search-result__list" role="presentation"></ol>
        </div>
      </div>
    </div>
  </div>
</div>
    
    
      <div class="md-header__source">
        <a href="https://github.com/JAILuo/notes" title="Go to repository" class="md-source" data-md-component="source">
  <div class="md-source__icon md-icon">
    
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 448 512"><!--! Font Awesome Free 6.7.1 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2024 Fonticons, Inc.--><path d="M439.55 236.05 244 40.45a28.87 28.87 0 0 0-40.81 0l-40.66 40.63 51.52 51.52c27.06-9.14 52.68 16.77 43.39 43.68l49.66 49.66c34.23-11.8 61.18 31 35.47 56.69-26.49 26.49-70.21-2.87-56-37.34L240.22 199v121.85c25.3 12.54 22.26 41.85 9.08 55a34.34 34.34 0 0 1-48.55 0c-17.57-17.6-11.07-46.91 11.25-56v-123c-20.8-8.51-24.6-30.74-18.64-45L142.57 101 8.45 235.14a28.86 28.86 0 0 0 0 40.81l195.61 195.6a28.86 28.86 0 0 0 40.8 0l194.69-194.69a28.86 28.86 0 0 0 0-40.81"/></svg>
  </div>
  <div class="md-source__repository">
    GitHub
  </div>
</a>
      </div>
    
  </nav>
  
</header>
    
    <div class="md-container" data-md-component="container">
      
      
        
          
        
      
      <main class="md-main" data-md-component="main">
        <div class="md-main__inner md-grid">
          
            
              
              <div class="md-sidebar md-sidebar--primary" data-md-component="sidebar" data-md-type="navigation" >
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    



<nav class="md-nav md-nav--primary" aria-label="Navigation" data-md-level="0">
  <label class="md-nav__title" for="__drawer">
    <a href="../../../index.html" title="Messy Notes" class="md-nav__button md-logo" aria-label="Messy Notes" data-md-component="logo">
      
  
  <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M12 8a3 3 0 0 0 3-3 3 3 0 0 0-3-3 3 3 0 0 0-3 3 3 3 0 0 0 3 3m0 3.54C9.64 9.35 6.5 8 3 8v11c3.5 0 6.64 1.35 9 3.54 2.36-2.19 5.5-3.54 9-3.54V8c-3.5 0-6.64 1.35-9 3.54"/></svg>

    </a>
    Messy Notes
  </label>
  
    <div class="md-nav__source">
      <a href="https://github.com/JAILuo/notes" title="Go to repository" class="md-source" data-md-component="source">
  <div class="md-source__icon md-icon">
    
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 448 512"><!--! Font Awesome Free 6.7.1 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2024 Fonticons, Inc.--><path d="M439.55 236.05 244 40.45a28.87 28.87 0 0 0-40.81 0l-40.66 40.63 51.52 51.52c27.06-9.14 52.68 16.77 43.39 43.68l49.66 49.66c34.23-11.8 61.18 31 35.47 56.69-26.49 26.49-70.21-2.87-56-37.34L240.22 199v121.85c25.3 12.54 22.26 41.85 9.08 55a34.34 34.34 0 0 1-48.55 0c-17.57-17.6-11.07-46.91 11.25-56v-123c-20.8-8.51-24.6-30.74-18.64-45L142.57 101 8.45 235.14a28.86 28.86 0 0 0 0 40.81l195.61 195.6a28.86 28.86 0 0 0 40.8 0l194.69-194.69a28.86 28.86 0 0 0 0-40.81"/></svg>
  </div>
  <div class="md-source__repository">
    GitHub
  </div>
</a>
    </div>
  
  <ul class="md-nav__list" data-md-scrollfix>
    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../../../index.html" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    首页
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    
    
    
    
    <li class="md-nav__item md-nav__item--nested">
      
        
        
        <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_2" >
        
          
          <label class="md-nav__link" for="__nav_2" id="__nav_2_label" tabindex="0">
            
  
  <span class="md-ellipsis">
    Article
  </span>
  

            <span class="md-nav__icon md-icon"></span>
          </label>
        
        <nav class="md-nav" data-md-level="1" aria-labelledby="__nav_2_label" aria-expanded="false">
          <label class="md-nav__title" for="__nav_2">
            <span class="md-nav__icon md-icon"></span>
            Article
          </label>
          <ul class="md-nav__list" data-md-scrollfix>
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="/article/concurrency sumary/summary.md" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    concurrency-summary
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="/article/toolchain/toolchain.mc" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    toolchain
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="/article/mount/mount.md" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    mount
  </span>
  

      </a>
    </li>
  

              
            
          </ul>
        </nav>
      
    </li>
  

    
      
      
  
  
  
  
    
    
    
    
    <li class="md-nav__item md-nav__item--nested">
      
        
        
        <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_3" >
        
          
          <label class="md-nav__link" for="__nav_3" id="__nav_3_label" tabindex="0">
            
  
  <span class="md-ellipsis">
    Course
  </span>
  

            <span class="md-nav__icon md-icon"></span>
          </label>
        
        <nav class="md-nav" data-md-level="1" aria-labelledby="__nav_3_label" aria-expanded="false">
          <label class="md-nav__title" for="__nav_3">
            <span class="md-nav__icon md-icon"></span>
            Course
          </label>
          <ul class="md-nav__list" data-md-scrollfix>
            
              
                
  
  
  
  
    
    
    
    
    <li class="md-nav__item md-nav__item--nested">
      
        
        
        <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_3_1" >
        
          
          <label class="md-nav__link" for="__nav_3_1" id="__nav_3_1_label" tabindex="0">
            
  
  <span class="md-ellipsis">
    University Course
  </span>
  

            <span class="md-nav__icon md-icon"></span>
          </label>
        
        <nav class="md-nav" data-md-level="2" aria-labelledby="__nav_3_1_label" aria-expanded="false">
          <label class="md-nav__title" for="__nav_3_1">
            <span class="md-nav__icon md-icon"></span>
            University Course
          </label>
          <ul class="md-nav__list" data-md-scrollfix>
            
              
                
  
  
  
  
    
    
    
    
    <li class="md-nav__item md-nav__item--nested">
      
        
        
        <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_3_1_1" >
        
          
          <label class="md-nav__link" for="__nav_3_1_1" id="__nav_3_1_1_label" tabindex="0">
            
  
  <span class="md-ellipsis">
    jyy OS2024
  </span>
  

            <span class="md-nav__icon md-icon"></span>
          </label>
        
        <nav class="md-nav" data-md-level="3" aria-labelledby="__nav_3_1_1_label" aria-expanded="false">
          <label class="md-nav__title" for="__nav_3_1_1">
            <span class="md-nav__icon md-icon"></span>
            jyy OS2024
          </label>
          <ul class="md-nav__list" data-md-scrollfix>
            
              
                
  
  
  
  
    
    
    
    
    <li class="md-nav__item md-nav__item--nested">
      
        
        
        <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_3_1_1_1" >
        
          
          <label class="md-nav__link" for="__nav_3_1_1_1" id="__nav_3_1_1_1_label" tabindex="0">
            
  
  <span class="md-ellipsis">
    course note
  </span>
  

            <span class="md-nav__icon md-icon"></span>
          </label>
        
        <nav class="md-nav" data-md-level="4" aria-labelledby="__nav_3_1_1_1_label" aria-expanded="false">
          <label class="md-nav__title" for="__nav_3_1_1_1">
            <span class="md-nav__icon md-icon"></span>
            course note
          </label>
          <ul class="md-nav__list" data-md-scrollfix>
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../../Course/University%20Course/jyy%20OS2024/cousre%20note/1.%20introduction/introduction.html" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    introduction
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../../Course/University%20Course/jyy%20OS2024/cousre%20note/2.%20concurrency/concurrency.html" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    concurrency
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../../Course/University%20Course/jyy%20OS2024/cousre%20note/3.%20virtualization/virtualization.html" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    virtualization
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../../Course/University%20Course/jyy%20OS2024/cousre%20note/4.%20kernel/kernel.html" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    kernel
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../../Course/University%20Course/jyy%20OS2024/cousre%20note/5.%20persistence/persistence.html" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    persistence
  </span>
  

      </a>
    </li>
  

              
            
          </ul>
        </nav>
      
    </li>
  

              
            
              
                
  
  
  
  
    
    
    
    
    <li class="md-nav__item md-nav__item--nested">
      
        
        
        <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_3_1_1_2" >
        
          
          <label class="md-nav__link" for="__nav_3_1_1_2" id="__nav_3_1_1_2_label" tabindex="0">
            
  
  <span class="md-ellipsis">
    Mini Labs
  </span>
  

            <span class="md-nav__icon md-icon"></span>
          </label>
        
        <nav class="md-nav" data-md-level="4" aria-labelledby="__nav_3_1_1_2_label" aria-expanded="false">
          <label class="md-nav__title" for="__nav_3_1_1_2">
            <span class="md-nav__icon md-icon"></span>
            Mini Labs
          </label>
          <ul class="md-nav__list" data-md-scrollfix>
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../../Course/University%20Course/jyy%20OS2024/Mini%20Labs/M1/M1.html" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    M1
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../../Course/University%20Course/jyy%20OS2024/Mini%20Labs/M2/M2.html" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    M2
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../../Course/University%20Course/jyy%20OS2024/Mini%20Labs/M3/M3.html" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    M3
  </span>
  

      </a>
    </li>
  

              
            
          </ul>
        </nav>
      
    </li>
  

              
            
              
                
  
  
  
  
    
    
    
    
    <li class="md-nav__item md-nav__item--nested">
      
        
        
        <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_3_1_1_3" >
        
          
          <label class="md-nav__link" for="__nav_3_1_1_3" id="__nav_3_1_1_3_label" tabindex="0">
            
  
  <span class="md-ellipsis">
    OS Labs
  </span>
  

            <span class="md-nav__icon md-icon"></span>
          </label>
        
        <nav class="md-nav" data-md-level="4" aria-labelledby="__nav_3_1_1_3_label" aria-expanded="false">
          <label class="md-nav__title" for="__nav_3_1_1_3">
            <span class="md-nav__icon md-icon"></span>
            OS Labs
          </label>
          <ul class="md-nav__list" data-md-scrollfix>
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../../Course/University%20Course/jyy%20OS2024/OS%20Labs/L0/L0.html" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    L0
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../../Course/University%20Course/jyy%20OS2024/OS%20Labs/L1/L1.html" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    L1
  </span>
  

      </a>
    </li>
  

              
            
          </ul>
        </nav>
      
    </li>
  

              
            
          </ul>
        </nav>
      
    </li>
  

              
            
          </ul>
        </nav>
      
    </li>
  

              
            
              
                
  
  
  
  
    
    
    
    
    <li class="md-nav__item md-nav__item--nested">
      
        
        
        <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_3_2" >
        
          
          <label class="md-nav__link" for="__nav_3_2" id="__nav_3_2_label" tabindex="0">
            
  
  <span class="md-ellipsis">
    GeekTime
  </span>
  

            <span class="md-nav__icon md-icon"></span>
          </label>
        
        <nav class="md-nav" data-md-level="2" aria-labelledby="__nav_3_2_label" aria-expanded="false">
          <label class="md-nav__title" for="__nav_3_2">
            <span class="md-nav__icon md-icon"></span>
            GeekTime
          </label>
          <ul class="md-nav__list" data-md-scrollfix>
            
              
                
  
  
  
  
    
    
    
    
    <li class="md-nav__item md-nav__item--nested">
      
        
        
        <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_3_2_1" >
        
          
          <label class="md-nav__link" for="__nav_3_2_1" id="__nav_3_2_1_label" tabindex="0">
            
  
  <span class="md-ellipsis">
    深入理解计算机组成原理
  </span>
  

            <span class="md-nav__icon md-icon"></span>
          </label>
        
        <nav class="md-nav" data-md-level="3" aria-labelledby="__nav_3_2_1_label" aria-expanded="false">
          <label class="md-nav__title" for="__nav_3_2_1">
            <span class="md-nav__icon md-icon"></span>
            深入理解计算机组成原理
          </label>
          <ul class="md-nav__list" data-md-scrollfix>
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../../Course/GeekTime/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/%E4%B8%80%E5%91%A8%E7%9B%AE/1.%20%E6%8C%87%E4%BB%A4%E4%B8%8E%E8%BF%90%E7%AE%97/%E6%8C%87%E4%BB%A4%E4%B8%8E%E8%BF%90%E7%AE%97.html" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    1. 指令与运算
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../../Course/GeekTime/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/%E4%B8%80%E5%91%A8%E7%9B%AE/2.%20%E5%A4%84%E7%90%86%E5%99%A8/%E5%A4%84%E7%90%86%E5%99%A8.html" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    2. 处理器
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../../Course/GeekTime/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/%E4%B8%80%E5%91%A8%E7%9B%AE/3.%20%E5%AD%98%E5%82%A8%E4%B8%8EIO%E7%B3%BB%E7%BB%9F/%E5%AD%98%E5%82%A8%E4%B8%8EIO%E7%B3%BB%E7%BB%9F.html" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    3. 存储与IO系统
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../../Course/GeekTime/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/%E4%B8%80%E5%91%A8%E7%9B%AE/4.%20%E5%BA%94%E7%94%A8/%E5%BA%94%E7%94%A8.html" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    4. 应用
  </span>
  

      </a>
    </li>
  

              
            
          </ul>
        </nav>
      
    </li>
  

              
            
              
                
  
  
  
  
    
    
    
    
    <li class="md-nav__item md-nav__item--nested">
      
        
        
        <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_3_2_2" >
        
          
          <label class="md-nav__link" for="__nav_3_2_2" id="__nav_3_2_2_label" tabindex="0">
            
  
  <span class="md-ellipsis">
    计算基础实战课
  </span>
  

            <span class="md-nav__icon md-icon"></span>
          </label>
        
        <nav class="md-nav" data-md-level="3" aria-labelledby="__nav_3_2_2_label" aria-expanded="false">
          <label class="md-nav__title" for="__nav_3_2_2">
            <span class="md-nav__icon md-icon"></span>
            计算基础实战课
          </label>
          <ul class="md-nav__list" data-md-scrollfix>
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../../Course/GeekTime/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80%E5%AE%9E%E6%88%98%E8%AF%BE/1.%20MiniCPU%E8%AE%BE%E8%AE%A1/MiniCPU%E8%AE%BE%E8%AE%A1.html" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    1. MiniCPU设计
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../../Course/GeekTime/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80%E5%AE%9E%E6%88%98%E8%AF%BE/2.%20%E8%AF%AD%E8%A8%80%E5%92%8C%E6%8C%87%E4%BB%A4/%E8%AF%AD%E8%A8%80%E5%92%8C%E6%8C%87%E4%BB%A4.html" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    2. 语言和指令
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../../Course/GeekTime/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80%E5%AE%9E%E6%88%98%E8%AF%BE/3.%20%E5%BA%94%E7%94%A8%E5%92%8C%E5%86%85%E5%AD%98/%E5%BA%94%E7%94%A8%E5%92%8C%E5%86%85%E5%AD%98.html" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    3. 应用和内存
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../../Course/GeekTime/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80%E5%AE%9E%E6%88%98%E8%AF%BE/4.%20IO%E4%B8%8E%E6%96%87%E4%BB%B6/IO%E5%92%8C%E6%96%87%E4%BB%B6.html" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    4. IO与文件
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../../Course/GeekTime/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80%E5%AE%9E%E6%88%98%E8%AF%BE/5.%20%E7%BB%BC%E5%90%88%E5%BA%94%E7%94%A8/synthesis.html" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    5. 综合应用
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../../Course/GeekTime/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80%E5%AE%9E%E6%88%98%E8%AF%BE/%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE%E5%92%8C%E5%B7%A5%E5%85%B7%E9%93%BE/%E7%9B%B8%E5%85%B3%E9%85%8D%E7%BD%AE.html" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    环境配置和工具链
  </span>
  

      </a>
    </li>
  

              
            
          </ul>
        </nav>
      
    </li>
  

              
            
          </ul>
        </nav>
      
    </li>
  

              
            
          </ul>
        </nav>
      
    </li>
  

    
      
      
  
  
  
  
    
    
    
    
    <li class="md-nav__item md-nav__item--nested">
      
        
        
        <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_4" >
        
          
          <label class="md-nav__link" for="__nav_4" id="__nav_4_label" tabindex="0">
            
  
  <span class="md-ellipsis">
    ysyx
  </span>
  

            <span class="md-nav__icon md-icon"></span>
          </label>
        
        <nav class="md-nav" data-md-level="1" aria-labelledby="__nav_4_label" aria-expanded="false">
          <label class="md-nav__title" for="__nav_4">
            <span class="md-nav__icon md-icon"></span>
            ysyx
          </label>
          <ul class="md-nav__list" data-md-scrollfix>
            
              
                
  
  
  
  
    
    
    
    
    <li class="md-nav__item md-nav__item--nested">
      
        
        
        <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_4_1" >
        
          
          <label class="md-nav__link" for="__nav_4_1" id="__nav_4_1_label" tabindex="0">
            
  
  <span class="md-ellipsis">
    NJU-ICS2023-PA
  </span>
  

            <span class="md-nav__icon md-icon"></span>
          </label>
        
        <nav class="md-nav" data-md-level="2" aria-labelledby="__nav_4_1_label" aria-expanded="false">
          <label class="md-nav__title" for="__nav_4_1">
            <span class="md-nav__icon md-icon"></span>
            NJU-ICS2023-PA
          </label>
          <ul class="md-nav__list" data-md-scrollfix>
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../../ysyx/pa/pa1/pa1.html" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    PA1
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../../ysyx/pa/pa2/pa2.html" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    PA2
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../../ysyx/pa/pa3/pa3.html" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    PA3
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../../ysyx/pa/pa4/pa4.html" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    PA4
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../../ysyx/pa/c_marco/macro.html" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    C Macro
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../../ysyx/pa/summary/summary.html" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Summary
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../../ysyx/pa/Linux_porting/porting.html" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Linux Porting
  </span>
  

      </a>
    </li>
  

              
            
          </ul>
        </nav>
      
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../../ysyx/digital-circuit/digital%20circuit.html" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Digital Circuit
  </span>
  

      </a>
    </li>
  

              
            
          </ul>
        </nav>
      
    </li>
  

    
      
      
  
  
  
  
    
    
    
    
    <li class="md-nav__item md-nav__item--nested">
      
        
        
        <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_5" >
        
          
          <label class="md-nav__link" for="__nav_5" id="__nav_5_label" tabindex="0">
            
  
  <span class="md-ellipsis">
    Tools
  </span>
  

            <span class="md-nav__icon md-icon"></span>
          </label>
        
        <nav class="md-nav" data-md-level="1" aria-labelledby="__nav_5_label" aria-expanded="false">
          <label class="md-nav__title" for="__nav_5">
            <span class="md-nav__icon md-icon"></span>
            Tools
          </label>
          <ul class="md-nav__list" data-md-scrollfix>
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../../Tools/GDB/GDB.html" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    GDB
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    
    
    
    
    <li class="md-nav__item md-nav__item--nested">
      
        
        
        <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_5_2" >
        
          
          <label class="md-nav__link" for="__nav_5_2" id="__nav_5_2_label" tabindex="0">
            
  
  <span class="md-ellipsis">
    Vim
  </span>
  

            <span class="md-nav__icon md-icon"></span>
          </label>
        
        <nav class="md-nav" data-md-level="2" aria-labelledby="__nav_5_2_label" aria-expanded="false">
          <label class="md-nav__title" for="__nav_5_2">
            <span class="md-nav__icon md-icon"></span>
            Vim
          </label>
          <ul class="md-nav__list" data-md-scrollfix>
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../../Tools/vim/usage/usage.html" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    usage
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../../Tools/vim/vim-plugin/vim.html" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    vim-plugin
  </span>
  

      </a>
    </li>
  

              
            
          </ul>
        </nav>
      
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../../Tools/doxygen/doxygen.html" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    doxygen
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../../Tools/gcc/gcc.html" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    gcc
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../../Tools/Git/Git.html" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Git
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../../Tools/md2slider/md2slider.html" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    md2slider
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../../Tools/tmux/tmux.html" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    tmux
  </span>
  

      </a>
    </li>
  

              
            
          </ul>
        </nav>
      
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../../../Todo%20List/todo.html" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    TODO List
  </span>
  

      </a>
    </li>
  

    
  </ul>
</nav>
                  </div>
                </div>
              </div>
            
            
              
              <div class="md-sidebar md-sidebar--secondary" data-md-component="sidebar" data-md-type="toc" >
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    

<nav class="md-nav md-nav--secondary" aria-label="Table of contents">
  
  
  
  
    <label class="md-nav__title" for="__toc">
      <span class="md-nav__icon md-icon"></span>
      Table of contents
    </label>
    <ul class="md-nav__list" data-md-component="toc" data-md-scrollfix>
      
        <li class="md-nav__item">
  <a href="#_1" class="md-nav__link">
    <span class="md-ellipsis">
      第一课
    </span>
  </a>
  
    <nav class="md-nav" aria-label="第一课">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_2" class="md-nav__link">
    <span class="md-ellipsis">
      学习方法
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_3" class="md-nav__link">
    <span class="md-ellipsis">
      (重)开发环境
    </span>
  </a>
  
    <nav class="md-nav" aria-label="(重)开发环境">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#1" class="md-nav__link">
    <span class="md-ellipsis">
      获取代码1
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#2" class="md-nav__link">
    <span class="md-ellipsis">
      获取代码2
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_4" class="md-nav__link">
    <span class="md-ellipsis">
      文档
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#gpio" class="md-nav__link">
    <span class="md-ellipsis">
      裸机如何访问 GPIO：阅读硬件文档
    </span>
  </a>
  
    <nav class="md-nav" aria-label="裸机如何访问 GPIO：阅读硬件文档">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_5" class="md-nav__link">
    <span class="md-ellipsis">
      阅读文档 / 硬件原理
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#linux-gpio" class="md-nav__link">
    <span class="md-ellipsis">
      Linux 访问 GPIO
    </span>
  </a>
  
    <nav class="md-nav" aria-label="Linux 访问 GPIO">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_6" class="md-nav__link">
    <span class="md-ellipsis">
      驱动接口 以及 字符设备驱动
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#gpio-mockup" class="md-nav__link">
    <span class="md-ellipsis">
      内核模块的编译和加载过程：gpio-mockup
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#gpio_1" class="md-nav__link">
    <span class="md-ellipsis">
      实践：使用寄存器访问 GPIO
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_7" class="md-nav__link">
    <span class="md-ellipsis">
      键盘输入时发生了什么
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#linux" class="md-nav__link">
    <span class="md-ellipsis">
      从广度了解 Linux 驱动
    </span>
  </a>
  
    <nav class="md-nav" aria-label="从广度了解 Linux 驱动">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_8" class="md-nav__link">
    <span class="md-ellipsis">
      如何画架构图
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#gpio-bitbang" class="md-nav__link">
    <span class="md-ellipsis">
      基于 GPIO 的 驱动 bitbang
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_9" class="md-nav__link">
    <span class="md-ellipsis">
      深度扩展
    </span>
  </a>
  
    <nav class="md-nav" aria-label="深度扩展">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#linux-gpio_1" class="md-nav__link">
    <span class="md-ellipsis">
      深入流程：Linux 下访问 GPIO 访问实际做了什么？
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#device-tree-acpi" class="md-nav__link">
    <span class="md-ellipsis">
      抽象能力：device tree 和 ACPI
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#dma" class="md-nav__link">
    <span class="md-ellipsis">
      第二课：驱动程序的寄存器访问和内存分配：DMA
    </span>
  </a>
  
    <nav class="md-nav" aria-label="第二课：驱动程序的寄存器访问和内存分配：DMA">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_10" class="md-nav__link">
    <span class="md-ellipsis">
      寄存器和内存访问的基础
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#linux_1" class="md-nav__link">
    <span class="md-ellipsis">
      裸机和 Linux 的寄存器访问
    </span>
  </a>
  
    <nav class="md-nav" aria-label="裸机和 Linux 的寄存器访问">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_11" class="md-nav__link">
    <span class="md-ellipsis">
      寄存器访问的特点
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#linux_2" class="md-nav__link">
    <span class="md-ellipsis">
      裸机寄存器访问 和 Linux 寄存器访问
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#armmemory-typedevice-memory" class="md-nav__link">
    <span class="md-ellipsis">
      内部原理：ARM架构：memory type：device memory
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#1mmu-dcache" class="md-nav__link">
    <span class="md-ellipsis">
      疑惑1：MMU 和 dcache 为什么会联系起来？
    </span>
  </a>
  
    <nav class="md-nav" aria-label="疑惑1：MMU 和 dcache 为什么会联系起来？">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#1_1" class="md-nav__link">
    <span class="md-ellipsis">
      1. 缓存策略的动态管理
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#2_1" class="md-nav__link">
    <span class="md-ellipsis">
      2. 访问速度差异的优化
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#1-mmio" class="md-nav__link">
    <span class="md-ellipsis">
      1. MMIO与普通内存的地址空间隔离
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#2_2" class="md-nav__link">
    <span class="md-ellipsis">
      2. 页表项属性位详解
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#3" class="md-nav__link">
    <span class="md-ellipsis">
      3. 操作系统中的实现
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#1-arm" class="md-nav__link">
    <span class="md-ellipsis">
      1. ARM架构
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#2-x86" class="md-nav__link">
    <span class="md-ellipsis">
      2. x86架构
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#1_2" class="md-nav__link">
    <span class="md-ellipsis">
      1. 缓存一致性问题
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#2-mmio" class="md-nav__link">
    <span class="md-ellipsis">
      2. MMIO访问优化
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#1-mmio_1" class="md-nav__link">
    <span class="md-ellipsis">
      1. 配置MMIO为非缓存
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#2_3" class="md-nav__link">
    <span class="md-ellipsis">
      2. 验证缓存策略
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#2-os-porting-cache" class="md-nav__link">
    <span class="md-ellipsis">
      疑惑2：为什么 OS porting 要考虑 cache 一致性
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_12" class="md-nav__link">
    <span class="md-ellipsis">
      大量数据访问
    </span>
  </a>
  
    <nav class="md-nav" aria-label="大量数据访问">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#dma_1" class="md-nav__link">
    <span class="md-ellipsis">
      DMA 入门
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#cache-api" class="md-nav__link">
    <span class="md-ellipsis">
      cache 一致性--&gt; 不同的API 选择
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_13" class="md-nav__link">
    <span class="md-ellipsis">
      缓存一致性与硬件/软件协作机制
    </span>
  </a>
  
    <nav class="md-nav" aria-label="缓存一致性与硬件/软件协作机制">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#1_3" class="md-nav__link">
    <span class="md-ellipsis">
      1. 缓存一致性的核心问题
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#2-dma-api" class="md-nav__link">
    <span class="md-ellipsis">
      2. DMA API的选择与缓存一致性
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#3_1" class="md-nav__link">
    <span class="md-ellipsis">
      3. 实际项目中的缓存维护操作
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#4" class="md-nav__link">
    <span class="md-ellipsis">
      4. 用户态与内核态访问寄存器的区别
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_14" class="md-nav__link">
    <span class="md-ellipsis">
      总结与建议
    </span>
  </a>
  
    <nav class="md-nav" aria-label="总结与建议">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#cpu" class="md-nav__link">
    <span class="md-ellipsis">
      CPU 访问内存
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#dma_2" class="md-nav__link">
    <span class="md-ellipsis">
      使用 DMA 搬移数据
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_15" class="md-nav__link">
    <span class="md-ellipsis">
      内存分配
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_16" class="md-nav__link">
    <span class="md-ellipsis">
      竞争和同步
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_17" class="md-nav__link">
    <span class="md-ellipsis">
      工作方法
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#_18" class="md-nav__link">
    <span class="md-ellipsis">
      第三课：中断和电源管理
    </span>
  </a>
  
    <nav class="md-nav" aria-label="第三课：中断和电源管理">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_19" class="md-nav__link">
    <span class="md-ellipsis">
      中断
    </span>
  </a>
  
    <nav class="md-nav" aria-label="中断">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_20" class="md-nav__link">
    <span class="md-ellipsis">
      架构图
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_21" class="md-nav__link">
    <span class="md-ellipsis">
      设备树
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#gic-400" class="md-nav__link">
    <span class="md-ellipsis">
      GIC-400 配置
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_22" class="md-nav__link">
    <span class="md-ellipsis">
      中断全流程
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#1-gic-400" class="md-nav__link">
    <span class="md-ellipsis">
      1. GIC-400 初始化
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#2-univ8250_console_init" class="md-nav__link">
    <span class="md-ellipsis">
      2. 设备初始化：univ8250_console_init
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#3_2" class="md-nav__link">
    <span class="md-ellipsis">
      3. 响应中断
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_23" class="md-nav__link">
    <span class="md-ellipsis">
      其他问题
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_24" class="md-nav__link">
    <span class="md-ellipsis">
      设备模型
    </span>
  </a>
  
    <nav class="md-nav" aria-label="设备模型">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#linux_3" class="md-nav__link">
    <span class="md-ellipsis">
      Linux 对设备抽象的演进
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_25" class="md-nav__link">
    <span class="md-ellipsis">
      为什么需要总线设备？
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_26" class="md-nav__link">
    <span class="md-ellipsis">
      设备模型核心概念
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#platform-bus" class="md-nav__link">
    <span class="md-ellipsis">
      platform bus
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#mmio" class="md-nav__link">
    <span class="md-ellipsis">
      MMIO 映射的寄存器属于控制器而非外设设备
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#i2cspi" class="md-nav__link">
    <span class="md-ellipsis">
      二、I2C/SPI 总线架构的硬件层级
    </span>
  </a>
  
    <nav class="md-nav" aria-label="二、I2C/SPI 总线架构的硬件层级">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#1-mmio_2" class="md-nav__link">
    <span class="md-ellipsis">
      1. 控制器寄存器（MMIO 映射）
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#2-mmio_1" class="md-nav__link">
    <span class="md-ellipsis">
      2. 外设寄存器（非 MMIO 映射）
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_27" class="md-nav__link">
    <span class="md-ellipsis">
      三、代码示例对比
    </span>
  </a>
  
    <nav class="md-nav" aria-label="三、代码示例对比">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#1-i2c-mmio" class="md-nav__link">
    <span class="md-ellipsis">
      1. I2C 控制器驱动（MMIO 操作）
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#2-i2c" class="md-nav__link">
    <span class="md-ellipsis">
      2. I2C 外设驱动（总线协议访问）
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_28" class="md-nav__link">
    <span class="md-ellipsis">
      四、关键差异总结
    </span>
  </a>
  
    <nav class="md-nav" aria-label="四、关键差异总结">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#1-mmio_3" class="md-nav__link">
    <span class="md-ellipsis">
      1. 为什么外设寄存器不直接 MMIO 映射？
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#2-mmio_2" class="md-nav__link">
    <span class="md-ellipsis">
      2. 例外情况：MMIO 外设
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#1-mmio_4" class="md-nav__link">
    <span class="md-ellipsis">
      1. 查看 MMIO 映射
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#2_4" class="md-nav__link">
    <span class="md-ellipsis">
      2. 跟踪总线操作
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#3-mmio" class="md-nav__link">
    <span class="md-ellipsis">
      3. 直接读写 MMIO（仅调试用！）
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#platform-device-platform-driver" class="md-nav__link">
    <span class="md-ellipsis">
      platform device 和 platform driver 和设备树
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#2-platform-driver" class="md-nav__link">
    <span class="md-ellipsis">
      步骤2：编写匹配设备树的 Platform Driver
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#i2c-camera" class="md-nav__link">
    <span class="md-ellipsis">
      设备访问全流程：I2C camera 为例
    </span>
  </a>
  
    <nav class="md-nav" aria-label="设备访问全流程：I2C camera 为例">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#v4l2" class="md-nav__link">
    <span class="md-ellipsis">
      通过V4L2框架访问（标准方式）
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#uart-uart" class="md-nav__link">
    <span class="md-ellipsis">
      拓展 UART：从零开发 UART驱动全流程
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#uart" class="md-nav__link">
    <span class="md-ellipsis">
      从零开发UART驱动的完整流程
    </span>
  </a>
  
    <nav class="md-nav" aria-label="从零开发UART驱动的完整流程">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_29" class="md-nav__link">
    <span class="md-ellipsis">
      一、硬件架构与设备树配置
    </span>
  </a>
  
    <nav class="md-nav" aria-label="一、硬件架构与设备树配置">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#1_4" class="md-nav__link">
    <span class="md-ellipsis">
      1. 硬件连接
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#2_5" class="md-nav__link">
    <span class="md-ellipsis">
      2. 设备树配置
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_30" class="md-nav__link">
    <span class="md-ellipsis">
      二、驱动层次结构
    </span>
  </a>
  
    <nav class="md-nav" aria-label="二、驱动层次结构">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#1-linux-tty" class="md-nav__link">
    <span class="md-ellipsis">
      1. Linux TTY子系统架构
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#2_6" class="md-nav__link">
    <span class="md-ellipsis">
      2. 关键数据结构
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_31" class="md-nav__link">
    <span class="md-ellipsis">
      三、驱动实现步骤
    </span>
  </a>
  
    <nav class="md-nav" aria-label="三、驱动实现步骤">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#1-uart" class="md-nav__link">
    <span class="md-ellipsis">
      1. 初始化UART驱动
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#2_7" class="md-nav__link">
    <span class="md-ellipsis">
      2. 实现硬件操作函数
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#3-platform" class="md-nav__link">
    <span class="md-ellipsis">
      3. 注册Platform驱动
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_32" class="md-nav__link">
    <span class="md-ellipsis">
      四、数据传输流程优化
    </span>
  </a>
  
    <nav class="md-nav" aria-label="四、数据传输流程优化">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#1_5" class="md-nav__link">
    <span class="md-ellipsis">
      1. 使用环形缓冲区
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#2_8" class="md-nav__link">
    <span class="md-ellipsis">
      2. 中断优化
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#3-dma" class="md-nav__link">
    <span class="md-ellipsis">
      3. 集成DMA（示例）
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_33" class="md-nav__link">
    <span class="md-ellipsis">
      五、调试与验证
    </span>
  </a>
  
    <nav class="md-nav" aria-label="五、调试与验证">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#1_6" class="md-nav__link">
    <span class="md-ellipsis">
      1. 用户空间测试
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#2_9" class="md-nav__link">
    <span class="md-ellipsis">
      2. 调试技巧
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_34" class="md-nav__link">
    <span class="md-ellipsis">
      六、总结
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#uart_1" class="md-nav__link">
    <span class="md-ellipsis">
      UART驱动层与应用层数据传输流程详解
    </span>
  </a>
  
    <nav class="md-nav" aria-label="UART驱动层与应用层数据传输流程详解">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#1_7" class="md-nav__link">
    <span class="md-ellipsis">
      1. 数据传输流程
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#2_10" class="md-nav__link">
    <span class="md-ellipsis">
      2. 避免数据丢失的关键方法
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#dma_3" class="md-nav__link">
    <span class="md-ellipsis">
      DMA在驱动开发中的核心作用与实现
    </span>
  </a>
  
    <nav class="md-nav" aria-label="DMA在驱动开发中的核心作用与实现">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#1-dma" class="md-nav__link">
    <span class="md-ellipsis">
      1. DMA的核心优势
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#2-dmauart" class="md-nav__link">
    <span class="md-ellipsis">
      2. DMA在UART驱动中的实现步骤
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#3-dma_1" class="md-nav__link">
    <span class="md-ellipsis">
      3. DMA开发中的关键注意事项
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#uartdma" class="md-nav__link">
    <span class="md-ellipsis">
      代码示例：UART驱动中的DMA发送
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_35" class="md-nav__link">
    <span class="md-ellipsis">
      总结
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#uart_2" class="md-nav__link">
    <span class="md-ellipsis">
      UART驱动实现详解
    </span>
  </a>
  
    <nav class="md-nav" aria-label="UART驱动实现详解">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#1_8" class="md-nav__link">
    <span class="md-ellipsis">
      1. 驱动架构与核心逻辑
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#2_11" class="md-nav__link">
    <span class="md-ellipsis">
      2. 数据传输流程
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#3_3" class="md-nav__link">
    <span class="md-ellipsis">
      3. 关键代码分析
    </span>
  </a>
  
    <nav class="md-nav" aria-label="3. 关键代码分析">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#31" class="md-nav__link">
    <span class="md-ellipsis">
      3.1 中断处理
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#32" class="md-nav__link">
    <span class="md-ellipsis">
      3.2 发送函数
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#4-uart" class="md-nav__link">
    <span class="md-ellipsis">
      4. 与标准UART流程的对比
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#5" class="md-nav__link">
    <span class="md-ellipsis">
      5. 优化建议与示例
    </span>
  </a>
  
    <nav class="md-nav" aria-label="5. 优化建议与示例">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#51" class="md-nav__link">
    <span class="md-ellipsis">
      5.1 完善中断处理
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#52-dma" class="md-nav__link">
    <span class="md-ellipsis">
      5.2 引入DMA发送
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#6" class="md-nav__link">
    <span class="md-ellipsis">
      6. 性能与可靠性优化
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#7" class="md-nav__link">
    <span class="md-ellipsis">
      7. 总结
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_36" class="md-nav__link">
    <span class="md-ellipsis">
      电源管理
    </span>
  </a>
  
    <nav class="md-nav" aria-label="电源管理">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_37" class="md-nav__link">
    <span class="md-ellipsis">
      电源管理的硬件架构
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#linux_4" class="md-nav__link">
    <span class="md-ellipsis">
      Linux 的 电源管理框架
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#linux_5" class="md-nav__link">
    <span class="md-ellipsis">
      Linux 的休眠唤醒
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#linux_6" class="md-nav__link">
    <span class="md-ellipsis">
      Linux 的唤醒源
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#linux_7" class="md-nav__link">
    <span class="md-ellipsis">
      Linux 唤醒演示实验
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_38" class="md-nav__link">
    <span class="md-ellipsis">
      具体流程
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#-soc" class="md-nav__link">
    <span class="md-ellipsis">
      - 《Soc 底层软件低功耗系统设计与实现》——李晓杰
    </span>
  </a>
  
    <nav class="md-nav" aria-label="- 《Soc 底层软件低功耗系统设计与实现》——李晓杰">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_39" class="md-nav__link">
    <span class="md-ellipsis">
      一、硬件架构核心概念深化
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#linux_8" class="md-nav__link">
    <span class="md-ellipsis">
      二、Linux电源管理框架深度解析
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#platform-device" class="md-nav__link">
    <span class="md-ellipsis">
      三、Platform Device电源管理实战
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_40" class="md-nav__link">
    <span class="md-ellipsis">
      四、深度调试技巧
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_41" class="md-nav__link">
    <span class="md-ellipsis">
      五、进阶学习建议
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#_42" class="md-nav__link">
    <span class="md-ellipsis">
      第四课：网络驱动
    </span>
  </a>
  
    <nav class="md-nav" aria-label="第四课：网络驱动">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_43" class="md-nav__link">
    <span class="md-ellipsis">
      网络协议栈
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#u-boot" class="md-nav__link">
    <span class="md-ellipsis">
      u-boot 下的网络驱动
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#linux_9" class="md-nav__link">
    <span class="md-ellipsis">
      Linux 网络协议栈
    </span>
  </a>
  
    <nav class="md-nav" aria-label="Linux 网络协议栈">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#linux_10" class="md-nav__link">
    <span class="md-ellipsis">
      Linux 网络驱动
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#_44" class="md-nav__link">
    <span class="md-ellipsis">
      第五课：调测
    </span>
  </a>
  
    <nav class="md-nav" aria-label="第五课：调测">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_45" class="md-nav__link">
    <span class="md-ellipsis">
      调测方法简述
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_46" class="md-nav__link">
    <span class="md-ellipsis">
      适合驱动的调测方法
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#linux-50" class="md-nav__link">
    <span class="md-ellipsis">
      Linux 5.0 以来重要的更新
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
    </ul>
  
</nav>
                  </div>
                </div>
              </div>
            
          
          
            <div class="md-content" data-md-component="content">
              <article class="md-content__inner md-typeset">
                
                  

  
  


  <h1>High level</h1>

<div class="highlight"><pre><span></span><code>graph LR
A[硬件协议] --&gt; B[驱动框架]
B --&gt; C[内核机制]
C --&gt; D[性能优化]
D --&gt; E[系统架构]
</code></pre></div>
<h2 id="_1">第一课</h2>
<h3 id="_2">学习方法</h3>
<p>设计、API、实践</p>
<p><img src="pic/image-20250314103558093.png" alt="image-20250314103558093" style="zoom:67%;" /></p>
<p><code>gpio</code> --&gt; 内存 --&gt; 网络</p>
<h3 id="_3">(重)开发环境</h3>
<h4 id="1">获取代码1</h4>
<p>现成组件、还是自己开发组件。如果用现成组件，用哪个版本？</p>
<p><img src="pic/image-20250314104145217.png" alt="image-20250314104145217" style="zoom: 67%;" /></p>
<ul>
<li>
<p>正式发布的软件包</p>
<ul>
<li>优势<ul>
<li>已经处理了部分或全部依赖关系，使用方便</li>
<li>编译流程已经实际验证郭，不需要手工微调</li>
</ul>
</li>
<li>劣势：<ul>
<li>没有版本管理，开发不便</li>
</ul>
</li>
</ul>
</li>
<li>
<p>SCM 仓库</p>
<ul>
<li>优势<ul>
<li>完整的版本历史，便于定位和分析工具</li>
<li>便于同时维护多个分支工具</li>
</ul>
</li>
<li>劣势<ul>
<li>需要单独处理依赖关系</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>比如提前预研的例子、具体例子。</p>
<h4 id="2">获取代码2<img alt="image-20250314104507904" src="pic/image-20250314104507904.png" /></h4>
<p>因为 git 是分布式的管理的，一个比较常用的就是多个 remote！回想自己 做 ysyx 的内容。</p>
<ul>
<li>
<p>怎么样算学习到位？</p>
<p>对官方文档是否清晰熟悉，能否通过搜索找到自己想要的内容。</p>
</li>
</ul>
<h4 id="_4">文档</h4>
<ul>
<li>
<p>官方文档</p>
<p>先看看原理清不清楚，再去看文档。</p>
<p><img src="pic/image-20250314104854576.png" alt="image-20250314104854576" style="zoom: 50%;" /></p>
</li>
<li>
<p><strong>搜索</strong></p>
<p>上位词与下位词</p>
<p>同义词和近义词</p>
<p>比如说拿到一块 Soc：H616（是 Cortex-A53的），ARMv8 就是其上位词。</p>
<p>搜 A53的cache，可能过于广泛，那就直接搜 ARMv8 的 cache</p>
<p>再有个例子（用近义词）：</p>
<p><img src="pic/image-20250314105404178.png" alt="image-20250314105404178" style="zoom:67%;" /></p>
<p><img src="pic/image-20250314105449973.png" alt="image-20250314105449973" style="zoom:50%;" /></p>
<p>按照不同的分类来搜索试试。</p>
<p>用一个详细例子：H616 DMA 怎么分连续的 2MiB 内存？</p>
<p>那就去看 armv8/ARM64怎么做。</p>
<p><img alt="image-20250314105640814" src="pic/image-20250314105640814.png" /></p>
<p>但是还是不够，需要去看看 Linux kernel 是怎么做的。（arm64 和 kernel 平级词，分开搜看看，当然现在有 AI，怎么找）</p>
<p>比如 各种分区、具体怎么分配，DMA有哪几类，各种</p>
</li>
</ul>
<h3 id="gpio">裸机如何访问 GPIO：阅读硬件文档</h3>
<blockquote>
<p>fH616 手册</p>
</blockquote>
<h4 id="_5">阅读文档 / 硬件原理</h4>
<p><img src="pic/image-20250314110116022.png" alt="image-20250314110116022" style="zoom: 67%;" /></p>
<p>I2C 的上拉和下拉，需要能够做什么？</p>
<p>驱动能力是否足够，从低电平到高电平的反转时间，上升沿的测？</p>
<p>是否需要中断：节省？中断硬连线的，有些 GPIO 不支持中断、唤醒的。</p>
<p>PH5、PH6</p>
<p><img alt="image-20250314111004123" src="pic/image-20250314111004123.png" /></p>
<p>看手册，知道这个地址是某一个GPIO的外设寄存器映射。</p>
<p><img src="pic/image-20250314111246107.png" alt="image-20250314111246107" style="zoom: 67%;" /></p>
<p>知道即可。不要过于陷入细节。</p>
<p>还有一个例子，关于供电：</p>
<p><img alt="image-20250314111632204" src="pic/image-20250314111632204.png" /></p>
<p>每一个GPIO的供电是不一样的，对应到硬件设计不同（LDO、DCDC：带负载能力和电流大小）</p>
<p>比如那个 PG口，选的是 <code>bldo1</code>，对应到设备树是 1.8 V</p>
<p>对应代码：<code>~/linux-6.8.1/arch/arm64/boot/dts/allwinner/sun50i-h616-orangepi-zero2.dts</code>，不同版本 kernel 可能不同。</p>
<p><img alt="image-20250314111606527" src="pic/image-20250314111606527.png" /></p>
<p><img src="pic/image-20250314112054241.png" alt="image-20250314112054241" style="zoom:67%;" /></p>
<h3 id="linux-gpio">Linux 访问 GPIO</h3>
<p><code>devmem</code> 控制寄存器，一般在产品中是不开启的。</p>
<p>实际用的是 VFIO、UIO</p>
<p>相当于之前在单片机，直接用库写寄存器。</p>
<p>比如我要直接调一个二进制的release 包，用 <code>ltrace/strace</code> 看看。</p>
<blockquote>
<p>实际上这都是 OS 课上非常常用的工具！</p>
</blockquote>
<p><img alt="image-20250314112937803" src="pic/image-20250314112937803.png" /></p>
<p>比如现场挂了，只能 open 一次，直接 <code>strace</code> 看看哪里有问题。</p>
<p>充分利用文档</p>
<p><img alt="image-20250314114312744" src="pic/image-20250314114312744.png" /></p>
<p><img alt="image-20250314113203705" src="pic/image-20250314113203705.png" /></p>
<p>无聊就看看，学原理：比如 <code>driver-api/driver.rst</code> 。多看内核文档！</p>
<p>核心：关键是理解 Linux 如何管理硬件。</p>
<p><img alt="image-20250314113516249" src="pic/image-20250314113516249.png" /></p>
<p>上面这些才是真正关键的，写代码甚至排在了后面。</p>
<blockquote>
<p>具体例子：</p>
<p>多个运算核，访问内存呢能力是不一样的，要说清这个资源？</p>
<p>理论上硬件差别和实际不一样？（有些内存，两个口接，不一样？给谁分配都一样？leader的工作，学学）</p>
<p>再比如各个模块的交互：gpio 模拟 i2c，怎么控制 i2c 的设备</p>
<p>关键在于 你怎么理清楚各个模块的流程。</p>
<p>搞清这个，再开始编码。</p>
</blockquote>
<p>但是，这距离硬件还有一定距离，对我们来说，一定要了解硬件架构是怎么样的，关键在于总线。</p>
<p><strong><mark>核心</mark></strong>：脑子里要有这个图，再去看各种手册。</p>
<p><img src="pic/image-20250314114919028.png" alt="image-20250314114919028" style="zoom: 67%;" /></p>
<p><img alt="image-20250314121232590" src="pic/image-20250314121232590.png" /></p>
<blockquote>
<p>ARM/RISC-V 内部基本就是这个图了。别的架构另说。</p>
</blockquote>
<p>脑子里有了框图之后，我们就是要回答一个问题；OS 怎么抽象 DMA 和 寄存器？这两个内容与 arch 没关系的，都是核心的。</p>
<p><img alt="image-20250314213518780" src="pic/image-20250314213518780.png" /></p>
<blockquote>
<p>大量寄存器也可以用 DMA 访问？USB、PCIe等模块也常用</p>
<p>关于模块的配置，可以用寄存器来访问，但这又有用问题：深度有限，没法放很多个，这对于软件来说不好？</p>
<p>一种方式就是通过 DMA，批量的寄存器访问放到内存里？</p>
<p>所以 PCIe、USB等硬件模块里也有一个 DMA，负责把内存区域里的内容读取回来？具体要深入学学看看。</p>
</blockquote>
<h4 id="_6">驱动接口 以及 字符设备驱动</h4>
<ul>
<li>
<p>驱动接口的目的：</p>
<ul>
<li>
<p>满足硬件需要</p>
</li>
<li>
<p>符合 Linux 系统设计思想</p>
</li>
</ul>
</li>
<li>
<p>写 <code>file_operation</code>：</p>
<p><code>open</code>、<code>read</code>、<code>write</code>、<code>ioctl</code>、<code>mmap</code></p>
</li>
</ul>
<blockquote>
<p>一个简单的字符设备驱动。jyy老师的例子。</p>
<p>关于字符设备，实际上比较少的，只有没法被归类的，比较老的才回到 字符设备（现在都是在 <code>misc</code> 类的）。</p>
</blockquote>
<h4 id="gpio-mockup">内核模块的编译和加载过程：<code>gpio-mockup</code></h4>
<p><img alt="image-20250314214628997" src="pic/image-20250314214628997.png" /></p>
<p>Linux 如何实现同一份代码可以编译进内核也可以编译为模块？</p>
<p>解析 module ：和 elf 文件类似 <code>kernel/module/main.c</code></p>
<p>解析完成之后，找到 elf 里的指针，这个指针实际做 <code>module_init</code></p>
<p>可以看看文档：<code>kernel/Documentation/admin-guide/gpio/gpio-mockup.rst</code></p>
<p>具体例子：8个 <code>gpio</code> 的，16个 <code>gpio</code> 的</p>
<p><code>modprobe gpio-mockup gpio_mockup_ranges=-1,8,-1,16</code></p>
<p>怎么找到这模块？根据 <code>uname -a</code> 名字。还有一些 <code>module</code> 依赖</p>
<p><img alt="image-20250314215754197" src="pic/image-20250314215754197.png" /></p>
<p>更多例子：e1000网卡驱动</p>
<p><img alt="image-20250314220139017" src="pic/image-20250314220139017.png" /></p>
<blockquote>
<p>当然这是自己电脑的。</p>
</blockquote>
<p>假如说我遇到了全志网卡的一个问题，不知道怎么做，一方面网上能直接查找到资料是最好的，如果不行，那就看看别的厂商是怎么做得：高通、龙芯的，去看看别的手册是怎么样的。</p>
<p><img alt="image-20250314220618670" src="pic/image-20250314220618670.png" /></p>
<p>具体 <code>gpio</code> 模块怎么做？一些工具：<code>gpio-event-mon -n gpiochip2 -o 0</code></p>
<h4 id="gpio_1">实践：使用寄存器访问 GPIO</h4>
<h3 id="_7">键盘输入时发生了什么</h3>
<p>多级理解：</p>
<ul>
<li>
<p>硬件到用户空间</p>
<p>就是一个终端发送一个1或者0到数据寄存器那里，用相关工具就能感知到，这很好理解，在做 PA 的时候实际就弄过这方面的内容。</p>
</li>
<li>
<p>现代的呢？具体业务的呢？</p>
<p>我想知道键盘输入时，我的Ubuntu系统发生了什么？搜索、AI。</p>
<p>搜到了：X server、Wayland。。。</p>
<p>怎么和键盘连上了？</p>
<p>还是用工具 <code>strace</code>、<code>ltrace</code></p>
<p><code>xinput</code> 通过一个socket 连。（能搜到，AI能回答）</p>
<p>那 x server 怎么和硬件沟通的？搜</p>
<p><img alt="image-20250314232352680" src="pic/image-20250314232352680.png" /></p>
<blockquote>
<p>strace支持用pid看进程的系统系统调用的。</p>
</blockquote>
</li>
</ul>
<h3 id="linux">从广度了解 Linux 驱动</h3>
<p>和 <code>GPIO</code> 类似的驱动：<code>UART</code>、<code>I2C</code>、<code>SPI</code></p>
<p>同样类似的，学习看文档：</p>
<p><code>find Documentation/ -name "*serial*" | grep -v device | vim -</code></p>
<p><code>find Documentation/ -name "*i2c*" | grep -v device | vim -</code></p>
<h4 id="_8">如何画架构图</h4>
<p><code>/Documentation/i2c/summary.rst</code></p>
<div class="highlight"><pre><span></span><code>-------------
|   API     |
-------------
     |
-------------
| algorithm |
-------------
     |
-------------
|   master  |
-------------
     |----------------|  --------------....
-------------    -------------
|   slave   |    |   slave   |
-------------    -------------
</code></pre></div>
<p>框架框架迁移到 stm32 。</p>
<h4 id="gpio-bitbang">基于 GPIO 的 驱动 bitbang</h4>
<p>软件模拟I2C</p>
<ul>
<li><code>Documentation/driver-api/gpio/drivers-on-gpio-rst</code></li>
<li>I2C 驱动（<code>gpio bitbang</code>）</li>
</ul>
<h3 id="_9">深度扩展</h3>
<h4 id="linux-gpio_1">深入流程：Linux 下访问 GPIO 访问实际做了什么？</h4>
<p><code>gpio-mockup</code> 里面使用了 irq sim，实际的 ARM Soc 普遍用 GIC，例如 GICv3的irq domain是树状借口的。</p>
<p>由于只用模拟这个中断，又不用真正触发这个中断</p>
<p>irq sim 模拟irq domain，触发中断，还是进到了中断处理函数，但不会真触发一个硬件中断。</p>
<p>irq domain 为什么有，这个有和谁相关</p>
<h4 id="device-tree-acpi">抽象能力：device tree 和 ACPI</h4>
<h2 id="dma">第二课：驱动程序的寄存器访问和内存分配：DMA</h2>
<h3 id="_10">寄存器和内存访问的基础</h3>
<p>还是从 上节课那个重要的图开始，CPU  &lt;---&gt; 总线 &lt;--&gt; 硬件模块（dma、pcie...）</p>
<p>有了这个图后，再去了解 xilinx 的 cache coherence 的文档</p>
<p><a href="https://xilinx-wiki.atlassian.net/wiki/spaces/A/pages/18842098/Zynq+UltraScale+MPSoC+Cache+Coherency">Zynq UltraScale+ MPSoC Cache Coherency - Xilinx Wiki - Confluence</a></p>
<blockquote>
<p>一些英语：</p>
<p>PS：逻辑固定的芯片被部分、PL：可编程的芯片部分（FPGA）</p>
<ul>
<li>
<p><code>baremetal</code>：</p>
<p>裸机：一般用在芯片验证或 OS 底层移植的上下文</p>
<p>裸金属：指不通过虚拟化管理组件（hypervisor）的虚拟化方式</p>
</li>
<li>
<p>总线：<code>bus</code>、<code>fabric</code>、<code>interconect</code></p>
<p><code>bus</code> 是总称；<code>fabric</code> 一般用于说具体的实现；<code>interconect</code> 一般翻译为互联，往往和同步、一致性可扩展性有关。</p>
</li>
<li>
<p><code>snoop</code></p>
</li>
<li>
<p><code>shareability</code></p>
<p>ARMv7a开始引入。ARMv8a里，所有 CPU 都在同一个 inner shareability </p>
</li>
</ul>
<p>能够主动发起访问、发起控制，能够当 master；只能被动接受的，当 slave。</p>
<p>注意，比如 DMA 既能当 master，又能当 slave。</p>
<p>比如，CPU 配置 DMA的时候，DMA这时候就当 slave了。</p>
<p><code>DeepSeek</code> 总结</p>
</blockquote>
<p>知道 cache coherence 是怎么走的。</p>
<p><img src="pic/image-20250315120039029.png" alt="image-20250315120039029" style="zoom: 67%;" /></p>
<h3 id="linux_1">裸机和 Linux 的寄存器访问</h3>
<h4 id="_11">寄存器访问的特点</h4>
<ul>
<li>重复可能有副作用</li>
<li>可能不支持多次读写。例如读清</li>
<li>配置有顺序要求</li>
<li>device memory<ul>
<li>gether</li>
<li>reorder</li>
<li>early acknowledge</li>
</ul>
</li>
</ul>
<h4 id="linux_2">裸机寄存器访问 和 Linux 寄存器访问</h4>
<p>三个大区别：</p>
<ul>
<li>
<p>是否开启 MMU </p>
<ul>
<li>裸机：没开MMU，<code>va=pa</code> （当然裸机也有开的，这里不考虑）</li>
<li>OS：开启 MMU </li>
</ul>
</li>
<li>
<p>使用 <code>volatile</code> 避免CPU从寄存器获取数据，确保CPU把数据写到地址而不仅仅写寄存器</p>
<p>比如要配某个 <code>gpio</code> 模块，通过 <code>mmio</code>，如果没有这个 <code>volatile</code>，可能导致配的数据还在CPU内部的寄存器，而没有真正写到 <code>gpio</code> 映射到内存中的地址</p>
<blockquote>
<p>具体例子</p>
</blockquote>
</li>
<li>
<p><code>data cache</code>，memory map （<code>mmio</code>）的寄存器需要建立映射吗</p>
<ul>
<li>
<p>裸机</p>
<p>没开数据cache，不需要为 <code>mmio</code> 的寄存器建立特别的映射</p>
</li>
<li>
<p>OS</p>
<p>有MMU后，来一个 data cache，需要为 <code>mmio</code> 的寄存器建立专门映射</p>
<blockquote>
<p>所以也就有了kernel中看到的 device memory 和 normal memory？</p>
<p><code>ioremap_xxx,memory type:device memory</code></p>
</blockquote>
</li>
</ul>
</li>
</ul>
<h4 id="armmemory-typedevice-memory">内部原理：ARM架构：memory type：<code>device memory</code></h4>
<p>当然，上面的内容是在 <strong>内核空间</strong> 下讨论的，那对于用户空间呢？</p>
<p>逻辑上也是要用 <code>ioremap</code>，但用户不能直接访问物理地址，所以用 API ！</p>
<blockquote>
<p>具体例子：</p>
<p><code>devmem</code> 用的就是 <code>mmap</code> ： </p>
<p><code>open</code> 的时候用的是 <code>O_SYNC</code>，而 <code>O_SYNC</code> 影响 <code>mmap</code> 的行为，所以，对于这部分 <code>mmio</code> 的寄存器，（因为是驱动的嘛，）OS 就让这个不会进 cache。 </p>
<p>如果不加 <code>O_SYNC</code> ，硬件现象是不一样的，有时能立刻反应，有时又不会；再接着，如果配了多个硬件寄存器，有时候工作有时不工作。</p>
<p>所以脑子要知道 cache coherence这个东西，配置要在具体预期之内，知道其行为。</p>
</blockquote>
<p>相关映射 API：<code>ioremap_xxx,memory type:device memory</code></p>
<h4 id="1mmu-dcache">疑惑1：MMU 和 <code>dcache</code> 为什么会联系起来？</h4>
<p><strong>核心：MMU与DCache协同工作机制及MMIO与内存地址空间区分</strong></p>
<ul>
<li>
<p><strong>一、MMU与DCache绑定的核心原因</strong></p>
<h5 id="1_1"><strong>1. 缓存策略的动态管理</strong></h5>
<ul>
<li><strong>功能协同</strong>：
    MMU负责虚拟地址到物理地址的转换，并在转换过程中通过页表项（Page Table Entry, PTE）指定内存区域的<strong>缓存属性</strong>（如是否可缓存、写回策略）。
    DCache则根据这些属性决定是否缓存该区域的数据。  </li>
<li><strong>外设寄存器（MMIO）的特殊性</strong>：
    MMIO区域的值由硬件外设动态更新，若被缓存，可能导致CPU读取过时数据（缓存与硬件状态不一致）。
    <strong>解决方案</strong>： 
    通过MMU页表项将MMIO区域标记为<strong>Non-cacheable</strong>，绕过DCache，确保每次访问直接读写硬件寄存器。</li>
</ul>
<h5 id="2_1"><strong>2. 访问速度差异的优化</strong></h5>
<ul>
<li><strong>普通内存</strong>：
    启用缓存（Cacheable）后，DCache可大幅提升访问速度（纳秒级延迟）。  </li>
<li><strong>MMIO区域</strong>：
    直接访问外设寄存器，通常无缓存（Non-cacheable），访问速度较慢（微秒级），但确保实时性与数据一致性。</li>
</ul>
</li>
<li>
<p><strong>二、地址空间划分与页表项配置</strong></p>
<h5 id="1-mmio"><strong>1. MMIO与普通内存的地址空间隔离</strong></h5>
<ul>
<li><strong>物理地址布局</strong>：  <ul>
<li><strong>普通内存区域</strong>：通常位于低地址段（如0x00000000~0x3FFFFFFF）。  </li>
<li><strong>MMIO区域</strong>：位于高地址段（如0x40000000~0xFFFFFFFF），由SoC厂商预定义。  </li>
</ul>
</li>
<li><strong>虚拟地址映射</strong>：<br />
    MMU通过页表将虚拟地址映射到不同的物理区域，并根据属性位区分访问策略。</li>
</ul>
<h5 id="2_2"><strong>2. 页表项属性位详解</strong></h5>
<p>在ARM架构中，页表项包含以下关键属性位：  </p>
<table>
<thead>
<tr>
<th><strong>属性位</strong></th>
<th><strong>功能</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>C (Cacheable)</strong></td>
<td>1=允许缓存，0=禁止缓存（用于MMIO）</td>
</tr>
<tr>
<td><strong>B (Bufferable)</strong></td>
<td>1=允许写缓冲，0=禁止写缓冲（MMIO通常设为0，确保写操作直达硬件）</td>
</tr>
<tr>
<td><strong>TEX[2:0]</strong></td>
<td>内存类型扩展（如Normal Memory、Device Memory）</td>
</tr>
<tr>
<td><strong>XN (Execute Never)</strong></td>
<td>1=禁止执行指令（MMIO区域通常设为1）</td>
</tr>
</tbody>
</table>
<ul>
<li>
<p><strong>MMIO页表示例</strong>：  </p>
<div class="highlight"><pre><span></span><code><span class="c1">// ARMv8页表项设置（Device-nGnRnE内存类型）</span>
<span class="n">pte</span><span class="w"> </span><span class="o">|=</span><span class="w"> </span><span class="p">(</span><span class="mh">0x0</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="mi">53</span><span class="p">)</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="p">(</span><span class="mh">0x0</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="mi">54</span><span class="p">);</span><span class="w">  </span><span class="c1">// TEX=0, C=0, B=0</span>
<span class="n">pte</span><span class="w"> </span><span class="o">|=</span><span class="w"> </span><span class="p">(</span><span class="mh">0x1</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="mi">53</span><span class="p">);</span><span class="w">                 </span><span class="c1">// 内存类型：Device-nGnRnE（严格顺序，无缓存）</span>
</code></pre></div>
</li>
</ul>
<h5 id="3"><strong>3. 操作系统中的实现</strong></h5>
<p>以Linux内核为例，MMIO区域通过<code>ioremap</code>函数映射为非缓存：  </p>
<div class="highlight"><pre><span></span><code><span class="kt">void</span><span class="w"> </span><span class="n">__iomem</span><span class="w"> </span><span class="o">*</span><span class="n">regs</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">ioremap</span><span class="p">(</span><span class="n">MMIO_PHYS_ADDR</span><span class="p">,</span><span class="w"> </span><span class="n">SIZE</span><span class="p">);</span>
<span class="c1">// 对应的页表项自动标记为Non-cacheable</span>
</code></pre></div>
</li>
<li>
<p><strong>三、不同架构的缓存与MMIO管理</strong></p>
<h5 id="1-arm"><strong>1. ARM架构</strong></h5>
<ul>
<li>
<p><strong>内存类型与属性</strong>：  </p>
<ul>
<li><strong>Normal Memory</strong>：可缓存，支持乱序访问（如普通DRAM）。  </li>
<li><strong>Device Memory</strong>：不可缓存，访问顺序严格（如MMIO）。  <ul>
<li><code>Device-nGnRnE</code>：最强限制（无重排序，无合并，无写缓冲）。  </li>
<li><code>Device-nGnRE</code>：允许写缓冲。  </li>
</ul>
</li>
</ul>
</li>
<li>
<p><strong>配置示例</strong>：  </p>
<div class="highlight"><pre><span></span><code><span class="c1">// 设置MMIO区域为Device-nGnRnE</span>
<span class="n">set_memory_attributes</span><span class="p">(</span><span class="n">addr</span><span class="p">,</span><span class="w"> </span><span class="n">size</span><span class="p">,</span><span class="w"> </span><span class="n">MT_DEVICE_nGnRnE</span><span class="p">);</span>
</code></pre></div>
</li>
</ul>
<h5 id="2-x86"><strong>2. x86架构</strong></h5>
<ul>
<li><strong>MTRR（Memory Type Range Registers）</strong>：
    定义物理地址范围的内存类型（如UC（Uncacheable）、WC（Write-Combining））。</li>
<li><strong>PAT（Page Attribute Table）</strong>：
    通过页表项扩展内存类型（如<code>PAT=1</code>时，页表项低3位定义缓存策略）。  </li>
</ul>
</li>
<li>
<p><strong>四、性能优化与问题规避</strong></p>
<h5 id="1_2"><strong>1. 缓存一致性问题</strong></h5>
<ul>
<li><strong>场景</strong>： 
    DMA控制器直接写入物理内存，若该区域被CPU缓存，可能导致缓存数据与内存不一致。  </li>
<li><strong>解决方案</strong>：  <ul>
<li><strong>软件维护</strong>：在DMA传输前后调用<code>dma_sync_single_for_device/cpu()</code>同步缓存。  </li>
<li><strong>硬件支持</strong>：启用硬件一致性（如ARM的CCI-400），自动维护缓存与内存一致性。</li>
</ul>
</li>
</ul>
<h5 id="2-mmio"><strong>2. MMIO访问优化</strong></h5>
<ul>
<li>
<p><strong>Write-Combining（WC）</strong>：<br />
    将多个MMIO写操作合并为一次总线传输，提升吞吐量（如x86的<code>MOVNTI</code>指令）。  </p>
</li>
<li>
<p><strong>示例</strong>：  </p>
<div class="highlight"><pre><span></span><code><span class="c1">// x86中设置MMIO区域为Write-Combining</span>
<span class="n">mtrr_add</span><span class="p">(</span><span class="n">MMIO_PHYS_ADDR</span><span class="p">,</span><span class="w"> </span><span class="n">SIZE</span><span class="p">,</span><span class="w"> </span><span class="n">MTRR_TYPE_WRCOMB</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">);</span>
</code></pre></div>
</li>
</ul>
</li>
<li>
<p><strong>五、实战示例：ARMv8页表配置</strong></p>
<h5 id="1-mmio_1"><strong>1. 配置MMIO为非缓存</strong></h5>
<div class="highlight"><pre><span></span><code><span class="c1">// 定义页表项属性</span>
<span class="cp">#define MT_DEVICE_nGnRnE 0x0   </span><span class="c1">// Device-nGnRnE类型</span>
<span class="cp">#define MT_NORMAL         0x4   </span><span class="c1">// Normal Memory类型</span>

<span class="c1">// 设置页表项</span>
<span class="kt">void</span><span class="w"> </span><span class="nf">set_pte_attrs</span><span class="p">(</span><span class="kt">uint64_t</span><span class="w"> </span><span class="o">*</span><span class="n">pte</span><span class="p">,</span><span class="w"> </span><span class="kt">uint64_t</span><span class="w"> </span><span class="n">pa</span><span class="p">,</span><span class="w"> </span><span class="kt">uint64_t</span><span class="w"> </span><span class="n">attrs</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="o">*</span><span class="n">pte</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">pa</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span><span class="n">PAGE_MASK</span><span class="p">)</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="p">(</span><span class="n">attrs</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="mi">2</span><span class="p">)</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="n">PTE_VALID</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">// 映射MMIO区域（Non-cacheable）</span>
<span class="n">set_pte_attrs</span><span class="p">(</span><span class="n">pte</span><span class="p">,</span><span class="w"> </span><span class="n">MMIO_PHYS_ADDR</span><span class="p">,</span><span class="w"> </span><span class="n">MT_DEVICE_nGnRnE</span><span class="p">);</span>
</code></pre></div>
<h5 id="2_3"><strong>2. 验证缓存策略</strong></h5>
<ul>
<li><strong>读取页表项</strong>：
    通过调试器（如JTAG）检查页表项的<code>C/B/TEX</code>位是否符合预期。  </li>
<li><strong>性能测试</strong>：
    对比启用/禁用缓存时的访问延迟（如使用<code>rdtsc</code>指令测量时间戳）。</li>
</ul>
</li>
<li>
<p><strong>六、总结与最佳实践</strong></p>
<ol>
<li><strong>严格区分内存类型</strong>：<ul>
<li>普通内存标记为<code>Cacheable</code>，外设寄存器标记为<code>Non-cacheable</code>。  </li>
</ul>
</li>
<li><strong>利用硬件特性</strong>：<ul>
<li>使用CCI-400或类似互连维护多主设备一致性。  </li>
</ul>
</li>
<li><strong>遵循架构规范</strong>：<ul>
<li>ARM的Device Memory类型、x86的MTRR/PAT配置需严格匹配硬件需求。  </li>
</ul>
</li>
<li><strong>调试与验证</strong>：<ul>
<li>通过性能分析工具（如<code>perf</code>）和硬件调试接口确保配置正确性。  </li>
</ul>
</li>
</ol>
</li>
</ul>
<h4 id="2-os-porting-cache">疑惑2：为什么 OS porting 要考虑 cache 一致性</h4>
<p>比如说 一些实际的ARM9 到 cortex-A9，一个带 cache，一个不带。</p>
<p>从上面的学习，知道的一个重点就是 memory 的类别：device memory、normal memory。所以，在移植的时候，需要详细考虑 cache 对 MMU 的影响（原因前面）：</p>
<ul>
<li>
<p><strong>页表配置</strong>：通过MMU将外设地址空间（MMIO）标记为 Device Memory（不可缓存），避免因缓存导致读写错误。</p>
</li>
<li>
<p><strong>内存类型设置</strong>：在页表项（PTE）中明确区分普通内存（Cacheable）与外设区域（Non-cacheable）。</p>
</li>
</ul>
<p>但还有什么？为什么结合到 cache？这里再借 <code>DeepSeek</code> 总结</p>
<h3 id="_12">大量数据访问</h3>
<h4 id="dma_1">DMA 入门</h4>
<p><strong>1. DMA是什么？</strong>
DMA（Direct Memory Access）是一种硬件模块，允许外设（如UART、SPI、网卡等）<strong>直接与内存交换数据</strong>，无需CPU参与。其核心价值是<strong>解放CPU资源</strong>，减少中断开销，提升数据传输效率。</p>
<p><img alt="image-20250325231143035" src="pic/image-20250325231143035.png" /></p>
<p><strong>理解 DMA 为一个只能执行 <code>memcpy</code>（给出address、buf、length等）的处理器！</strong> </p>
<p><strong>2. DMA的核心流程</strong></p>
<ul>
<li><strong>初始化</strong>：配置DMA控制器，指定源地址（数据来源）、目标地址（数据去向）、传输方向（内存→外设或外设→内存）和数据长度。</li>
<li><strong>触发传输</strong>：外设或软件触发DMA请求，DMA控制器接管总线，按配置搬运数据。</li>
<li><strong>传输完成</strong>：DMA控制器通过中断通知CPU，释放总线控制权。</li>
</ul>
<p><strong>3. DMA传输模式</strong></p>
<ul>
<li><strong>单次传输</strong>：传输指定长度的数据后停止，需重新配置才能再次传输。</li>
<li><strong>循环传输</strong>：自动重复传输，适用于持续数据流（如音频播放）。</li>
</ul>
<p><strong>4. 关键概念</strong></p>
<ul>
<li><strong>内存一致性</strong>：DMA操作的内存需是物理连续的，可通过<code>dma_alloc_coherent()</code>分配。</li>
<li><strong>中断协同</strong>：DMA传输完成后触发中断，CPU需处理数据或启动下一轮传输。</li>
</ul>
<p>快速入门：</p>
<div class="highlight"><pre><span></span><code><span class="c1">// 1. 定义DMA控制器和UART寄存器（简化版）</span>
<span class="cp">#define DMA_CHANNEL        0</span>
<span class="cp">#define UART_TX_REGISTER   0xFFFF0000  </span><span class="c1">// UART发送寄存器地址</span>
<span class="cp">#define DATA_SIZE          128         </span><span class="c1">// 传输数据长度</span>

<span class="c1">// 2. 分配DMA缓冲区（物理连续）</span>
<span class="kt">void</span><span class="w"> </span><span class="o">*</span><span class="n">dma_buffer</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">dma_alloc_coherent</span><span class="p">(</span><span class="n">DATA_SIZE</span><span class="p">);</span>

<span class="c1">// 3. 填充待发送数据（例如字符串）</span>
<span class="n">memcpy</span><span class="p">(</span><span class="n">dma_buffer</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;Hello DMA!&quot;</span><span class="p">,</span><span class="w"> </span><span class="mi">11</span><span class="p">);</span>

<span class="c1">// 4. 配置DMA控制器</span>
<span class="kt">void</span><span class="w"> </span><span class="nf">configure_dma</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">set_dma_channel</span><span class="p">(</span><span class="n">DMA_CHANNEL</span><span class="p">);</span><span class="w">              </span><span class="c1">// 选择DMA通道</span>
<span class="w">    </span><span class="n">set_dma_source</span><span class="p">(</span><span class="n">dma_buffer</span><span class="p">);</span><span class="w">                </span><span class="c1">// 源地址：内存缓冲区</span>
<span class="w">    </span><span class="n">set_dma_destination</span><span class="p">(</span><span class="n">UART_TX_REGISTER</span><span class="p">);</span><span class="w">     </span><span class="c1">// 目标地址：UART发送寄存器</span>
<span class="w">    </span><span class="n">set_dma_direction</span><span class="p">(</span><span class="n">MEM_TO_DEV</span><span class="p">);</span><span class="w">             </span><span class="c1">// 传输方向：内存→外设</span>
<span class="w">    </span><span class="n">set_dma_length</span><span class="p">(</span><span class="n">DATA_SIZE</span><span class="p">);</span><span class="w">                 </span><span class="c1">// 传输数据长度</span>
<span class="w">    </span><span class="n">enable_dma_interrupt</span><span class="p">(</span><span class="n">DMA_CHANNEL</span><span class="p">);</span><span class="w">         </span><span class="c1">// 使能传输完成中断</span>
<span class="p">}</span>

<span class="c1">// 5. 启动DMA传输</span>
<span class="kt">void</span><span class="w"> </span><span class="nf">start_dma</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">start_dma_transfer</span><span class="p">(</span><span class="n">DMA_CHANNEL</span><span class="p">);</span>
<span class="p">}</span>

<span class="c1">// 6. DMA传输完成中断处理函数</span>
<span class="kt">void</span><span class="w"> </span><span class="nf">dma_complete_isr</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">print</span><span class="p">(</span><span class="s">&quot;DMA传输完成！&quot;</span><span class="p">);</span>
<span class="w">    </span><span class="n">dma_free_coherent</span><span class="p">(</span><span class="n">dma_buffer</span><span class="p">);</span><span class="w">            </span><span class="c1">// 释放DMA缓冲区</span>
<span class="p">}</span>
</code></pre></div>
<ol>
<li><strong>内存分配</strong>：使用 <code>dma_alloc_coherent()</code> 确保缓冲区物理连续，DMA可直接访问。</li>
<li><strong>配置DMA</strong>：明确数据来源、去向、方向和长度，绑定到指定通道。</li>
<li><strong>启动传输</strong>：DMA控制器接管总线，自动搬运数据到UART。</li>
<li><strong>中断处理</strong>：传输完成后释放资源，或启动下一轮传输。</li>
</ol>
<blockquote>
<ul>
<li><strong>DMA的本质</strong>：通过硬件加速数据传输，减少CPU负载。</li>
<li><strong>核心步骤</strong>：分配内存 → 配置DMA → 启动传输 → 处理中断。</li>
<li><strong>适用场景</strong>：高频、大数据量传输（如UART连续通信、图形渲染）</li>
</ul>
</blockquote>
<h4 id="cache-api">cache 一致性--&gt; 不同的API 选择</h4>
<p><img alt="image-20250315212516908" src="pic/image-20250315212516908.png" /></p>
<p>具体例子？</p>
<p>所以说 cache 对软件是透明的？说一致性，在设计上的保证？迷迷糊糊。</p>
<p>比如 CPU 和视频编解码模块，有一部分数据还在 CPU 内部的 cache，而这个编解码模块又没有能力去查询 CPU cache里的话，当从给定地址去读取数据的话，只能走 DDR 那条路，还记得 总线、CPU、DDR、master 那个图吗？</p>
<p>只能从视频编解码模块的 master 到 AHB 的 master，再走到 AXI，再走到 DDRC，再走到 memory，最后读取数据，这个时候，就会存在 cache 一致性的问题。（当然如果这个模块有能力查询  CPU cache，另说）这是就会影响后续 DMA API 的选择！！！所以再回到上面那个图的最下面，如何保证一致性，都是根据之前硬件模块的设计的。（哦！这个时候就能解释为什么有些地方会莫名其妙加一些 cache maintenance 指令（ARM、RISCV的）来维护一致性）</p>
<p>（再看如果是有系统总线来维护一致性的话，CPU 直接给地址即可！！！）</p>
<blockquote>
<p>前面的，寄存器为什么要分用户态和内核态访问，这也是类似的？还是上面的视频编解码的例子，怎么尽可能地方便将视频生成的数据给用户？</p>
</blockquote>
<p>这里再通过 AI 总结一些例子，就能比较好地理解。</p>
<blockquote>
<hr />
<h3 id="_13"><strong>缓存一致性与硬件/软件协作机制</strong></h3>
<h4 id="1_3"><strong>1. 缓存一致性的核心问题</strong></h4>
<ul>
<li>
<p><strong>硬件自动维护</strong>：在<strong>一致性总线架构</strong>（如带Snooping的Cache Coherent Interconnect, CCI）中，CPU与外设（如GPU、DMA控制器）共享缓存一致性协议（如MESI）。  </p>
<ul>
<li><strong>示例</strong>：CPU和GPU均能通过总线监听（Snoop）彼此的缓存，确保数据一致性。此时，外设可直接访问CPU缓存，无需软件干预。  </li>
<li><strong>典型场景</strong>：SoC内集成的高性能计算单元（如NPU）与CPU协作时，硬件自动维护一致性。</li>
</ul>
</li>
<li>
<p><strong>软件手动维护</strong>：若外设<strong>不支持缓存一致性协议</strong>（如某些传统DMA控制器），则需软件通过<strong>缓存维护指令</strong>（如ARM的<code>DMB</code>/<code>DSB</code>、RISC-V的<code>FENCE</code>）或<strong>内存屏障</strong>显式刷新缓存。  </p>
<ul>
<li><strong>示例</strong>：视频编解码模块直接访问DDR时，若CPU缓存中存在未写回的数据，外设读取的将是旧数据，需驱动在DMA传输前调用<code>dma_sync_single_for_device()</code>刷新缓存。</li>
</ul>
</li>
</ul>
<hr />
<h4 id="2-dma-api"><strong>2. DMA API的选择与缓存一致性</strong></h4>
<p>Linux内核提供两类DMA API，其选择取决于硬件是否支持一致性：  </p>
<ol>
<li><strong>一致性DMA（Coherent DMA）</strong>  <ul>
<li>硬件支持缓存一致性（如带SMMU/IOMMU的DMA控制器），通过共享页表映射<strong>一致性内存区域</strong>。  </li>
<li><strong>API</strong>：<code>dma_alloc_coherent()</code>、<code>dma_free_coherent()</code></li>
<li><strong>企业案例</strong>：  <ul>
<li>某智能摄像头项目中，视频编码器与CPU共享一致性内存，驱动使用<code>dma_alloc_coherent()</code>分配内存，硬件自动维护一致性，无需手动刷新。</li>
</ul>
</li>
</ul>
</li>
<li><strong>流式DMA（Streaming DMA）</strong>  <ul>
<li>硬件不支持缓存一致性，需驱动在传输前后显式同步缓存。  </li>
<li><strong>API</strong>：<code>dma_map_single()</code>/<code>dma_unmap_single()</code>  </li>
<li><strong>企业案例</strong>：  <ul>
<li>某工业控制系统中，旧版DMA控制器无法感知CPU缓存，驱动在数据传输前调用<code>dma_sync_single_for_cpu()</code>确保数据可见性。</li>
</ul>
</li>
</ul>
</li>
</ol>
<hr />
<h4 id="3_1"><strong>3. 实际项目中的缓存维护操作</strong></h4>
<p>以<strong>视频编解码模块</strong>为例，若其DMA控制器无法查询CPU缓存：  </p>
<ol>
<li>
<p><strong>驱动实现步骤</strong>：  </p>
<ul>
<li>分配内存：使用<code>kzalloc()</code>或<code>vmalloc()</code>申请缓冲区。  </li>
<li>映射DMA地址：调用<code>dma_map_single()</code>将虚拟地址映射为物理地址供外设使用。  </li>
<li>启动传输前：调用<code>dma_sync_single_for_device()</code>，内部执行<code>__clean_dcache_area_poc()</code>（ARM）刷新CPU缓存到DDR。  </li>
<li>传输完成后：调用<code>dma_sync_single_for_cpu()</code>，使CPU缓存失效并从DDR重新加载数据。  </li>
</ul>
</li>
<li>
<p><strong>代码片段</strong>：  </p>
<div class="highlight"><pre><span></span><code><span class="c1">// 分配缓冲区</span>
<span class="kt">void</span><span class="w"> </span><span class="o">*</span><span class="n">buf</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">kmalloc</span><span class="p">(</span><span class="n">BUF_SIZE</span><span class="p">,</span><span class="w"> </span><span class="n">GFP_KERNEL</span><span class="p">);</span>
<span class="c1">// 映射DMA地址</span>
<span class="n">dma_addr_t</span><span class="w"> </span><span class="n">dma_handle</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">dma_map_single</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span><span class="w"> </span><span class="n">buf</span><span class="p">,</span><span class="w"> </span><span class="n">BUF_SIZE</span><span class="p">,</span><span class="w"> </span><span class="n">DMA_TO_DEVICE</span><span class="p">);</span>
<span class="c1">// 启动DMA传输前刷新缓存</span>
<span class="n">dma_sync_single_for_device</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span><span class="w"> </span><span class="n">dma_handle</span><span class="p">,</span><span class="w"> </span><span class="n">BUF_SIZE</span><span class="p">,</span><span class="w"> </span><span class="n">DMA_TO_DEVICE</span><span class="p">);</span>
<span class="c1">// 传输完成后使CPU缓存失效</span>
<span class="n">dma_sync_single_for_cpu</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span><span class="w"> </span><span class="n">dma_handle</span><span class="p">,</span><span class="w"> </span><span class="n">BUF_SIZE</span><span class="p">,</span><span class="w"> </span><span class="n">DMA_FROM_DEVICE</span><span class="p">);</span>
</code></pre></div>
</li>
</ol>
<hr />
<h4 id="4"><strong>4. 用户态与内核态访问寄存器的区别</strong></h4>
<ul>
<li><strong>权限隔离</strong>：内核态可直接访问物理寄存器和内存映射寄存器（如MMIO），而用户态需通过<code>mmap()</code>或系统调用（如<code>ioctl()</code>）间接操作，目的是<strong>防止用户程序破坏硬件状态</strong>。  </li>
<li><strong>与缓存一致性无关</strong>：寄存器访问的权限分离是安全设计，而缓存一致性是硬件/软件对内存数据的同步机制，二者属于不同维度的问题。</li>
</ul>
<hr />
<h3 id="_14"><strong>总结与建议</strong></h3>
<ol>
<li>
<p><strong>硬件设计决定软件策略</strong>：  </p>
<ul>
<li>若外设支持一致性总线（如SMMU），优先使用<code>dma_alloc_coherent()</code>，减少软件开销。  </li>
<li>若外设无一致性支持，需严格遵循DMA API的缓存同步流程。</li>
</ul>
</li>
<li>
<p><strong>企业级最佳实践</strong>：  </p>
<ul>
<li><strong>案例1</strong>：某自动驾驶视觉处理模块中，使用带SMMU的DMA控制器，驱动通过一致性API实现CPU与FPGA的高效数据交换。  </li>
<li><strong>案例2</strong>：某5G基站基带处理中，旧版DMA控制器需驱动手动调用<code>cache flush</code>，结合<code>dma_map_single()</code>确保数据正确性。</li>
</ul>
</li>
<li>
<p><strong>调试技巧</strong>：  </p>
<ul>
<li>通过<code>ftrace</code>监控DMA缓存同步函数的调用频率，优化性能瓶颈。  </li>
<li>使用<code>CONFIG_DMA_API_DEBUG</code>跟踪DMA内存泄漏问题。</li>
</ul>
</li>
</ol>
</blockquote>
<p>再有文章：<a href="https://zhuanlan.zhihu.com/p/7943091314">聊聊Linux的DMA机制 - 知乎</a></p>
<h4 id="cpu">CPU 访问内存</h4>
<ul>
<li>
<p><strong>内核内存访问：有权限，有多少你用多少</strong></p>
<blockquote>
<p>三个关键</p>
<ul>
<li>当驱动需要分配内存</li>
<li>内核内存分配 API</li>
<li><code>dev_xxx</code> 接口的意义</li>
</ul>
</blockquote>
<p>具体例子：</p>
<ul>
<li><strong>内存分配场景</strong>：
    当驱动需要分配内存时（如为设备缓冲区申请空间），内核提供以下核心API：<ul>
<li><strong><code>kmalloc</code></strong>：分配<strong>物理连续</strong>的内存块，适用于DMA或硬件寄存器访问。</li>
<li><strong><code>vmalloc</code></strong>：分配<strong>虚拟连续但物理可能不连续</strong>的内存，适用于大块内存（如驱动程序日志缓冲区）。</li>
<li><strong><code>devm_kzalloc</code></strong>：设备资源管理接口，自动释放内存，防止内存泄漏（例如：<code>devm_kzalloc(&amp;pdev-&gt;dev, size, GFP_KERNEL)</code>）。</li>
</ul>
</li>
<li><strong><code>dev_xxx</code>接口的意义</strong>：<ul>
<li><strong>资源生命周期管理</strong>：<code>devm_*</code>系列函数（如<code>devm_kzalloc</code>、<code>devm_ioremap</code>）与设备绑定，设备卸载时自动释放资源，简化驱动代码。</li>
<li><strong>示例</strong>：在摄像头驱动中，使用<code>devm_kzalloc</code>为图像缓冲区分配内存，无需手动在 <code>probe</code> 和 <code>remove</code> 函数中处理释放逻辑。</li>
</ul>
</li>
</ul>
</li>
<li>
<p><strong>用户空间访问：权限受限，可以申请，但能否实际分配内存实际由内核决定</strong></p>
<blockquote>
<p>三个关键：</p>
<ul>
<li>用户空间内存 API</li>
<li>用户空间内存分配和系统调用的关系</li>
<li>用户空间内存能不能直接给硬件用？</li>
</ul>
</blockquote>
<ul>
<li><strong>用户空间内存分配机制</strong>：<ul>
<li><strong><code>malloc</code>/<code>free</code></strong>：通过 <code>brk</code> 或 <code>mmap</code> 系统调用向内核申请虚拟内存，但实际物理内存分配是<strong>按需延迟</strong>的（Page Fault触发）。</li>
<li><strong><code>mmap</code></strong>：直接将用户空间缓冲区映射到内核或硬件设备（如DMA），需结合<code>O_SYNC</code> 或 <code>O_DIRECT</code> 标志绕过页缓存。</li>
</ul>
</li>
<li><strong>用户空间内存能否直接给硬件使用？</strong><ul>
<li><strong>直接使用限制</strong>：用户空间内存的物理地址是动态分配的，且可能被换出，硬件（如DMA控制器）通常需要<strong>固定物理地址</strong>。</li>
<li><strong>解决方案</strong>：<ol>
<li><strong>内核中转</strong>：用户程序通过<code>ioctl</code>将数据传递给内核，由内核调用<code>dma_map_single</code>映射到设备。</li>
<li><strong><code>mmap</code>到设备</strong>：通过<code>remap_pfn_range</code>将设备内存映射到用户空间（需硬件支持，如显卡显存）。</li>
</ol>
</li>
</ul>
</li>
<li><strong>视频编解码模块的实践</strong>：<ul>
<li>若模块支持一致性（如带SMMU）：用户空间缓冲区可通过<code>dma_buf</code>框架导出为DMA内存，直接供硬件使用。</li>
<li>若不支持一致性：需内核驱动调用<code>get_user_pages</code>锁定用户内存页，再通过<code>dma_map_page</code>映射到设备。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="dma_2">使用 DMA 搬移数据</h4>
<ul>
<li>
<p><strong>一种 memory 批量访问方法</strong></p>
</li>
<li>
<p><strong>DMA 快还是 CPU 快？</strong></p>
<p>一般来说，数据量小的时候：寄存器快，反之。</p>
<p>具体界限：几百K、及K，那 寄存器快；几 M 往上，DMA快。但具体还要看硬件模块的设计如何。</p>
<p>所以，不能简单地认为DMA就是搬移快，DMA主要优势是搬移量大，对大数据比较好。</p>
<p>主要关注几 K 到几百 K 的数据。</p>
<blockquote>
<p>具体做业务的时候，使用的这款芯片的 DMA 在空载/满载的时候，搬运速度是多快，具体到数量级。</p>
<p>如果有 200K 的数据，如果用 寄存器的话会占用 CPU 时间。</p>
<p>再看 DMA 能不能优化，如果单次搬移不能的话，再看看多笔能不能优化，比如一次给 4 个 200 K 的数据。</p>
<p>增加 DMA 通道的数据就能做好？</p>
</blockquote>
</li>
<li>
<p><strong>CPU 和 DMA 访问的利弊</strong></p>
<p>带宽（bandwidth）</p>
<p>时延（latency）</p>
<p>CPU 占用情况</p>
</li>
<li>
<p><strong>Linux DMA 的两种类型</strong></p>
<ul>
<li>
<p><strong>一致性DMA（Coherent DMA）</strong></p>
<ul>
<li>
<p><strong>特点</strong>：内存区域在<strong>生命周期内保持缓存一致性</strong>，硬件与CPU共享缓存协议（如SMMU/IOMMU）。</p>
</li>
<li>
<p><strong>API</strong>：<code>dma_alloc_coherent()</code></p>
</li>
<li>
<p><strong>适用场景</strong>：频繁小数据交换（如网络控制器收发描述符环）。</p>
</li>
<li>
<p><strong>代码示例</strong>：</p>
<div class="highlight"><pre><span></span><code><span class="n">dma_addr_t</span><span class="w"> </span><span class="n">dma_handle</span><span class="p">;</span><span class="w">  </span>
<span class="kt">void</span><span class="w"> </span><span class="o">*</span><span class="n">cpu_addr</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">dma_alloc_coherent</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span><span class="w"> </span><span class="n">size</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">dma_handle</span><span class="p">,</span><span class="w"> </span><span class="n">GFP_KERNEL</span><span class="p">);</span><span class="w">  </span>
</code></pre></div>
</li>
</ul>
</li>
<li>
<p><strong>流式DMA（Streaming DMA）</strong></p>
<ul>
<li>
<p><strong>特点</strong>：需显式调用<code>dma_sync_*</code>维护缓存一致性，适用于单次大数据传输（如视频帧传输）。</p>
</li>
<li>
<p><strong>API</strong>：<code>dma_map_single()</code>/<code>dma_unmap_single()</code></p>
</li>
<li>
<p><strong>适用场景</strong>：外设不支持缓存一致性（如传统DMA控制器）。</p>
</li>
<li>
<p><strong>代码示例</strong>：</p>
<div class="highlight"><pre><span></span><code><span class="n">dma_addr_t</span><span class="w"> </span><span class="n">dma_handle</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">dma_map_single</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span><span class="w"> </span><span class="n">buf</span><span class="p">,</span><span class="w"> </span><span class="n">size</span><span class="p">,</span><span class="w"> </span><span class="n">direction</span><span class="p">);</span><span class="w">  </span>
<span class="c1">// 启动DMA传输  </span>
<span class="n">dma_unmap_single</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span><span class="w"> </span><span class="n">dma_handle</span><span class="p">,</span><span class="w"> </span><span class="n">size</span><span class="p">,</span><span class="w"> </span><span class="n">direction</span><span class="p">);</span><span class="w">  </span>
</code></pre></div>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p><strong>DMA 子系统</strong></p>
<ul>
<li><strong>抽象硬件差异</strong>：通过统一API（如<code>dmaengine</code>）屏蔽不同DMA控制器的底层细节。</li>
<li><strong>内存与设备映射</strong>：管理物理地址与设备地址的转换（尤其在IOMMU存在时）。</li>
<li><strong>企业级案例</strong>：<ul>
<li><strong>案例1：视频直播设备</strong>：<ul>
<li>使用流式DMA传输视频帧，驱动在每帧传输前后调用<code>dma_sync_single_for_device</code>和<code>dma_sync_single_for_cpu</code>，确保编解码器读取最新数据。</li>
</ul>
</li>
<li><strong>案例2：高速数据采集卡</strong>：<ul>
<li>采用一致性DMA，通过<code>dma_alloc_coherent</code>分配内存，硬件自动维护缓存一致性，减少CPU干预。</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p><strong>最佳实践</strong></p>
<ol>
<li><strong>内核与用户空间协作</strong>：<ul>
<li>用户空间数据若需硬件访问，优先通过<code>mmap</code>或<code>dma_buf</code>共享内存，而非直接传递指针。</li>
<li>驱动中始终使用<code>devm_*</code>接口管理资源，避免内存泄漏。</li>
</ul>
</li>
<li><strong>DMA API选择原则</strong>：<ul>
<li>硬件支持一致性 → 一致性DMA（高效，低延迟）。</li>
<li>硬件不支持 → 流式DMA + 显式缓存维护（兼容性强）。</li>
</ul>
</li>
<li><strong>调试与优化</strong>：<ul>
<li>通过<code>dma-debug</code>工具监控DMA映射错误。</li>
<li>使用<code>perf</code>分析DMA传输延迟，优化缓存刷新频率。</li>
</ul>
</li>
</ol>
</li>
<li>
<p><strong>项目示例</strong></p>
<ul>
<li><strong>智能网卡驱动优化</strong>：某云计算厂商在DPDK中采用一致性DMA，通过<code>dma_alloc_coherent</code>分配报文缓冲区，减少缓存同步开销，提升网络吞吐量20%。</li>
<li><strong>工业相机驱动</strong>：在无IOMMU的ARM平台上，使用<code>dma_map_single</code>映射用户空间内存，结合<code>get_user_pages</code>锁定物理页，确保实时图像传输零拷贝。</li>
</ul>
</li>
<li>
<p><strong>DMA访问的 四个方向</strong></p>
</li>
</ul>
<p><img src="pic/image-20250317152939845.png" alt="image-20250317152939845" style="zoom:50%;" /></p>
<p>设备那边会有一个 FIFO？</p>
<p>设备到设备：pipeline？</p>
<ul>
<li><strong>DMA 地址组织形式1：链表</strong></li>
</ul>
<p><img src="pic/image-20250317153316385.png" alt="image-20250317153316385" style="zoom: 50%;" /></p>
<p>DMA 链表起始 key 放在寄存器访问。</p>
<p>为什么要这么设计？具体场景</p>
<ul>
<li><strong>DMA 地址组织形式2：IOMMU</strong></li>
</ul>
<p><img src="pic/image-20250317153403166.png" alt="image-20250317153403166" style="zoom:50%;" /></p>
<ul>
<li><strong>DMA  API：</strong></li>
</ul>
<p><img src="pic/image-20250317153658821.png" alt="image-20250317153658821" style="zoom:50%;" /></p>
<ul>
<li>
<p><code>dma_alloc_coherent</code></p>
</li>
<li>
<p><code>dma_pool_xxx</code></p>
<p>上面两个是一类。比如摄像头这么用？</p>
</li>
<li>
<p><code>dma_map_single</code></p>
<p>网络，发出去就用一次？</p>
</li>
</ul>
<p>都是用在什么情况下的？</p>
<p><img src="pic/image-20250317154816082.png" alt="image-20250317154816082" style="zoom: 67%;" /></p>
<h4 id="_15">内存分配</h4>
<p><code>man top</code></p>
<p><img src="pic/image-20250315215000843.png" alt="image-20250315215000843" style="zoom:50%;" /></p>
<p>用户态内存分配就上面四种情况：</p>
<p>匿名的、非匿名的：是否和具体文件关联。具体例子？</p>
<p>private/ shared：数据修改完之后，将来是否会同步到文件里（比如3象限里的，该数据是该进程私有的，将来是不打算同步回去的）</p>
<blockquote>
<p>所有能看内存的工具，只需要区分四种情况的哪一种，实际要搜的就是这四种。</p>
</blockquote>
<p><strong>小内存：<code>brk</code>；大内存：直接通过 <code>mmap</code> 申请大内存？具体的细节。</strong></p>
<p>这部分直接重新去看 jyy 老师那部分的课。</p>
<p>测试工具 <code>memtester</code></p>
<p>又听到了这个问题：<code>pagefault</code>、申请和分配两个概念。</p>
<ul>
<li>
<p><strong>Page Fault 的触发机制</strong></p>
<ol>
<li><strong>硬件触发</strong> 
    Page Fault <strong>由硬件直接触发</strong>，具体由 CPU 的内存管理单元（MMU）负责。当进程访问一个虚拟内存地址时，MMU 会检查页表：<ul>
<li>若目标页表项（PTE）标记为无效（如物理页未分配、权限不足等），MMU 会生成一个 <strong>Page Fault 异常</strong>，通知 CPU。</li>
<li>CPU 随后通过中断机制将控制权交给操作系统的 Page Fault 处理程序。</li>
</ul>
</li>
<li><strong>操作系统处理</strong> 
    操作系统通过 Page Fault 处理程序完成后续工作：<ul>
<li>检查访问是否合法（如地址是否在进程的虚拟地址空间内、权限是否匹配）。</li>
<li>若合法，分配物理页并更新页表；若非法，终止进程。</li>
</ul>
</li>
</ol>
</li>
<li>
<p><strong>内存申请与分配的区别</strong></p>
<ol>
<li><strong>申请（Reservation）</strong>  <ul>
<li>进程通过系统调用（如 <code>malloc</code>、<code>mmap</code>）申请内存时，操作系统仅修改进程的 <strong>虚拟地址空间</strong>，标记一段虚拟内存区域为“可访问”。</li>
<li>此时并未分配物理内存，仅建立虚拟地址到物理地址的映射框架（如 VMA 结构）。</li>
</ul>
</li>
<li><strong>分配（Allocation）</strong>  <ul>
<li>物理内存的分配是 <strong>按需延迟</strong> 的。当进程首次访问已申请但未映射的虚拟地址时，触发 Page Fault。</li>
<li>操作系统在 Page Fault 处理中分配物理页，并更新页表完成映射。</li>
</ul>
</li>
</ol>
<p><strong>申请 vs 分配</strong>：申请是虚拟地址空间的预留，分配是物理内存的按需映射。</p>
</li>
<li>
<p><strong>案例解析：申请 1GB 内存，实际使用 512MiB</strong></p>
<ol>
<li><strong>初始状态</strong>  <ul>
<li>进程申请 1GB 虚拟内存（如 <code>malloc(1GB)</code>），操作系统在进程的虚拟地址空间中预留 1GB 的虚拟区域，但 <strong>不分配物理内存</strong>。</li>
</ul>
</li>
<li><strong>首次访问 512MiB</strong>  <ul>
<li>进程首次读写前 512MiB 时，MMU 发现对应页表项无效，触发 Page Fault。</li>
<li>操作系统分配物理页，建立虚拟地址到物理页的映射，进程正常使用。</li>
</ul>
</li>
<li><strong>剩余 512MiB 的处理</strong>  <ul>
<li>剩余的 512MiB 虚拟内存未被访问时，操作系统不会为其分配物理页。</li>
<li>当进程访问剩余地址时，再次触发 Page Fault，操作系统动态分配物理页。</li>
</ul>
</li>
</ol>
</li>
</ul>
<blockquote>
<ul>
<li><strong>内存利用率</strong>：避免提前分配未使用的物理内存，减少资源浪费。</li>
<li><strong>灵活性</strong>：支持稀疏内存访问（如稀疏数组、动态数据结构）。</li>
<li><strong>透明性</strong>：进程无需感知物理内存分配细节，由操作系统自动管理。</li>
</ul>
</blockquote>
<p>再用 <code>perf</code> 工具</p>
<p><code>sudo perf record -e syscalls:sys_enter_mmap -e syscalls:sys_enter_brk -ag memtester 1M 1</code></p>
<p><code>sudo perf report</code>、<code>sudo perf script</code></p>
<p><img alt="image-20250315223244370" src="pic/image-20250315223244370.png" /></p>
<p>能够直接看出这个<code>memtester</code> 的 <code>mmap</code> 系统调用用了 70us？？这么nb</p>
<h3 id="_16">竞争和同步</h3>
<ul>
<li>原子操作</li>
<li>自旋锁</li>
<li>非中断上下文的同步：<code>mutex</code>、<code>rw_semephore</code></li>
</ul>
<h3 id="_17">工作方法</h3>
<h2 id="_18">第三课：中断和电源管理</h2>
<p>引导问题：为什么系统休眠后不能唤醒？</p>
<p>为什么屏幕关了，就能省电？</p>
<p>比如手机熄屏，听音乐带着耳机，拔掉耳机后，手机是一个什么状态。</p>
<h3 id="_19">中断</h3>
<blockquote>
<p>interrupt</p>
<p>exception</p>
<p>poll/polling：轮询、查询</p>
</blockquote>
<h4 id="_20">架构图</h4>
<p>异步获得硬件的事件；</p>
<p>中断是否属于异常，因架构而异。ARM架构下中断是一种异常</p>
<p><a href="https://www.cnblogs.com/arnoldlu/p/17381705.html">GIC Implementation and Architecture Specification - ArnoldLu - 博客园</a></p>
<p><img src="pic/image-20250318191620873.png" alt="image-20250318191620873" style="zoom:67%;" /></p>
<p>通过上面这个图，能否对应到之前几节课画的那个总的架构图？那现在再<strong>结合当前使用的芯片重新构建这个图</strong>！比如是结合 H616的，它的中断管理借助于 GIC-400</p>
<blockquote>
<p>实际上这个才是最重要的内容，有了对现代的 Soc 内部架构有了总体上的了解后，再结合具体 Soc 使用的模块，脑海中或者手动画出来这么一个架构图！</p>
</blockquote>
<p><img src="pic/image-20250318191940805.png" alt="image-20250318191940805" style="zoom: 80%;" /></p>
<h4 id="_21">设备树</h4>
<div class="highlight"><pre><span></span><code><span class="nt">gic</span><span class="p">:</span><span class="w"> </span><span class="l l-Scalar l-Scalar-Plain">interrupt-controller@3021000 {</span>
<span class="w">    </span><span class="l l-Scalar l-Scalar-Plain">compatible = &quot;arm,gic-400&quot;;</span>
<span class="w">    </span><span class="l l-Scalar l-Scalar-Plain">reg = &lt;0x03021000 0x1000&gt;,</span>
<span class="w">          </span><span class="l l-Scalar l-Scalar-Plain">&lt;0x03022000 0x2000&gt;,</span>
<span class="w">          </span><span class="l l-Scalar l-Scalar-Plain">&lt;0x03024000 0x2000&gt;,</span>
<span class="w">          </span><span class="l l-Scalar l-Scalar-Plain">&lt;0x03026000 0x2000&gt;;</span>
<span class="w">    </span><span class="l l-Scalar l-Scalar-Plain">interrupts = &lt;GIC_PPI 9 (GIC_CPU_MASK_SIMPLE(4) | IRQ_TYPE_LEVEL_HIGH)&gt;;</span>
<span class="w">    </span><span class="l l-Scalar l-Scalar-Plain">interrupt-controller;</span>
<span class="w">    </span><span class="l l-Scalar l-Scalar-Plain">#interrupt-cells = &lt;3&gt;;</span><span class="w">                                                                                        </span>
<span class="err">}</span><span class="l l-Scalar l-Scalar-Plain">;</span>
<span class="nn">...</span>
<span class="nt">uart0</span><span class="p">:</span><span class="w"> </span><span class="l l-Scalar l-Scalar-Plain">serial@5000000 {</span>
<span class="w">    </span><span class="l l-Scalar l-Scalar-Plain">compatible = &quot;snps,dw-apb-uart&quot;;</span>
<span class="w">    </span><span class="l l-Scalar l-Scalar-Plain">reg = &lt;0x05000000 0x400&gt;;</span>
<span class="w">    </span><span class="l l-Scalar l-Scalar-Plain">interrupts = &lt;GIC_SPI 0 IRQ_TYPE_LEVEL_HIGH&gt;;</span>
<span class="w">    </span><span class="l l-Scalar l-Scalar-Plain">reg-shift = &lt;2&gt;;</span>
<span class="w">    </span><span class="l l-Scalar l-Scalar-Plain">reg-io-width = &lt;4&gt;;</span>
<span class="w">    </span><span class="l l-Scalar l-Scalar-Plain">clocks = &lt;&amp;ccu CLK_BUS_UART0&gt;;</span>
<span class="w">    </span><span class="l l-Scalar l-Scalar-Plain">resets = &lt;&amp;ccu RST_BUS_UART0&gt;;</span>
<span class="w">    </span><span class="l l-Scalar l-Scalar-Plain">status = &quot;disabled&quot;;</span>
<span class="err">}</span><span class="l l-Scalar l-Scalar-Plain">;</span>
<span class="l l-Scalar l-Scalar-Plain">arch/arm64/boot/dts/allwinner/sun50i-h616.dtsi</span>
</code></pre></div>
<p>根据 H616 这款 Soc 写出其使用的 <strong>中断控制器</strong> 的配置，同时，这个配置就是上面那个图GIC-400的具体定义，传递给软件要使用的。</p>
<p>这个时候会有问题，为什么这款控制器配置要写这些内容？即这个中断控制器为什么要写这些配置项？换句话说，这个设备树的配置文件是怎么写出来的？</p>
<p>具体看 binding 手册：<code>Documentation/devicetree/bindings</code> 下的内容：</p>
<p><img alt="image-20250318193234033" src="pic/image-20250318193234033.png" /></p>
<p>如果我们要写一个 <code>uart</code> 的设备树内容的话，那就直接去看 <code>serial</code> 目录下的内容，配合已经厂商自己设计时使用的uart硬件模块。</p>
<p><img alt="屏幕截图 2025-03-18 214437" src="pic/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202025-03-18%20214437.png" /></p>
<p>由此查看相关配置项：</p>
<div class="highlight"><pre><span></span><code><span class="c1"># SPDX-License-Identifier: GPL-2.0</span>
<span class="nt">%YAML</span><span class="w"> </span><span class="m">1.2</span>
<span class="nn">---</span>
<span class="nt">$id</span><span class="p">:</span><span class="w"> </span><span class="l l-Scalar l-Scalar-Plain">http://devicetree.org/schemas/serial/snps-dw-apb-uart.yaml#</span>
<span class="nt">$schema</span><span class="p">:</span><span class="w"> </span><span class="l l-Scalar l-Scalar-Plain">http://devicetree.org/meta-schemas/core.yaml#</span>

<span class="nt">title</span><span class="p">:</span><span class="w"> </span><span class="l l-Scalar l-Scalar-Plain">Synopsys DesignWare ABP UART</span>

<span class="nt">maintainers</span><span class="p">:</span>
<span class="w">  </span><span class="p p-Indicator">-</span><span class="w"> </span><span class="l l-Scalar l-Scalar-Plain">Rob Herring &lt;robh@kernel.org&gt;</span>

<span class="nt">allOf</span><span class="p">:</span>
<span class="w">  </span><span class="p p-Indicator">-</span><span class="w"> </span><span class="nt">$ref</span><span class="p">:</span><span class="w"> </span><span class="l l-Scalar l-Scalar-Plain">serial.yaml#</span>
<span class="w">  </span><span class="p p-Indicator">-</span><span class="w"> </span><span class="nt">$ref</span><span class="p">:</span><span class="w"> </span><span class="l l-Scalar l-Scalar-Plain">rs485.yaml#</span>

<span class="nt">properties</span><span class="p">:</span>
<span class="w">  </span><span class="nt">compatible</span><span class="p">:</span>
<span class="w">    </span><span class="nt">oneOf</span><span class="p">:</span>
<span class="w">      </span><span class="p p-Indicator">-</span><span class="w"> </span><span class="nt">items</span><span class="p">:</span>
<span class="w">          </span><span class="p p-Indicator">-</span><span class="w"> </span><span class="nt">enum</span><span class="p">:</span>
<span class="w">              </span><span class="p p-Indicator">-</span><span class="w"> </span><span class="l l-Scalar l-Scalar-Plain">renesas,r9a06g032-uart</span>
<span class="w">              </span><span class="p p-Indicator">-</span><span class="w"> </span><span class="l l-Scalar l-Scalar-Plain">renesas,r9a06g033-uart</span>
<span class="w">          </span><span class="p p-Indicator">-</span><span class="w"> </span><span class="nt">const</span><span class="p">:</span><span class="w"> </span><span class="l l-Scalar l-Scalar-Plain">renesas,rzn1-uart</span>
<span class="w">      </span><span class="p p-Indicator">-</span><span class="w"> </span><span class="nt">items</span><span class="p">:</span>
<span class="w">          </span><span class="p p-Indicator">-</span><span class="w"> </span><span class="nt">enum</span><span class="p">:</span>
<span class="w">              </span><span class="p p-Indicator">-</span><span class="w"> </span><span class="l l-Scalar l-Scalar-Plain">rockchip,rv1126-uart</span>
<span class="w">              </span><span class="l l-Scalar l-Scalar-Plain">...</span>
<span class="w">          </span><span class="p p-Indicator">-</span><span class="w"> </span><span class="nt">const</span><span class="p">:</span><span class="w"> </span><span class="l l-Scalar l-Scalar-Plain">snps,dw-apb-uart</span>
<span class="w">      </span><span class="p p-Indicator">-</span><span class="w"> </span><span class="nt">items</span><span class="p">:</span>
<span class="w">          </span><span class="p p-Indicator">-</span><span class="w"> </span><span class="nt">enum</span><span class="p">:</span>
<span class="w">              </span><span class="p p-Indicator">-</span><span class="w"> </span><span class="l l-Scalar l-Scalar-Plain">brcm,bcm11351-dw-apb-uart</span>
<span class="w">              </span><span class="p p-Indicator">-</span><span class="w"> </span><span class="l l-Scalar l-Scalar-Plain">brcm,bcm21664-dw-apb-uart</span>
<span class="w">          </span><span class="p p-Indicator">-</span><span class="w"> </span><span class="nt">const</span><span class="p">:</span><span class="w"> </span><span class="l l-Scalar l-Scalar-Plain">snps,dw-apb-uart</span>
<span class="w">      </span><span class="p p-Indicator">-</span><span class="w"> </span><span class="nt">items</span><span class="p">:</span>
<span class="w">          </span><span class="p p-Indicator">-</span><span class="w"> </span><span class="nt">enum</span><span class="p">:</span>
<span class="w">              </span><span class="p p-Indicator">-</span><span class="w"> </span><span class="l l-Scalar l-Scalar-Plain">starfive,jh7100-hsuart</span>
<span class="w">              </span><span class="p p-Indicator">-</span><span class="w"> </span><span class="l l-Scalar l-Scalar-Plain">starfive,jh7100-uart</span>
<span class="w">          </span><span class="p p-Indicator">-</span><span class="w"> </span><span class="nt">const</span><span class="p">:</span><span class="w"> </span><span class="l l-Scalar l-Scalar-Plain">snps,dw-apb-uart</span>
<span class="w">      </span><span class="p p-Indicator">-</span><span class="w"> </span><span class="nt">const</span><span class="p">:</span><span class="w"> </span><span class="l l-Scalar l-Scalar-Plain">snps,dw-apb-uart</span>

<span class="w">  </span><span class="nt">reg</span><span class="p">:</span>
<span class="w">    </span><span class="nt">maxItems</span><span class="p">:</span><span class="w"> </span><span class="l l-Scalar l-Scalar-Plain">1</span>

<span class="w">  </span><span class="nt">interrupts</span><span class="p">:</span>
<span class="w">    </span><span class="nt">maxItems</span><span class="p">:</span><span class="w"> </span><span class="l l-Scalar l-Scalar-Plain">1</span>

<span class="w">  </span><span class="nt">clock-frequency</span><span class="p">:</span><span class="w"> </span><span class="l l-Scalar l-Scalar-Plain">true</span>

<span class="w">  </span><span class="nt">clocks</span><span class="p">:</span>
<span class="w">    </span><span class="nt">minItems</span><span class="p">:</span><span class="w"> </span><span class="l l-Scalar l-Scalar-Plain">1</span>
<span class="w">    </span><span class="nt">maxItems</span><span class="p">:</span><span class="w"> </span><span class="l l-Scalar l-Scalar-Plain">2</span>

<span class="w">  </span><span class="nt">clock-names</span><span class="p">:</span>
<span class="w">    </span><span class="nt">items</span><span class="p">:</span>
<span class="w">      </span><span class="p p-Indicator">-</span><span class="w"> </span><span class="nt">const</span><span class="p">:</span><span class="w"> </span><span class="l l-Scalar l-Scalar-Plain">baudclk</span>
<span class="w">      </span><span class="p p-Indicator">-</span><span class="w"> </span><span class="nt">const</span><span class="p">:</span><span class="w"> </span><span class="l l-Scalar l-Scalar-Plain">apb_pclk</span>

<span class="w">  </span><span class="nt">dmas</span><span class="p">:</span>
<span class="w">    </span><span class="nt">maxItems</span><span class="p">:</span><span class="w"> </span><span class="l l-Scalar l-Scalar-Plain">2</span>

<span class="w">  </span><span class="nt">dma-names</span><span class="p">:</span>
<span class="w">    </span><span class="nt">items</span><span class="p">:</span>
<span class="w">      </span><span class="p p-Indicator">-</span><span class="w"> </span><span class="nt">const</span><span class="p">:</span><span class="w"> </span><span class="l l-Scalar l-Scalar-Plain">tx</span>
<span class="w">      </span><span class="p p-Indicator">-</span><span class="w"> </span><span class="nt">const</span><span class="p">:</span><span class="w"> </span><span class="l l-Scalar l-Scalar-Plain">rx</span>

<span class="w">  </span><span class="l l-Scalar l-Scalar-Plain">snps,uart-16550-compatible</span><span class="p p-Indicator">:</span>
<span class="w">    </span><span class="nt">description</span><span class="p">:</span><span class="w"> </span><span class="l l-Scalar l-Scalar-Plain">reflects the value of UART_16550_COMPATIBLE configuration</span>
<span class="w">      </span><span class="l l-Scalar l-Scalar-Plain">parameter. Define this if your UART does not implement the busy functionality.</span>
<span class="w">    </span><span class="nt">type</span><span class="p">:</span><span class="w"> </span><span class="l l-Scalar l-Scalar-Plain">boolean</span>

<span class="w">  </span><span class="nt">resets</span><span class="p">:</span>
<span class="w">    </span><span class="nt">maxItems</span><span class="p">:</span><span class="w"> </span><span class="l l-Scalar l-Scalar-Plain">1</span>

<span class="w">  </span><span class="nt">reg-shift</span><span class="p">:</span><span class="w"> </span><span class="l l-Scalar l-Scalar-Plain">true</span>

<span class="w">  </span><span class="nt">reg-io-width</span><span class="p">:</span><span class="w"> </span><span class="l l-Scalar l-Scalar-Plain">true</span>

<span class="w">  </span><span class="nt">dcd-override</span><span class="p">:</span>
<span class="w">    </span><span class="nt">description</span><span class="p">:</span><span class="w"> </span><span class="l l-Scalar l-Scalar-Plain">Override the DCD modem status signal. This signal will</span>
<span class="w">      </span><span class="l l-Scalar l-Scalar-Plain">always be reported as active instead of being obtained from the modem</span>
<span class="w">      </span><span class="l l-Scalar l-Scalar-Plain">status register. Define this if your serial port does not use this</span>
<span class="w">      </span><span class="l l-Scalar l-Scalar-Plain">pin.</span>
<span class="w">    </span><span class="nt">type</span><span class="p">:</span><span class="w"> </span><span class="l l-Scalar l-Scalar-Plain">boolean</span>

<span class="w">  </span><span class="nt">dsr-override</span><span class="p">:</span>
<span class="w">    </span><span class="nt">description</span><span class="p">:</span><span class="w"> </span><span class="l l-Scalar l-Scalar-Plain">Override the DTS modem status signal. This signal will</span>
<span class="w">      </span><span class="l l-Scalar l-Scalar-Plain">always be reported as active instead of being obtained from the modem</span>
<span class="w">      </span><span class="l l-Scalar l-Scalar-Plain">status register. Define this if your serial port does not use this</span>
<span class="w">      </span><span class="l l-Scalar l-Scalar-Plain">pin.</span>
<span class="w">    </span><span class="nt">type</span><span class="p">:</span><span class="w"> </span><span class="l l-Scalar l-Scalar-Plain">boolean</span>

<span class="w">  </span><span class="nt">cts-override</span><span class="p">:</span>
<span class="w">    </span><span class="nt">description</span><span class="p">:</span><span class="w"> </span><span class="l l-Scalar l-Scalar-Plain">Override the CTS modem status signal. This signal will</span>
<span class="w">      </span><span class="l l-Scalar l-Scalar-Plain">always be reported as active instead of being obtained from the modem</span>
<span class="w">      </span><span class="l l-Scalar l-Scalar-Plain">status register. Define this if your serial port does not use this</span>
<span class="w">      </span><span class="l l-Scalar l-Scalar-Plain">pin.</span>
<span class="w">    </span><span class="nt">type</span><span class="p">:</span><span class="w"> </span><span class="l l-Scalar l-Scalar-Plain">boolean</span>

<span class="w">  </span><span class="nt">ri-override</span><span class="p">:</span>
<span class="w">    </span><span class="nt">description</span><span class="p">:</span><span class="w"> </span><span class="l l-Scalar l-Scalar-Plain">Override the RI modem status signal. This signal will always</span>
<span class="w">      </span><span class="l l-Scalar l-Scalar-Plain">be reported as inactive instead of being obtained from the modem status</span>
<span class="w">      </span><span class="l l-Scalar l-Scalar-Plain">register. Define this if your serial port does not use this pin.</span>
<span class="w">    </span><span class="nt">type</span><span class="p">:</span><span class="w"> </span><span class="l l-Scalar l-Scalar-Plain">boolean</span>

<span class="nt">required</span><span class="p">:</span>
<span class="w">  </span><span class="p p-Indicator">-</span><span class="w"> </span><span class="l l-Scalar l-Scalar-Plain">compatible</span>
<span class="w">  </span><span class="p p-Indicator">-</span><span class="w"> </span><span class="l l-Scalar l-Scalar-Plain">reg</span>

<span class="nt">unevaluatedProperties</span><span class="p">:</span><span class="w"> </span><span class="l l-Scalar l-Scalar-Plain">false</span>

<span class="nt">examples</span><span class="p">:</span>
<span class="w">  </span><span class="p p-Indicator">-</span><span class="w"> </span><span class="p p-Indicator">|</span>
<span class="w">    </span><span class="no">serial@80230000 {</span>
<span class="w">      </span><span class="no">compatible = &quot;snps,dw-apb-uart&quot;;</span>
<span class="w">      </span><span class="no">reg = &lt;0x80230000 0x100&gt;;</span>
<span class="w">      </span><span class="no">clock-frequency = &lt;3686400&gt;;</span>
<span class="w">      </span><span class="no">interrupts = &lt;10&gt;;</span>
<span class="w">      </span><span class="no">reg-shift = &lt;2&gt;;</span>
<span class="w">      </span><span class="no">reg-io-width = &lt;4&gt;;</span>
<span class="w">      </span><span class="no">dcd-override;</span>
<span class="w">      </span><span class="no">dsr-override;</span>
<span class="w">      </span><span class="no">cts-override;</span>
<span class="w">      </span><span class="no">ri-override;</span>
<span class="w">    </span><span class="no">};</span>

<span class="w">  </span><span class="p p-Indicator">-</span><span class="w"> </span><span class="p p-Indicator">|</span>
<span class="w">    </span><span class="no">// Example with one clock:</span>
<span class="w">    </span><span class="no">serial@80230000 {</span>
<span class="w">      </span><span class="no">compatible = &quot;snps,dw-apb-uart&quot;;</span>
<span class="w">      </span><span class="no">reg = &lt;0x80230000 0x100&gt;;</span>
<span class="w">      </span><span class="no">clocks = &lt;&amp;baudclk&gt;;</span>
<span class="w">      </span><span class="no">interrupts = &lt;10&gt;;</span>
<span class="w">      </span><span class="no">reg-shift = &lt;2&gt;;</span>
<span class="w">      </span><span class="no">reg-io-width = &lt;4&gt;;</span>
<span class="w">    </span><span class="no">};</span>

<span class="w">  </span><span class="p p-Indicator">-</span><span class="w"> </span><span class="p p-Indicator">|</span>
<span class="w">    </span><span class="no">// Example with two clocks:</span>
<span class="w">    </span><span class="no">serial@80230000 {</span>
<span class="w">      </span><span class="no">compatible = &quot;snps,dw-apb-uart&quot;;</span>
<span class="w">      </span><span class="no">reg = &lt;0x80230000 0x100&gt;;</span>
<span class="w">      </span><span class="no">clocks = &lt;&amp;baudclk&gt;, &lt;&amp;apb_pclk&gt;;</span>
<span class="w">      </span><span class="no">clock-names = &quot;baudclk&quot;, &quot;apb_pclk&quot;;</span>
<span class="w">      </span><span class="no">interrupts = &lt;10&gt;;</span>
<span class="w">      </span><span class="no">reg-shift = &lt;2&gt;;</span>
<span class="w">      </span><span class="no">reg-io-width = &lt;4&gt;;</span>
<span class="w">    </span><span class="no">};</span>
<span class="nn">...</span>
</code></pre></div>
<p>由此可知，写设备树节点的时候，直接写 <code>properties</code> 各个子项就可以了，其中 <code>required</code> 属于必填选项，其他内容按需填写。不过注意，出了一些通用的设备树节点语法，各个硬件模块应该都会有相关独特的设备树节点语法，具体要查看相关硬件模块的 binding 文件，当然，直接有例子可以参考！</p>
<p><strong><mark>TODO</mark></strong>：总结便携设备树（节点）的流程。</p>
<h4 id="gic-400">GIC-400 配置</h4>
<p>回到中断相关设备树的配置：</p>
<div class="highlight"><pre><span></span><code><span class="nt">gic</span><span class="p">:</span><span class="w"> </span><span class="l l-Scalar l-Scalar-Plain">interrupt-controller@3021000 {</span>
<span class="w">    </span><span class="l l-Scalar l-Scalar-Plain">compatible = &quot;arm,gic-400&quot;;</span>
<span class="w">    </span><span class="l l-Scalar l-Scalar-Plain">reg = &lt;0x03021000 0x1000&gt;,</span>
<span class="w">          </span><span class="l l-Scalar l-Scalar-Plain">&lt;0x03022000 0x2000&gt;,</span>
<span class="w">          </span><span class="l l-Scalar l-Scalar-Plain">&lt;0x03024000 0x2000&gt;,</span>
<span class="w">          </span><span class="l l-Scalar l-Scalar-Plain">&lt;0x03026000 0x2000&gt;;</span>
<span class="w">    </span><span class="l l-Scalar l-Scalar-Plain">interrupts = &lt;GIC_PPI 9 (GIC_CPU_MASK_SIMPLE(4) | IRQ_TYPE_LEVEL_HIGH)&gt;;</span>
<span class="w">    </span><span class="l l-Scalar l-Scalar-Plain">interrupt-controller;</span>
<span class="w">    </span><span class="l l-Scalar l-Scalar-Plain">#interrupt-cells = &lt;3&gt;;</span><span class="w">                                                                                        </span>
<span class="err">}</span><span class="l l-Scalar l-Scalar-Plain">;</span>
<span class="nn">...</span>
<span class="nt">uart0</span><span class="p">:</span><span class="w"> </span><span class="l l-Scalar l-Scalar-Plain">serial@5000000 {</span>
<span class="w">    </span><span class="l l-Scalar l-Scalar-Plain">compatible = &quot;snps,dw-apb-uart&quot;;</span>
<span class="w">    </span><span class="l l-Scalar l-Scalar-Plain">reg = &lt;0x05000000 0x400&gt;;</span>
<span class="w">    </span><span class="l l-Scalar l-Scalar-Plain">interrupts = &lt;GIC_SPI 0 IRQ_TYPE_LEVEL_HIGH&gt;;</span>
<span class="w">    </span><span class="l l-Scalar l-Scalar-Plain">reg-shift = &lt;2&gt;;</span>
<span class="w">    </span><span class="l l-Scalar l-Scalar-Plain">reg-io-width = &lt;4&gt;;</span>
<span class="w">    </span><span class="l l-Scalar l-Scalar-Plain">clocks = &lt;&amp;ccu CLK_BUS_UART0&gt;;</span>
<span class="w">    </span><span class="l l-Scalar l-Scalar-Plain">resets = &lt;&amp;ccu RST_BUS_UART0&gt;;</span>
<span class="w">    </span><span class="l l-Scalar l-Scalar-Plain">status = &quot;disabled&quot;;</span>
<span class="err">}</span><span class="l l-Scalar l-Scalar-Plain">;</span>
<span class="l l-Scalar l-Scalar-Plain">arch/arm64/boot/dts/allwinner/sun50i-h616.dtsi</span>
</code></pre></div>
<p>为什么 UART 中断这里配的是 <code>GIC_SPI 0 IRQ_TYPE_LEVEL_HIGH</code> 呢？看手册只知道中断号是32呀？为什么？</p>
<p><img src="pic/image-20250318223952264.png" alt="image-20250318223952264" style="zoom:67%;" /></p>
<p>再想想，既然这个这是 H616 的中断控制器，通过学校课开的上位词/下位词/平级词来去想想，去找找资料，这个中断控制器是GIC-v2的，那不如看看 GIC-v2 的 spec？《ARM® Generic Interrupt Controller Architecture version 2.0 Architecture Specification》</p>
<p>还真找到了！</p>
<p><img src="pic/屏幕截图 2025-03-18 224328.png" alt="屏幕截图 2025-03-18 224328" style="zoom:67%;" /></p>
<p>对于 GIC-v2 的中断分发是有特定编号的，所以32是 SPIs 的开始，那自然也就是 <code>GIC_SPI</code> 的 第 0 个中断了。</p>
<p>由此，设备树里获得了中断编号后，就能去内核里进行注册。</p>
<blockquote>
<p><strong><mark>补充知识</mark></strong></p>
<p>GIC 划分的中断类型。</p>
</blockquote>
<h4 id="_22">中断全流程</h4>
<div class="highlight"><pre><span></span><code>flowchart LR
    Bootloader --&gt; KernelEarlyInit[内核早期初始化]
    KernelEarlyInit --&gt; MemoryInit[内存/页表初始化]
    MemoryInit --&gt; GICInit[GIC初始化]
    GICInit --&gt; DeviceTreeParse[设备树解析]
    DeviceTreeParse --&gt; DeviceProbe[设备探测]
    DeviceProbe --&gt; InterruptReg[中断注册]
    InterruptReg --&gt; ISRExecution[中断触发执行ISR]
</code></pre></div>
<p>这里只关注中断部分的内容，还是以 GIC-400 为例。硬件模块中断连线连到 GIC，GIC 乃至之后的内容怎么初始化？</p>
<p><img alt="image-20250318225509317" src="pic/image-20250318225509317.png" /></p>
<p>这么一个总图。</p>
<h4 id="1-gic-400">1. GIC-400 初始化</h4>
<ul>
<li>
<p><strong>代码路径</strong>：<code>drivers/irqchip/irq-gic.c</code></p>
</li>
<li>
<p><strong>函数调用链</strong>：</p>
<div class="highlight"><pre><span></span><code><span class="n">start_kernel</span><span class="p">()</span><span class="w">  </span>
<span class="w">  </span><span class="err">→</span><span class="w"> </span><span class="n">init_IRQ</span><span class="p">()</span><span class="w">  </span>
<span class="w">    </span><span class="err">→</span><span class="w"> </span><span class="n">irqchip_init</span><span class="p">()</span><span class="w">  </span>
<span class="w">      </span><span class="err">→</span><span class="w"> </span><span class="n">of_irq_init</span><span class="p">()</span><span class="w">  </span><span class="c1">// 解析设备树中的中断控制器节点</span>
<span class="w">        </span><span class="err">→</span><span class="w"> </span><span class="n">gic_of_init</span><span class="p">()</span><span class="w">  </span><span class="c1">// 初始化GIC</span>
</code></pre></div>
</li>
</ul>
<p><strong>(1) <code>__gic_init_bases</code> 函数</strong></p>
<ul>
<li>
<p><strong>功能</strong>：初始化 GIC 控制器的基础设施，包括 CPU 接口映射和全局中断处理函数注册。</p>
</li>
<li>
<p><strong>代码逻辑</strong>：</p>
<div class="highlight"><pre><span></span><code><span class="k">static</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">__init</span><span class="w"> </span><span class="nf">__gic_init_bases</span><span class="p">(</span><span class="k">struct</span><span class="w"> </span><span class="nc">gic_chip_data</span><span class="w"> </span><span class="o">*</span><span class="n">gic</span><span class="p">,</span><span class="w"> </span><span class="k">struct</span><span class="w"> </span><span class="nc">fwnode_handle</span><span class="w"> </span><span class="o">*</span><span class="n">handle</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="c1">// 初始化 CPU 接口映射表，标记所有 CPU 接口为未初始化状态（0xff）</span>
<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">NR_GIC_CPU_IF</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">++</span><span class="p">)</span>
<span class="w">        </span><span class="n">gic_cpu_map</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mh">0xff</span><span class="p">;</span>

<span class="w">    </span><span class="c1">// 注册全局中断处理函数，所有中断最终由 gic_handle_irq 分发</span>
<span class="w">    </span><span class="n">set_handle_irq</span><span class="p">(</span><span class="n">gic_handle_irq</span><span class="p">);</span>

<span class="w">    </span><span class="c1">// 调用底层初始化函数</span>
<span class="w">    </span><span class="n">ret</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">gic_init_bases</span><span class="p">(</span><span class="n">gic</span><span class="p">,</span><span class="w"> </span><span class="n">handle</span><span class="p">);</span>

<span class="w">    </span><span class="c1">// 多核相关初始化（如 IPI 中断配置）</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">gic</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="o">&amp;</span><span class="n">gic_data</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
<span class="w">        </span><span class="n">gic_smp_init</span><span class="p">();</span>
<span class="p">}</span>
</code></pre></div>
</li>
<li>
<p><strong>关键操作</strong>：</p>
<ul>
<li><strong>CPU 接口映射</strong>：初始化 CPU 核心与 GIC 接口的映射关系，后续由每个 CPU 核心探测其 ID。</li>
<li><strong>全局中断处理函数</strong>：<code>gic_handle_irq</code> 是 GIC 的中断入口，负责读取中断号并调用设备注册的 ISR。</li>
</ul>
</li>
</ul>
<blockquote>
<p>因为 GIC 也是一个设备啊，所以他也会有一般设备该有的东西呀，比如说 GIC 的中断！别搞混了！</p>
</blockquote>
<p><strong>(2) <code>gic_init_bases</code> 函数</strong></p>
<ul>
<li>
<p><strong>功能</strong>：配置 GIC 的 <code>Distributor</code> 和 <code>CPU Interface</code> 寄存器，初始化中断域（<code>irq_domain</code>）。</p>
</li>
<li>
<p><strong>代码逻辑</strong></p>
<div class="highlight"><pre><span></span><code><span class="k">static</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="nf">gic_init_bases</span><span class="p">(</span><span class="k">struct</span><span class="w"> </span><span class="nc">gic_chip_data</span><span class="w"> </span><span class="o">*</span><span class="n">gic</span><span class="p">,</span><span class="w"> </span><span class="k">struct</span><span class="w"> </span><span class="nc">fwnode_handle</span><span class="w"> </span><span class="o">*</span><span class="n">handle</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="c1">// 映射 GIC Distributor 和 CPU Interface 的物理地址到虚拟地址</span>
<span class="w">    </span><span class="n">gic</span><span class="o">-&gt;</span><span class="n">raw_dist_base</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">ioremap</span><span class="p">(</span><span class="n">res</span><span class="p">.</span><span class="n">start</span><span class="p">,</span><span class="w"> </span><span class="n">resource_size</span><span class="p">(</span><span class="o">&amp;</span><span class="n">res</span><span class="p">));</span>
<span class="w">    </span><span class="n">gic</span><span class="o">-&gt;</span><span class="n">raw_cpu_base</span><span class="w">  </span><span class="o">=</span><span class="w"> </span><span class="n">ioremap</span><span class="p">(</span><span class="n">res2</span><span class="p">.</span><span class="n">start</span><span class="p">,</span><span class="w"> </span><span class="n">resource_size</span><span class="p">(</span><span class="o">&amp;</span><span class="n">res2</span><span class="p">));</span>

<span class="w">    </span><span class="c1">// 为每个 CPU 核心设置独立的 Distributor 和 CPU 接口基地址（支持多核）</span>
<span class="w">    </span><span class="n">for_each_possible_cpu</span><span class="p">(</span><span class="n">cpu</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">u32</span><span class="w"> </span><span class="n">mpidr</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">cpu_logical_map</span><span class="p">(</span><span class="n">cpu</span><span class="p">);</span>
<span class="w">        </span><span class="n">u32</span><span class="w"> </span><span class="n">core_id</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">MPIDR_AFFINITY_LEVEL</span><span class="p">(</span><span class="n">mpidr</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">);</span>
<span class="w">        </span><span class="o">*</span><span class="n">per_cpu_ptr</span><span class="p">(</span><span class="n">gic</span><span class="o">-&gt;</span><span class="n">dist_base</span><span class="p">.</span><span class="n">percpu_base</span><span class="p">,</span><span class="w"> </span><span class="n">cpu</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">gic</span><span class="o">-&gt;</span><span class="n">raw_dist_base</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">offset</span><span class="p">;</span>
<span class="w">        </span><span class="o">*</span><span class="n">per_cpu_ptr</span><span class="p">(</span><span class="n">gic</span><span class="o">-&gt;</span><span class="n">cpu_base</span><span class="p">.</span><span class="n">percpu_base</span><span class="p">,</span><span class="w"> </span><span class="n">cpu</span><span class="p">)</span><span class="w">  </span><span class="o">=</span><span class="w"> </span><span class="n">gic</span><span class="o">-&gt;</span><span class="n">raw_cpu_base</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">offset</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="c1">// 创建 irq_domain，管理物理中断号到 Linux IRQ 号的映射</span>
<span class="w">    </span><span class="n">gic</span><span class="o">-&gt;</span><span class="n">domain</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">irq_domain_create_linear</span><span class="p">(</span><span class="n">handle</span><span class="p">,</span><span class="w"> </span><span class="n">gic_irqs</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">gic_irq_domain_ops</span><span class="p">,</span><span class="w"> </span><span class="n">gic</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div>
</li>
<li>
<p><strong>关键操作</strong>：</p>
<ul>
<li><strong>地址映射</strong>：将 GIC 的硬件寄存器映射到内核虚拟地址空间。</li>
<li><strong>多核支持</strong>：为每个 CPU 核心分配独立的基地址，支持 SMP 系统中的并行中断处理。</li>
<li><strong>中断域（irq_domain）</strong>：创建线性映射表，将硬件中断号（HW IRQ）转换为 Linux 逻辑中断号（Virq）。</li>
</ul>
</li>
</ul>
<p><strong>(3) <code>irq_domain</code> 的设计</strong></p>
<p>注册完 GIC 实际上还是不够的，因为 Soc 上的中断是很多的！<strong>可能连续可能不连续？可能还有依赖树状关系！</strong></p>
<p>因此 Linux 内核为了抽象不同的中断组织形式（连续编号的、不连续的、还是一级/多级的中断控制器），内核增加了一个 <code>irq_domain</code> 的概念（还有一个 <code>irq_domain_latency</code> 不考虑）。<code>irq_domain</code> 是 Linux 内核为统一管理不同中断控制器拓扑结构引入的抽象层，具体两个场景：</p>
<table>
<thead>
<tr>
<th style="text-align: left;"><strong>场景</strong></th>
<th style="text-align: left;"><strong>解决方案</strong></th>
<th style="text-align: left;"><strong>适用控制器</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: left;"><strong>连续中断号</strong></td>
<td style="text-align: left;"><code>irq_domain_create_linear</code></td>
<td style="text-align: left;">GICv2（固定连续中断号）</td>
</tr>
<tr>
<td style="text-align: left;"><strong>稀疏/树状中断号</strong></td>
<td style="text-align: left;"><code>irq_domain_create_tree</code></td>
<td style="text-align: left;">GICv3/v4（支持多级中断控制器）</td>
</tr>
</tbody>
</table>
<ul>
<li><strong>核心功能</strong>：<ul>
<li><strong>映射管理</strong>：维护硬件中断号（HW IRQ）到 Linux 逻辑中断号（Virq）的映射关系。</li>
<li><strong>中断控制器抽象</strong>：支持不同中断控制器的拓扑结构（单级、多级、树形）。</li>
</ul>
</li>
</ul>
<blockquote>
<ul>
<li><strong>分层抽象</strong>：
    GIC 提供硬件中断管理基础设施，<code>irq_domain</code> 抽象中断号映射，设备驱动仅关注业务逻辑。</li>
<li><strong>性能优化</strong>：<ul>
<li><strong>多核分离</strong>：每个 CPU 核心独立的寄存器基地址，避免锁竞争。</li>
<li><strong>快速路径</strong>：<code>gic_handle_irq</code> 仅处理中断号转换，不涉及具体设备逻辑。</li>
</ul>
</li>
<li><strong>扩展性</strong>：
    <code>irq_domain</code> 支持多种中断控制器拓扑，适应不同 SoC 设计（如级联 GIC 或树形结构）。</li>
</ul>
</blockquote>
<p><strong>不管是哪个 中断控制器，具体都要做的事情：1. 注册中断处理函数。2. 建立物理实际中断编号和内核中断编号的映射/基础设施。</strong></p>
<p>由此之后再做设备初始化。这里配一个图，下面再看设备初始化。</p>
<div class="highlight"><pre><span></span><code>flowchart TD
    A[内核启动] --&gt; B[GIC 初始化]
    B --&gt; C[__gic_init_bases]
    C --&gt; D[设置 CPU 接口映射]
    C --&gt; E[注册 gic_handle_irq]
    C --&gt; F[调用 gic_init_bases]
    F --&gt; G[映射硬件寄存器]
    F --&gt; H[创建 irq_domain]
    F --&gt; I[配置多核基地址]
    A --&gt; J[设备驱动初始化]
    J --&gt; K[设备硬件配置]
    J --&gt; L[request_irq 注册 ISR]
    E --&gt; M[中断触发]
    L --&gt; M
    M --&gt; N[gic_handle_irq 分发]
    N --&gt; O[调用设备 ISR]
</code></pre></div>
<h4 id="2-univ8250_console_init">2. 设备初始化：<code>univ8250_console_init</code></h4>
<p>这里还在学习 8250 和 dw8250 层次关系。先看一部分，有点问题。<strong><mark>TODO</mark></strong></p>
<div class="highlight"><pre><span></span><code>flowchart TD
    A[内核启动] --&gt; B[基础框架初始化]
    B --&gt; B1[内存管理/页表初始化]
    B --&gt; B2[GIC初始化]
    B --&gt; B3[标准8250框架初始化]

    B3 --&gt; C1[注册核心uart_ops]
    B3 --&gt; C2[注册串口驱动serial8250_reg]

    A --&gt; D[设备树解析]
    D --&gt; E[匹配设备节点与驱动]

    E --&gt; F[8250_dw驱动注册]
    F --&gt; F1[platform_driver注册]
    F1 --&gt; F2[dw8250_probe触发]

    F2 --&gt; G1[解析设备树资源]
    G1 --&gt; G2[映射寄存器]
    G2 --&gt; G3[配置uart_8250_port]
    G3 --&gt; G4[注册端口到标准框架]

    B3 --&gt; H1[传统ISA设备初始化]
    H1 --&gt; H2[硬编码参数配置]
    H2 --&gt; H3[调用univ8250_console_init]

    G4 --&gt; I1[控制台自动关联]
    I1 --&gt; I2[通过命令行/设备树配置]
</code></pre></div>
<div class="highlight"><pre><span></span><code><span class="k">static</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="k">struct</span><span class="w"> </span><span class="nc">of_device_id</span><span class="w"> </span><span class="n">dw8250_of_match</span><span class="p">[]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="p">{</span><span class="w"> </span><span class="p">.</span><span class="n">compatible</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">&quot;snps,dw-apb-uart&quot;</span><span class="p">,</span><span class="w"> </span><span class="p">.</span><span class="n">data</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">&amp;</span><span class="n">dw8250_dw_apb</span><span class="w"> </span><span class="p">},</span>
<span class="w">    </span><span class="p">{</span><span class="w"> </span><span class="p">.</span><span class="n">compatible</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">&quot;cavium,octeon-3860-uart&quot;</span><span class="p">,</span><span class="w"> </span><span class="p">.</span><span class="n">data</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">&amp;</span><span class="n">dw8250_octeon_3860_data</span><span class="w"> </span><span class="p">},</span>
<span class="w">    </span><span class="p">{</span><span class="w"> </span><span class="p">.</span><span class="n">compatible</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">&quot;marvell,armada-38x-uart&quot;</span><span class="p">,</span><span class="w"> </span><span class="p">.</span><span class="n">data</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">&amp;</span><span class="n">dw8250_armada_38x_data</span><span class="w"> </span><span class="p">},</span>
<span class="w">    </span><span class="p">{</span><span class="w"> </span><span class="p">.</span><span class="n">compatible</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">&quot;renesas,rzn1-uart&quot;</span><span class="p">,</span><span class="w"> </span><span class="p">.</span><span class="n">data</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">&amp;</span><span class="n">dw8250_renesas_rzn1_data</span><span class="w"> </span><span class="p">},</span>
<span class="w">    </span><span class="p">{</span><span class="w"> </span><span class="p">.</span><span class="n">compatible</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">&quot;starfive,jh7100-uart&quot;</span><span class="p">,</span><span class="w"> </span><span class="p">.</span><span class="n">data</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">&amp;</span><span class="n">dw8250_starfive_jh7100_data</span><span class="w"> </span><span class="p">},</span>
<span class="w">    </span><span class="p">{</span><span class="w"> </span><span class="cm">/* Sentinel */</span><span class="w"> </span><span class="p">}</span>
<span class="p">};</span>

<span class="c1">// drivers/tty/serial/8250/8250_dw.c</span>
</code></pre></div>
<ol>
<li>
<p><code>univ8250_console_init</code></p>
<p>首先注册号这个设备的相关操作，发送数据、接收数据、各个状态：operations。</p>
</li>
<li>
<p>h616 串口 probe</p>
<p>然后就可以注册我这个 Soc 上的串口了。probe再说。<code>requset_irq</code></p>
<p>具体从设备树中获得中断物理号，上面那个 <code>GIC_SPI 0</code>，结合这个 Soc 的物理中断号就是 32。</p>
</li>
</ol>
<blockquote>
<p>正常来说，如果不是 uart 的话，这里还会做一个事情，将物理中断号和逻辑中断号对应起来，然后用这个逻辑中断号去注册中断函数。</p>
<p>但由于串口比较特殊，因为串口的上一层是 <code>tty</code>，由于 <code>tty</code> 比较老，现在已经没有这种设备，<strong>所以 <code>tty</code> 下的设备具体是能够按照 <code>tty</code> 的形式操作的设备，比如 <code>console</code>、<code>pts</code>。</strong></p>
<p>为了将 <code>tty</code> 和 串口 两个驱动区分开，在 串口初始化的时候，中断实际还没有注册的，真正 <code>tty</code> 要使用才注册。</p>
</blockquote>
<p><img alt="image-20250318232137311" src="pic/image-20250318232137311.png" /></p>
<p>注册信息</p>
<p><img alt="image-20250319103423479" src="pic/image-20250319103423479.png" /></p>
<blockquote>
<p>还有一个问题，那究竟什么时候注册中断呢？</p>
<p>在用户空间第一次打开这个 <code>tty</code> 设备，具体中断函数：<code>serial8250_interrupt</code> </p>
</blockquote>
<h4 id="3_2">3. 响应中断</h4>
<p>接着，再看看内核什么时候该响应中断？即中断响应流程 <code>arch/arm64/kernel/entry.S</code> 。</p>
<p>实际上这部分内容还是比较重要的，比如几个例子</p>
<ul>
<li>
<p>调中断时候，还不知道该中断是否正常工作，那就要知道这个中断是由谁触发的怎么处理，在调试时才知道要看哪些函数、寄存器。</p>
</li>
<li>
<p>在中断注册的时候，连枚举都没有获得设备树的编号，那肯定要看设备树的配置有没有问题。</p>
</li>
<li>
<p>如果设备树配置正确，但还是没有注册中断，那就去看 request_irq.</p>
</li>
<li>
<p>注册之后，中断还是没有相应，这个时候就需要知道内核什么时候会响应这个中断：是所有中断都没响应，还是只是这一中断没响应。</p>
<p>不过所有中断都没有响应，这种情况应该比较少，应该会出现在小系统移植的时候，做Linux 的移植，这个时候内核刚启动完，没有timer也能启动内核，串口是第一个响应中断的用户，那这个时候去看中断有没有响应，去看在什么层次做调试。</p>
<p><strong>无论到是哪一种 ISA，它关于异常/中断响应流程都是类似的（比如什么保存现场、返回内核空间还是用户空间）。</strong></p>
</li>
</ul>
<p><img alt="image-20250319103153137" src="pic/image-20250319103153137.png" /></p>
<div class="highlight"><pre><span></span><code>flowchart TD
    A[中断触发] --&gt; B[跳转异常向量表vectors]
    B --&gt; C[kernel_ventry入口]
    C --&gt; D[kernel_entry保存现场]
    D --&gt; E[关中断disable_daif]
    E --&gt; F[调用gic_handle_irq等处理函数]
    F --&gt; G[安全特性处理MTE/PAC/SSBD]
    G --&gt; H[kernel_exit恢复现场]
    H --&gt; I[开中断并eret返回]
</code></pre></div>
<p>这个查找：<code>:cs find g el0t_64_irq_handler</code> 是什么？</p>
<p>对应该串口的中断处理函数：<code>serial8250_interrupt</code>（<code>drivers/tty/serial/8250/8250_core.c</code>）</p>
<p>具体注册：<code>dw8250_handle_irq</code>（<code>drivers/tty/serial/8250/8250_dw.c</code>）、<code>serial8250_handle_irq</code>（<code>drivers/tty/serial/8250/8250_port.c</code>）具体涉及到 <code>uart</code> 更多细节，使用 DMA？</p>
<p>之后就是中断返回了，恢复现场等等。</p>
<p>中断之后上下文怎么恢复？<code>APCS</code>、<code>CPSR/PSTATE</code>（处理器的状态！有点像 NEMU 中的特权级切换，都是一样的）</p>
<p><strong>上面的内容除了让自己造轮子以外，更大的作用就是更好的调试。</strong></p>
<p>对于具体工作/真正做起来说，知道中断编号、设备树怎么写，再把 <code>request_irq</code> 捋一下，差不多就清楚。</p>
<p><img src="pic/image-20250319103058314.png" alt="image-20250319103058314" style="zoom:67%;" /></p>
<p><img src="pic/image-20250319103008096.png" alt="image-20250319103008096" style="zoom:67%;" /></p>
<h4 id="_23">其他问题</h4>
<ul>
<li>
<p>中断和查询的性能对比</p>
<ul>
<li>什么情况中断(异常也是类似的，ARM/RISC-V下中断是异常的一种)</li>
<li>什么情况查询</li>
</ul>
<p>还是那个问题，占用CPU、latency。所以要看 <code>latency of interrupt handling</code>。</p>
<p><strong>参考值：5000 CPU cycle：e.g.CPU 1GHz → 5us。（具体可能是几千，不细说，但未来可以看看具体算出来的？）</strong></p>
<p>具体来说，如果一秒钟中断的处理次数要远远大于 <code>1000 * 1000 / 5 = 200,000</code>，那使用中断应该是能节省 CPU 的占用时间，</p>
<p>但如果小于呢？？我有点迷惑上面这个结论是否正确了？</p>
<p>如果中断来得特别多的话，那就暂时用 <code>thread irq</code>线程的方式来处理中断。（在网卡里会这么用）这种情况适合中断比较少，但是中断来得比较快。处理完之后再转成默认的中断。</p>
</li>
</ul>
<p>但实际上中断只占了异步通知的一小部分，内核社区在做的事情更多在于怎么更好更方便地去内核和用户空间做异步通知，有时候会叫成用户态中断。</p>
<ul>
<li>
<p><strong>用户态的异步通知</strong></p>
<ul>
<li>
<p>信号</p>
</li>
<li>
<p><code>signalfd</code></p>
</li>
<li>
<p><code>userfaultfd</code></p>
<p>虚拟化做缺页处理的</p>
</li>
<li>
<p><code>UIO</code> 的中断</p>
</li>
<li>
<p><code>virtio</code> 的中断</p>
</li>
</ul>
</li>
<li>
<p><strong>定时器的使用和精度</strong></p>
<ul>
<li>C++ 的timer</li>
<li>select 的精度</li>
</ul>
</li>
<li>
<p><strong>性能视角的总结</strong></p>
<ul>
<li><code>latency</code> vs <code>bandwidth</code></li>
<li>单次的 <code>latency</code> vs 批量的 <code>latency</code></li>
</ul>
</li>
</ul>
<p>补充：<code>kernel command-line</code></p>
<p>文档：<code>Documentation/admin-guide/kernel-parameters.*</code></p>
<p>具体来说，对于 8250 这个设备，我是要去配一个参数的。</p>
<p><img alt="image-20250319110016638" src="pic/image-20250319110016638.png" /></p>
<p>就像在 NEMU 上移植 <code>nommu-Linux</code> 的时候，在设备树里写的：</p>
<div class="highlight"><pre><span></span><code><span class="l l-Scalar l-Scalar-Plain">chosen {</span>
<span class="w">    </span><span class="l l-Scalar l-Scalar-Plain">bootargs = &quot;earlycon=uart8250,mmio,0xa00003f8,1000000 console=ttyS0&quot;;</span>
<span class="l l-Scalar l-Scalar-Plain">};</span>
</code></pre></div>
<p>搞清楚自己要配什么？</p>
<h3 id="_24">设备模型</h3>
<h4 id="linux_3">Linux 对设备抽象的演进</h4>
<p>这个就是为了解决电源管理的问题。。。休眠唤醒。</p>
<ul>
<li>总线驱动 + 设备驱动</li>
<li>虚拟设备驱动（platform bus）</li>
<li>面向对象：设备模型</li>
<li>class 和 multi-function-device（mfd）</li>
<li>面向对象：资源和申请和回收</li>
<li>更好的抽象嵌入式 ARM 设备：device tree</li>
<li>服务器的设备抽象：ACPI</li>
</ul>
<blockquote>
<p>查 bug，通过知道 APCS，知道传递函数参数，是用 x0-x7的。</p>
<p>根据调用函数 xxx+0x30 这种，也能算出实际调用的问题在哪里。</p>
<p>对照 <code>objdump</code> 就能找到问题。</p>
</blockquote>
<h4 id="_25">为什么需要总线设备？</h4>
<p><code>DeepSeek</code>：</p>
<ol>
<li>
<p><strong>统一电源管理</strong>
    需要系统级休眠唤醒时，内核必须知道：</p>
<ul>
<li>所有设备的依赖关系（如USB设备依赖USB控制器）</li>
<li>设备的电源状态切换顺序（先唤醒父设备再操作子设备）</li>
</ul>
</li>
<li>
<p><strong>解决硬件拓扑描述</strong>
    现代计算机有复杂的硬件层级：</p>
<div class="highlight"><pre><span></span><code>graph LR
    CPU--&gt; PCIe_Root
    PCIe_Root --&gt; PCI_Bridge
    PCI_Bridge --&gt; USB_Controller
    USB_Controller --&gt; USB_Mouse
</code></pre></div>
<p>需要树形结构描述设备关系</p>
</li>
<li>
<p><strong>解耦驱动与设备</strong>
    传统驱动代码中硬编码设备信息（如寄存器地址、中断号），设备模型通过抽象层实现驱动与硬件的解耦。</p>
</li>
</ol>
<p>我觉得最重要的原因就是：<strong>抽象不同总线</strong></p>
<ul>
<li>不同的资源组织形势</li>
<li>不同的枚举方式</li>
<li>不同的总线专有特性</li>
<li>不同的拓扑关系了。例如 IOMMU 和 PCI 的关系。SMMU 和 platform device 的关系。</li>
</ul>
<h4 id="_26">设备模型核心概念</h4>
<ul>
<li>
<p><strong>四大核心结构体（面向对象思想的体现）</strong></p>
<table>
<thead>
<tr>
<th style="text-align: left;">结构体</th>
<th style="text-align: left;">作用</th>
<th style="text-align: left;">类比面向对象</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: left;"><code>struct bus_type</code></td>
<td style="text-align: left;">总线类型（如PCI、USB、虚拟的platform）</td>
<td style="text-align: left;">抽象基类</td>
</tr>
<tr>
<td style="text-align: left;"><code>struct device</code></td>
<td style="text-align: left;">代表一个物理/逻辑设备</td>
<td style="text-align: left;">对象实例</td>
</tr>
<tr>
<td style="text-align: left;"><code>struct device_driver</code></td>
<td style="text-align: left;">设备的驱动程序</td>
<td style="text-align: left;">操作方法集合</td>
</tr>
<tr>
<td style="text-align: left;"><code>struct class</code></td>
<td style="text-align: left;">设备分类（如input、block）</td>
<td style="text-align: left;">接口抽象</td>
</tr>
</tbody>
</table>
</li>
<li>
<p><strong>关键机制</strong></p>
<ul>
<li><strong>sysfs 文件系统</strong>：<code>/sys</code> 目录下展示设备树结构</li>
<li><strong>热插拔事件处理</strong>：通过uevent机制通知用户空间（如udev）</li>
<li><strong>电源管理</strong>：实现<code>-&gt;suspend()</code>和<code>-&gt;resume()</code>回调</li>
</ul>
</li>
</ul>
<h4 id="platform-bus">platform bus</h4>
<p>这里需要搞清晰 platform bus 和其他的总线的内容。看文档就讲得很好：<code>Documentation/driver-api/driver-model/platform.rst</code></p>
<ul>
<li>
<p><strong>总线</strong></p>
<p>这里简单回忆一些jyy上课讲过的内容：</p>
<blockquote>
<p>你总不想每个计算机系统只有固定的设备吧？我想接入更多 (甚至<strong>未知</strong>) 的 I/O 设备，要是有一天出了新型产品硬件，那只要有这个，就能极大地减少成本呀！复用率高！</p>
<p>所以，这么一个特殊的 I/O 设备：总线bus</p>
<p>每当有一个请求给总线，总线会根据这个请求（属于 DDR，属于键盘，属于别的设备），转发给别的设备！</p>
<p>但总线也有设备，CPU 通过和总线的寄存器交互，从而知道总线挂了哪些设备，设备中有几个寄存器，产商是谁......</p>
<p><img alt="image-20250305172845154" src="pic/image-20250305172845154.png" /></p>
<p>所有外部设备都直接或间接地连接到 PCIe 总线上，插上之后，总线给它分配地址。</p>
</blockquote>
<p>而 Linux 内核通过分层总线模型管理硬件设备，其核心设计目标是 <strong>统一设备管理</strong> 与 <strong>硬件差异抽象</strong>。我现在把总线架构可分为两类：</p>
<table>
<thead>
<tr>
<th style="text-align: left;"><strong>总线类型</strong></th>
<th style="text-align: left;"><strong>物理总线</strong></th>
<th style="text-align: left;"><strong>虚拟总线</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: left;"><strong>硬件特性</strong></td>
<td style="text-align: left;">真实电气连接（PCIe/USB/I2C/SPI）</td>
<td style="text-align: left;">软件抽象用于管理无总线机制（无物理信号）</td>
</tr>
<tr>
<td style="text-align: left;"><strong>设备发现方式</strong></td>
<td style="text-align: left;">硬件自动枚举（Presence Detection）</td>
<td style="text-align: left;">静态配置（设备树/ACPI）</td>
</tr>
<tr>
<td style="text-align: left;"><strong>地址分配</strong></td>
<td style="text-align: left;">动态分配（BAR空间/端点地址）</td>
<td style="text-align: left;">固定地址（芯片手册定义）</td>
</tr>
<tr>
<td style="text-align: left;"><strong>典型示例</strong></td>
<td style="text-align: left;">PCIe网卡、USB摄像头</td>
<td style="text-align: left;">SoC内部控制器（GPIO/UART）</td>
</tr>
</tbody>
</table>
<div class="highlight"><pre><span></span><code>graph TD
    Root[系统总线] --&gt; Physical[物理总线]
    Root --&gt; Virtual[虚拟总线]
    Physical --&gt; PCIe
    Physical --&gt; USB
    Physical --&gt; I2C
    Virtual --&gt; Platform
</code></pre></div>
</li>
</ul>
<p>这个其实光看其实没什么理解，还是需结合具体外设的例子：比如说 I2C、SPI、PCI 来学。</p>
<p>再补充一些概念：</p>
<ul>
<li>
<p><strong><code>xxx controller</code> 和 <code>xxx device</code></strong></p>
<ul>
<li><strong>controller：</strong>SoC 内部的 I2C 控制器 IP 核</li>
<li><strong>device：</strong>外接的传感器、EEPROM 等</li>
</ul>
<p><a href="https://stackoverflow.com/questions/27743652/platform-device-driver-vs-i2c-device-driver">platform device/driver vs i2c device/driver - Stack Overflow</a></p>
<div class="highlight"><pre><span></span><code>graph TD
    subgraph SoC[&quot;SoC 芯片&quot;]
        CPUcore[&quot;CPU core&quot;]
        BUS[&quot;bus&quot;]
        GPIO[&quot;GPIO controller&quot;]
        UART[&quot;UART controller&quot;]
        I2C_Ctrl[&quot;I2C controller&quot;]
        SPI_Ctrl[&quot;I2C controller&quot;]
    end
    I2C_Ctrl --&gt; camera
    I2C_Ctrl --&gt; other_senor
    SPI_Ctrl --&gt; LCD
</code></pre></div>
</li>
<li>
<p><strong><code>Discoverable</code> 和 <code>not discoverable</code></strong></p>
<p><strong>Discoverable</strong>：</p>
<ul>
<li><strong>硬件级发现</strong>：总线控制器能通过电气信号或协议自动检测设备存在（如 PCIe 的 Presence Detect 引脚、USB 的端口状态检测）</li>
<li><strong>动态枚举</strong>：系统在运行时（无需预先配置）识别设备并分配资源（地址、中断等）</li>
</ul>
<p><strong>not discoverable</strong>：</p>
<ul>
<li><strong>本质</strong>：总线连接的设备无法通过硬件机制自动检测</li>
<li><strong>根源</strong>：设备物理位置和资源配置在硬件设计阶段已固定（如 SoC 内部外设）</li>
<li><strong>结果</strong>：依赖软件静态描述（设备树/ACPI）或硬编码信息</li>
</ul>
</li>
</ul>
<p>这个时候再来看 <code>platform bus</code> 和 <code>platform device</code> 和 <code>platform driver</code> 的内容，就好理解了，直接看kernel 文档的定义：</p>
<blockquote>
<p>See <linux/platform_device.h> for the driver model interface to theplatform bus:  platform_device, and platform_driver.</p>
<p><strong>This pseudo-bus is used to connect devices on busses with minimal infrastructure, like those used to integrate peripherals on many system-on-chip processors, or some "legacy" PC interconnects; as opposed to large formally specified ones like PCI or USB.</strong> </p>
<p>Platform devices are devices that typically appear as autonomousentities in the system. This includes legacy port-based devices and host bridges to peripheral buses, and most controllers integrated into system-on-chip platforms.  What they usually have in common is direct addressing from a CPU bus.  Rarely, a platform_device will be connected through a segment of some other kind of bus; but its registers will still be directly addressable.</p>
</blockquote>
<ul>
<li>
<p><code>platform bus</code>：一款伪总线，用于连接基础设施最少的总线上的设备。</p>
</li>
<li>
<p><code>platform device</code>：<strong>无法通过硬件机制自动发现</strong> 的嵌入式设备，需通过静态配置描述其存在。</p>
<p><strong>包括传统的基于端口的设备、连接外设总线的主桥，以及大多数集成在 SoC 平台中的控制器。它们的共同特点是能够通过 CPU 总线直接寻址。</strong></p>
<p>典型特征：</p>
<ul>
<li><strong>资源固定性</strong>：寄存器地址、中断号等由 SoC 设计固化</li>
<li><strong>关键路径依赖</strong>：多为系统启动早期必需的底层控制器</li>
<li><strong>非热插拔</strong>：物理连接固定（焊接或 SoC 集成）</li>
</ul>
</li>
<li>
<p><code>platform driver</code>：自然就是管理 Platform device 的程序。</p>
<ul>
<li><strong>硬件初始化</strong>：配置时钟、电源、寄存器等底层资源</li>
<li><strong>资源抽象</strong>：向上层总线（如 I2C/SPI 核心）提供标准接口</li>
<li><strong>电源管理</strong>：实现休眠/唤醒等低功耗状态切换</li>
</ul>
</li>
</ul>
<p>具体来看个图，再结合例子就能看懂。</p>
<div class="highlight"><pre><span></span><code>graph LR
    %% SoC内部结构
    subgraph SoC[&quot;SoC 内部&quot;]
        %% 总线层级
        subgraph Buses[&quot;总线层级&quot;]
            Platform_Bus[&quot;Platform Bus (虚拟总线)&quot;]
            I2C_Bus[&quot;I2C Bus&quot;]
            SPI_Bus[&quot;SPI Bus&quot;]
            USB_Bus[&quot;USB Bus&quot;]
            PCIe_Bus[&quot;PCIe Bus&quot;]
            UART_Bus[&quot;UART Bus&quot;]
        end

        %% SoC内部控制器（Platform设备）
        Platform_Bus --&gt; I2C_Ctrl[&quot;I2C控制器（Platform设备）&quot;]
        Platform_Bus --&gt; SPI_Ctrl[&quot;SPI控制器（Platform设备）&quot;]
        Platform_Bus --&gt; USB_Host[&quot;USB Host控制器（Platform设备）&quot;]
        Platform_Bus --&gt; PCIe_Ctrl[&quot;PCIe控制器（Platform设备）&quot;]
        Platform_Bus --&gt; UART_Ctrl[&quot;UART控制器（Platform设备）&quot;]
    end

    %% 总线设备（非Platform设备）
    subgraph External_Devices[&quot;外部设备&quot;]
        %% I2C总线设备
        I2C_Ctrl --&gt; I2C_Bus
        I2C_Bus --&gt; Sensor[&quot;温度传感器（I2C设备）&quot;]
        I2C_Bus --&gt; RTC[&quot;RTC芯片（I2C设备）&quot;]

        %% SPI总线设备
        SPI_Ctrl --&gt; SPI_Bus
        SPI_Bus --&gt; Flash[&quot;SPI Flash（SPI设备）&quot;]
        SPI_Bus --&gt; LCD[&quot;SPI LCD屏（SPI设备）&quot;]

        %% USB总线设备
        USB_Host --&gt; USB_Bus
        USB_Bus --&gt; Hub[&quot;USB Hub（USB设备）&quot;]
        Hub --&gt; Mouse[&quot;USB鼠标（USB设备）&quot;]
        Hub --&gt; Camera[&quot;USB摄像头（USB设备）&quot;]

        %% PCIe总线设备
        PCIe_Ctrl --&gt; PCIe_Bus
        PCIe_Bus --&gt; NIC[&quot;PCIe网卡（PCIe设备）&quot;]

        %% UART总线设备
        UART_Ctrl --&gt; UART_Bus
        UART_Bus --&gt; GPS[&quot;UART GPS模块（UART设备）&quot;]
    end

    %% 样式定义（适合黑色背景）
    classDef soc fill:#000000,stroke:#ffa500,stroke-width:2px,color:#ffa500;
    classDef bus fill:#000000,stroke:#add8e6,stroke-width:2px,color:#add8e6;
    classDef platform_device fill:#000000,stroke:#00ffff,stroke-width:2px,color:#00ffff;
    classDef device fill:#000000,stroke:#ffff00,stroke-width:2px,color:#ffff00;

    class SoC soc;
    class Platform_Bus,I2C_Bus,SPI_Bus,USB_Bus,PCIe_Bus,UART_Bus bus;
    class I2C_Ctrl,SPI_Ctrl,USB_Host,PCIe_Ctrl,UART_Ctrl platform_device;
    class Sensor,RTC,Flash,LCD,Hub,Mouse,Camera,NIC,GPS device;
</code></pre></div>
<p>还是以 I2C 子系统为例，这个时候再回去看具体例子和 API 解释：</p>
<blockquote>
<p><strong>Every SOC(Silicon on Chip) or microcontroller will have a I2C controller, which provides a way to connect and communicate to I2C devices like camera sensors, PMIC, temperature sensor etc. The driver used for configuring and using this I2C controller is called platform driver. This I2C controller is called platform device. Mostly platform devices will be part of the SOC. The registers of the I2C controller are programmed using platform driver. These registers are in say ARM memory mapped and will be available on TRM of the SOC.</strong></p>
<p><strong>Now all the I2C devices that can be connected to the SOC or microcontroller via I2C controller like Camera sensors, PMIC, temperature sensor etc need a driver to control them. This driver is called device driver. The registers of these devices are not part of memory map of SOC. Need the datasheet of the I2C device like OV5640 Camera Sensor to program the registers. I2C data are sent out to program the registers and access data.</strong></p>
</blockquote>
<p>已经总结得很好了，额外注意一个 MMIO 的例子，MMIO映射的是 controller 相关的寄存器！！以前的想法有点不准确！</p>
<blockquote>
<h4 id="mmio">MMIO 映射的寄存器属于控制器而非外设设备</h4>
<p>MMIO（Memory-Mapped I/O）是 CPU 访问硬件设备寄存器的关键机制，它将设备的控制寄存器映射到内存地址空间。以下两类场景需要 MMIO：</p>
<table>
<thead>
<tr>
<th><strong>场景</strong></th>
<th><strong>示例</strong></th>
<th><strong>映射目标</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>总线控制器</strong></td>
<td>I2C控制器、SPI控制器</td>
<td>控制器的寄存器</td>
</tr>
<tr>
<td><strong>独立外设</strong></td>
<td>PCI设备、GPU显存</td>
<td>外设自身的寄存器/内存区域</td>
</tr>
</tbody>
</table>
<hr />
<h4 id="i2cspi">二、I2C/SPI 总线架构的硬件层级</h4>
<div class="highlight"><pre><span></span><code>graph TD
    SOC[&quot;SoC&quot;] --&gt; I2C_CTRL[&quot;I2C控制器 (MMIO映射)&quot;]
    SOC --&gt; SPI_CTRL[&quot;SPI控制器 (MMIO映射)&quot;]
    
    I2C_CTRL --&gt; I2C_DEV1[&quot;I2C温度传感器 (从机地址 0x48)&quot;]
    I2C_CTRL --&gt; I2C_DEV2[&quot;I2C RTC芯片 (从机地址 0x68)&quot;]
    
    SPI_CTRL --&gt; SPI_DEV1[&quot;SPI Flash (片选 0)&quot;]
    SPI_CTRL --&gt; SPI_DEV2[&quot;SPI LCD屏 (片选 1)&quot;]
</code></pre></div>
<h5 id="1-mmio_2">1. <strong>控制器寄存器（MMIO 映射）</strong></h5>
<ul>
<li><strong>物理位置</strong>：集成在 SoC 内部</li>
<li><strong>访问方式</strong>：CPU 直接读写内存地址（如 <code>0x10000000</code>）</li>
<li><strong>操作内容</strong>：<ul>
<li>配置总线时钟频率</li>
<li>控制数据传输（启动/停止条件、DMA 配置）</li>
<li>状态寄存器查询（传输完成、错误标志）</li>
</ul>
</li>
</ul>
<h5 id="2-mmio_1">2. <strong>外设寄存器（非 MMIO 映射）</strong></h5>
<ul>
<li><strong>物理位置</strong>：位于外部芯片（如传感器、Flash）</li>
<li><strong>访问方式</strong>：通过总线协议（I2C/SPI）间接访问</li>
<li><strong>操作内容</strong>：<ul>
<li>发送读/写命令（如 <code>i2c_smbus_read_byte_data</code>）</li>
<li>传输数据缓冲区（如 <code>spi_write</code>）</li>
</ul>
</li>
</ul>
<hr />
<h4 id="_27">三、代码示例对比</h4>
<h5 id="1-i2c-mmio">1. <strong>I2C 控制器驱动（MMIO 操作）</strong></h5>
<div class="highlight"><pre><span></span><code><span class="c1">// 设备树定义</span>
<span class="nl">i2c0</span><span class="p">:</span><span class="w"> </span><span class="n">i2c</span><span class="err">@</span><span class="mi">10000000</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">compatible</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">&quot;vendor,i2c-controller&quot;</span><span class="p">;</span>
<span class="w">    </span><span class="n">reg</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">&lt;</span><span class="mh">0x10000000</span><span class="w"> </span><span class="mh">0x1000</span><span class="o">&gt;</span><span class="p">;</span><span class="w"> </span><span class="c1">// MMIO 区域</span>
<span class="w">    </span><span class="n">interrupts</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">&lt;</span><span class="mi">0</span><span class="w"> </span><span class="mi">32</span><span class="w"> </span><span class="n">IRQ_TYPE_LEVEL_HIGH</span><span class="o">&gt;</span><span class="p">;</span>
<span class="p">};</span>

<span class="c1">// 驱动代码</span>
<span class="k">static</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="nf">i2c_controller_probe</span><span class="p">(</span><span class="k">struct</span><span class="w"> </span><span class="nc">platform_device</span><span class="w"> </span><span class="o">*</span><span class="n">pdev</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">    </span><span class="k">struct</span><span class="w"> </span><span class="nc">resource</span><span class="w"> </span><span class="o">*</span><span class="n">res</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">platform_get_resource</span><span class="p">(</span><span class="n">pdev</span><span class="p">,</span><span class="w"> </span><span class="n">IORESOURCE_MEM</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">);</span>
<span class="w">    </span><span class="kt">void</span><span class="w"> </span><span class="n">__iomem</span><span class="w"> </span><span class="o">*</span><span class="n">base</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">devm_ioremap_resource</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span><span class="w"> </span><span class="n">res</span><span class="p">);</span>
<span class="w">    </span>
<span class="w">    </span><span class="c1">// 配置控制器寄存器</span>
<span class="w">    </span><span class="n">writel</span><span class="p">(</span><span class="mh">0x200</span><span class="p">,</span><span class="w"> </span><span class="n">base</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">I2C_CLK_DIV</span><span class="p">);</span><span class="w"> </span><span class="c1">// 设置时钟分频</span>
<span class="w">    </span><span class="n">writel</span><span class="p">(</span><span class="mh">0x1</span><span class="p">,</span><span class="w"> </span><span class="n">base</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">I2C_CTRL</span><span class="p">);</span><span class="w">      </span><span class="c1">// 使能控制器</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>
<h5 id="2-i2c">2. <strong>I2C 外设驱动（总线协议访问）</strong></h5>
<div class="highlight"><pre><span></span><code><span class="c1">// 设备树定义</span>
<span class="nl">temp_sensor</span><span class="p">:</span><span class="w"> </span><span class="n">sensor</span><span class="err">@</span><span class="mi">48</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">compatible</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">&quot;ti,tmp75&quot;</span><span class="p">;</span>
<span class="w">    </span><span class="n">reg</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">&lt;</span><span class="mh">0x48</span><span class="o">&gt;</span><span class="p">;</span><span class="w"> </span><span class="c1">// 从机地址，非MMIO地址！</span>
<span class="p">};</span>

<span class="c1">// 驱动代码</span>
<span class="k">static</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="nf">tmp75_probe</span><span class="p">(</span><span class="k">struct</span><span class="w"> </span><span class="nc">i2c_client</span><span class="w"> </span><span class="o">*</span><span class="n">client</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">    </span><span class="c1">// 通过I2C协议读取温度</span>
<span class="w">    </span><span class="n">u8</span><span class="w"> </span><span class="n">reg</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mh">0x00</span><span class="p">;</span><span class="w"> </span><span class="c1">// 温度寄存器地址</span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">temp</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">i2c_smbus_read_byte_data</span><span class="p">(</span><span class="n">client</span><span class="p">,</span><span class="w"> </span><span class="n">reg</span><span class="p">);</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>
<hr />
<h4 id="_28">四、关键差异总结</h4>
<table>
<thead>
<tr>
<th><strong>特性</strong></th>
<th>总线控制器 (MMIO)</th>
<th>外设设备 (非MMIO)</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>寄存器物理位置</strong></td>
<td>SoC 内部</td>
<td>外部芯片内部</td>
</tr>
<tr>
<td><strong>CPU访问方式</strong></td>
<td>直接读写内存地址</td>
<td>通过总线协议（I2C/SPI）</td>
</tr>
<tr>
<td><strong>驱动代码操作</strong></td>
<td><code>ioremap</code> + <code>writel/readl</code></td>
<td><code>i2c_transfer</code>/<code>spi_sync</code></td>
</tr>
<tr>
<td><strong>设备树属性</strong></td>
<td><code>reg</code> 表示物理地址范围</td>
<td><code>reg</code> 表示总线地址（如从机地址）</td>
</tr>
<tr>
<td><strong>典型操作</strong></td>
<td>配置总线参数、DMA控制</td>
<td>发送数据包、读取传感器值</td>
</tr>
</tbody>
</table>
<hr />
<p><strong>常见误解澄清</strong></p>
<h5 id="1-mmio_3">1. <strong>为什么外设寄存器不直接 MMIO 映射？</strong></h5>
<ul>
<li><strong>电气隔离</strong>：I2C/SPI 外设与 SoC 之间通过总线连接，无法直接访问其内部寄存器</li>
<li><strong>协议封装</strong>：外设操作需遵循总线协议（如 I2C 的 START/STOP 条件）</li>
<li><strong>地址冲突</strong>：总线上的外设可能有相同物理地址（如多个 I2C 0x48 设备），需通过总线拓扑区分</li>
</ul>
<h5 id="2-mmio_2">2. <strong>例外情况：MMIO 外设</strong></h5>
<p>某些复杂外设（如 PCIe 网卡、USB3 控制器）<strong>自身拥有 MMIO 空间</strong>，但这些场景中：
   - 外设通过 PCIe/USB 总线连接到 SoC
   - 其 MMIO 空间由总线控制器（如 PCIe Root Complex）动态分配
   - 与 I2C/SPI 外设有本质区别</p>
<hr />
<p><strong>调试技巧</strong></p>
<h5 id="1-mmio_4">1. <strong>查看 MMIO 映射</strong></h5>
<div class="highlight"><pre><span></span><code><span class="c1"># 查看已注册的 I/O 内存区域</span>
cat<span class="w"> </span>/proc/iomem

<span class="c1"># 输出示例</span>
<span class="m">10000000</span>-10000fff<span class="w"> </span>:<span class="w"> </span>i2c0<span class="w">  </span><span class="c1"># I2C控制器的MMIO区域</span>
<span class="m">20000000</span>-20000fff<span class="w"> </span>:<span class="w"> </span>spi0<span class="w">  </span><span class="c1"># SPI控制器的MMIO区域</span>
</code></pre></div>
<h5 id="2_4">2. <strong>跟踪总线操作</strong></h5>
<div class="highlight"><pre><span></span><code><span class="c1"># 启用I2C调试</span>
<span class="nb">echo</span><span class="w"> </span><span class="m">1</span><span class="w"> </span>&gt;<span class="w"> </span>/sys/module/i2c_core/parameters/debug

<span class="c1"># 查看内核日志</span>
dmesg<span class="w"> </span><span class="p">|</span><span class="w"> </span>grep<span class="w"> </span><span class="s2">&quot;i2c i2c-0&quot;</span><span class="w">  </span><span class="c1"># 观察I2C总线传输过程</span>
</code></pre></div>
<h5 id="3-mmio">3. <strong>直接读写 MMIO（仅调试用！）</strong></h5>
<div class="highlight"><pre><span></span><code><span class="c1">// 内核模块中临时操作寄存器</span>
<span class="kt">void</span><span class="w"> </span><span class="n">__iomem</span><span class="w"> </span><span class="o">*</span><span class="n">base</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">ioremap</span><span class="p">(</span><span class="mh">0x10000000</span><span class="p">,</span><span class="w"> </span><span class="mh">0x1000</span><span class="p">);</span>
<span class="n">u32</span><span class="w"> </span><span class="n">reg_val</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">readl</span><span class="p">(</span><span class="n">base</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mh">0x04</span><span class="p">);</span>
<span class="n">writel</span><span class="p">(</span><span class="mh">0x55aa</span><span class="p">,</span><span class="w"> </span><span class="n">base</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mh">0x08</span><span class="p">);</span>
<span class="n">iounmap</span><span class="p">(</span><span class="n">base</span><span class="p">);</span>
</code></pre></div>
<hr />
<p>MMIO 映射的寄存器<strong>属于总线控制器（I2C/SPI控制器）</strong>，而非挂载在总线上的外设设备。理解这一区别是掌握以下内容的关键：
1. 如何编写总线控制器驱动（涉及 MMIO 操作）
2. 如何编写外设驱动（通过总线 API 通信）
3. 正确解析设备树中的 <code>reg</code> 属性含义</p>
</blockquote>
<h4 id="platform-device-platform-driver">platform device 和 platform driver 和设备树</h4>
<p>再深入一点，如果一个设备没有通过设备树来描述，那就需要在代码里面手动的创建 <code>platform device</code> 已经对应的 <code>platform driver</code>，如果设备树已经描述过，那 <code>platform device</code> 那就不用在这里创建了，内核自己有办法（什么办法？自动创建？），最终也是会自动调用 <code>platform driver</code> 的。借助 AI 总结。</p>
<ul>
<li>
<p><strong>步骤1：编写 Platform Driver</strong></p>
<div class="highlight"><pre><span></span><code><span class="c1">// my_platform_driver.c</span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;linux/module.h&gt;</span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;linux/platform_device.h&gt;</span>

<span class="k">static</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="nf">my_probe</span><span class="p">(</span><span class="k">struct</span><span class="w"> </span><span class="nc">platform_device</span><span class="w"> </span><span class="o">*</span><span class="n">pdev</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">    </span><span class="n">pr_info</span><span class="p">(</span><span class="s">&quot;Platform Driver Probe: Device found!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="nf">my_remove</span><span class="p">(</span><span class="k">struct</span><span class="w"> </span><span class="nc">platform_device</span><span class="w"> </span><span class="o">*</span><span class="n">pdev</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">    </span><span class="n">pr_info</span><span class="p">(</span><span class="s">&quot;Platform Driver Remove: Device removed.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span><span class="w"> </span><span class="k">struct</span><span class="w"> </span><span class="nc">platform_driver</span><span class="w"> </span><span class="n">my_driver</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="p">.</span><span class="n">probe</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">my_probe</span><span class="p">,</span>
<span class="w">    </span><span class="p">.</span><span class="n">remove</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">my_remove</span><span class="p">,</span>
<span class="w">    </span><span class="p">.</span><span class="n">driver</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="p">.</span><span class="n">name</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">&quot;my_manual_device&quot;</span><span class="p">,</span>
<span class="w">        </span><span class="p">.</span><span class="n">owner</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">THIS_MODULE</span><span class="p">,</span>
<span class="w">    </span><span class="p">},</span>
<span class="p">};</span>

<span class="n">module_platform_driver</span><span class="p">(</span><span class="n">my_driver</span><span class="p">);</span>

<span class="n">MODULE_LICENSE</span><span class="p">(</span><span class="s">&quot;GPL&quot;</span><span class="p">);</span>
<span class="n">MODULE_AUTHOR</span><span class="p">(</span><span class="s">&quot;Your Name&quot;</span><span class="p">);</span>
<span class="n">MODULE_DESCRIPTION</span><span class="p">(</span><span class="s">&quot;Manual Platform Driver Example&quot;</span><span class="p">);</span>
</code></pre></div>
</li>
<li>
<p><strong>步骤2：手动注册 Platform Device</strong></p>
<div class="highlight"><pre><span></span><code><span class="c1">// my_platform_device.c</span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;linux/module.h&gt;</span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;linux/platform_device.h&gt;</span>

<span class="k">static</span><span class="w"> </span><span class="k">struct</span><span class="w"> </span><span class="nc">platform_device</span><span class="w"> </span><span class="o">*</span><span class="n">my_device</span><span class="p">;</span>

<span class="k">static</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">__init</span><span class="w"> </span><span class="nf">my_device_init</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">    </span><span class="n">my_device</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">platform_device_alloc</span><span class="p">(</span><span class="s">&quot;my_manual_device&quot;</span><span class="p">,</span><span class="w"> </span><span class="mi">-1</span><span class="p">);</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="o">!</span><span class="n">my_device</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">pr_err</span><span class="p">(</span><span class="s">&quot;Failed to allocate platform device</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">ret</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">platform_device_add</span><span class="p">(</span><span class="n">my_device</span><span class="p">);</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">ret</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">pr_err</span><span class="p">(</span><span class="s">&quot;Failed to add platform device</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
<span class="w">        </span><span class="n">platform_device_put</span><span class="p">(</span><span class="n">my_device</span><span class="p">);</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="n">ret</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="n">pr_info</span><span class="p">(</span><span class="s">&quot;Manual Platform Device registered</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="n">__exit</span><span class="w"> </span><span class="nf">my_device_exit</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">    </span><span class="n">platform_device_unregister</span><span class="p">(</span><span class="n">my_device</span><span class="p">);</span>
<span class="w">    </span><span class="n">pr_info</span><span class="p">(</span><span class="s">&quot;Manual Platform Device unregistered</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
<span class="p">}</span>

<span class="n">module_init</span><span class="p">(</span><span class="n">my_device_init</span><span class="p">);</span>
<span class="n">module_exit</span><span class="p">(</span><span class="n">my_device_exit</span><span class="p">);</span>

<span class="n">MODULE_LICENSE</span><span class="p">(</span><span class="s">&quot;GPL&quot;</span><span class="p">);</span>
<span class="n">MODULE_AUTHOR</span><span class="p">(</span><span class="s">&quot;Your Name&quot;</span><span class="p">);</span>
<span class="n">MODULE_DESCRIPTION</span><span class="p">(</span><span class="s">&quot;Manual Platform Device Example&quot;</span><span class="p">);</span>
</code></pre></div>
</li>
<li>
<p><strong>步骤3：编译并加载模块</strong></p>
<ol>
<li>
<p><strong>编译模块</strong>：</p>
<div class="highlight"><pre><span></span><code>make<span class="w"> </span>-C<span class="w"> </span>/lib/modules/<span class="k">$(</span>uname<span class="w"> </span>-r<span class="k">)</span>/build<span class="w"> </span><span class="nv">M</span><span class="o">=</span><span class="nv">$PWD</span><span class="w"> </span>modules
</code></pre></div>
</li>
<li>
<p><strong>加载 Platform Device 模块</strong>：</p>
<div class="highlight"><pre><span></span><code>sudo<span class="w"> </span>insmod<span class="w"> </span>my_platform_device.ko
</code></pre></div>
</li>
<li>
<p><strong>加载 Platform Driver 模块</strong>：</p>
<div class="highlight"><pre><span></span><code>sudo<span class="w"> </span>insmod<span class="w"> </span>my_platform_driver.ko
</code></pre></div>
</li>
<li>
<p><strong>验证绑定</strong>：</p>
<div class="highlight"><pre><span></span><code>dmesg<span class="w"> </span><span class="p">|</span><span class="w"> </span>grep<span class="w"> </span><span class="s2">&quot;Platform Driver&quot;</span>
<span class="c1"># 应输出 &quot;Platform Driver Probe: Device found!&quot;</span>
</code></pre></div>
</li>
<li>
<p><strong>卸载模块</strong>：</p>
<div class="highlight"><pre><span></span><code>sudo<span class="w"> </span>rmmod<span class="w"> </span>my_platform_driver<span class="w"> </span>my_platform_device
</code></pre></div>
</li>
</ol>
</li>
<li>
<p><strong>设备树自动注册 Platform Device 的流程</strong></p>
<ul>
<li>
<p><strong>步骤1：修改设备树</strong></p>
<p>在设备树文件（如 <code>my_board.dts</code>）中添加节点：</p>
<div class="highlight"><pre><span></span><code><span class="nf">/</span><span class="cm"> </span><span class="p">{</span>
<span class="w">    </span><span class="nf">my_auto_device</span><span class="cm"> </span><span class="p">{</span>
<span class="w">        </span><span class="kr">compatible</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">&quot;my_auto_device&quot;</span><span class="p">;</span>
<span class="w">        </span><span class="kr">status</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">&quot;okay&quot;</span><span class="p">;</span>
<span class="w">    </span><span class="p">};</span>
<span class="p">};</span>
</code></pre></div>
</li>
<li>
<h4 id="2-platform-driver"><strong>步骤2：编写匹配设备树的 Platform Driver</strong></h4>
<div class="highlight"><pre><span></span><code><span class="c1">// my_dt_driver.c</span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;linux/module.h&gt;</span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;linux/platform_device.h&gt;</span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;linux/of.h&gt;</span>

<span class="k">static</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="nf">dt_probe</span><span class="p">(</span><span class="k">struct</span><span class="w"> </span><span class="nc">platform_device</span><span class="w"> </span><span class="o">*</span><span class="n">pdev</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">    </span><span class="n">pr_info</span><span class="p">(</span><span class="s">&quot;DT Driver Probe: Device found via Device Tree!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="nf">dt_remove</span><span class="p">(</span><span class="k">struct</span><span class="w"> </span><span class="nc">platform_device</span><span class="w"> </span><span class="o">*</span><span class="n">pdev</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">    </span><span class="n">pr_info</span><span class="p">(</span><span class="s">&quot;DT Driver Remove: Device removed.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="k">struct</span><span class="w"> </span><span class="nc">of_device_id</span><span class="w"> </span><span class="n">dt_match</span><span class="p">[]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="p">{</span><span class="w"> </span><span class="p">.</span><span class="n">compatible</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">&quot;my_auto_device&quot;</span><span class="w"> </span><span class="p">},</span>
<span class="w">    </span><span class="p">{}</span>
<span class="p">};</span>
<span class="n">MODULE_DEVICE_TABLE</span><span class="p">(</span><span class="n">of</span><span class="p">,</span><span class="w"> </span><span class="n">dt_match</span><span class="p">);</span>

<span class="k">static</span><span class="w"> </span><span class="k">struct</span><span class="w"> </span><span class="nc">platform_driver</span><span class="w"> </span><span class="n">dt_driver</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="p">.</span><span class="n">probe</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">dt_probe</span><span class="p">,</span>
<span class="w">    </span><span class="p">.</span><span class="n">remove</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">dt_remove</span><span class="p">,</span>
<span class="w">    </span><span class="p">.</span><span class="n">driver</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="p">.</span><span class="n">name</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">&quot;my_auto_device&quot;</span><span class="p">,</span>
<span class="w">        </span><span class="p">.</span><span class="n">of_match_table</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">dt_match</span><span class="p">,</span>
<span class="w">        </span><span class="p">.</span><span class="n">owner</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">THIS_MODULE</span><span class="p">,</span>
<span class="w">    </span><span class="p">},</span>
<span class="p">};</span>

<span class="n">module_platform_driver</span><span class="p">(</span><span class="n">dt_driver</span><span class="p">);</span>

<span class="n">MODULE_LICENSE</span><span class="p">(</span><span class="s">&quot;GPL&quot;</span><span class="p">);</span>
<span class="n">MODULE_AUTHOR</span><span class="p">(</span><span class="s">&quot;Your Name&quot;</span><span class="p">);</span>
<span class="n">MODULE_DESCRIPTION</span><span class="p">(</span><span class="s">&quot;Device Tree Platform Driver Example&quot;</span><span class="p">);</span>
</code></pre></div>
</li>
<li>
<p><strong>步骤3：更新设备树并加载驱动</strong></p>
</li>
<li>
<p><strong>编译设备树</strong>：</p>
<div class="highlight"><pre><span></span><code>dtc<span class="w"> </span>-I<span class="w"> </span>dts<span class="w"> </span>-O<span class="w"> </span>dtb<span class="w"> </span>-o<span class="w"> </span>my_board.dtb<span class="w"> </span>my_board.dts
</code></pre></div>
</li>
<li>
<p><strong>加载新设备树</strong>（通过Bootloader或动态加载）：</p>
<div class="highlight"><pre><span></span><code>sudo<span class="w"> </span>cp<span class="w"> </span>my_board.dtb<span class="w"> </span>/boot/
<span class="c1"># 重启系统</span>
</code></pre></div>
</li>
<li>
<p><strong>加载 Platform Driver 模块</strong>：</p>
<div class="highlight"><pre><span></span><code>sudo<span class="w"> </span>insmod<span class="w"> </span>my_dt_driver.ko
</code></pre></div>
</li>
<li>
<p><strong>验证自动绑定</strong>：</p>
<div class="highlight"><pre><span></span><code>dmesg<span class="w"> </span><span class="p">|</span><span class="w"> </span>grep<span class="w"> </span><span class="s2">&quot;DT Driver&quot;</span>
<span class="c1"># 应输出 &quot;DT Driver Probe: Device found via Device Tree!&quot;</span>
</code></pre></div>
</li>
<li>
<p><strong>查看设备信息</strong>：</p>
<div class="highlight"><pre><span></span><code>ls<span class="w"> </span>/sys/bus/platform/devices/my_auto_device
</code></pre></div>
</li>
</ul>
</li>
<li>
<p><strong>关键区别总结</strong></p>
</li>
</ul>
<table>
<thead>
<tr>
<th><strong>特性</strong></th>
<th><strong>手动注册</strong></th>
<th><strong>设备树自动注册</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>设备描述来源</strong></td>
<td>硬编码在模块中</td>
<td>设备树文件（动态配置）</td>
</tr>
<tr>
<td><strong>灵活性</strong></td>
<td>低（需重新编译模块修改设备信息）</td>
<td>高（修改设备树无需重新编译内核模块）</td>
</tr>
<tr>
<td><strong>资源管理</strong></td>
<td>需手动分配内存、中断等资源</td>
<td>通过设备树自动解析资源</td>
</tr>
<tr>
<td><strong>适用场景</strong></td>
<td>临时测试、无设备树支持的旧硬件</td>
<td>现代嵌入式系统，支持设备树的平台</td>
</tr>
<tr>
<td><strong>维护性</strong></td>
<td>设备信息分散在代码中，维护成本高</td>
<td>设备信息集中管理，易于维护</td>
</tr>
</tbody>
</table>
<ul>
<li><strong>手动注册</strong>适用于快速测试或旧系统，但缺乏灵活性。</li>
<li><strong>设备树自动注册</strong>是标准做法，通过解耦硬件描述和驱动代码，提升可维护性和可移植性。</li>
<li>内核通过解析设备树生成 <code>platform_device</code>，并自动匹配 <code>platform_driver</code> 的 <code>of_match_table</code> 完成绑定。</li>
</ul>
<h4 id="i2c-camera">设备访问全流程：I2C camera 为例</h4>
<ol>
<li>
<p><strong>硬件架构连接</strong></p>
<div class="highlight"><pre><span></span><code>graph LR
    SOC[&quot;ARM SoC&quot;] --&gt; I2C_Ctrl[&quot;I2C控制器（Platform设备）&quot;]
    I2C_Ctrl --&gt;|SCL/SDA| Camera[&quot;OV5640 Camera（I2C设备）&quot;]
    I2C_Ctrl --&gt;|MMIO| Registers[&quot;I2C控制器寄存器&quot;]
    Camera --&gt;|MIPI/Parallel| Image_Sensor[&quot;图像传感器&quot;]
</code></pre></div>
<p><strong>硬件特性</strong>：</p>
<ul>
<li><strong>I2C控制器</strong>：SoC内部模块，地址<code>0x400A0000</code>（内存映射）</li>
<li><strong>OV5640 Camera</strong>：从设备地址<code>0x3C</code>，通过I2C配置寄存器</li>
<li><strong>数据接口</strong>：图像数据通过MIPI/Parallel接口传输（与I2C控制总线分离）</li>
</ul>
</li>
<li>
<p><strong>设备树配置</strong></p>
<div class="highlight"><pre><span></span><code><span class="l l-Scalar l-Scalar-Plain">// SoC级定义：I2C控制器作为Platform设备</span>
<span class="l l-Scalar l-Scalar-Plain">i2c1</span><span class="p p-Indicator">:</span><span class="w"> </span><span class="l l-Scalar l-Scalar-Plain">i2c@400a0000 {</span>
<span class="w">    </span><span class="l l-Scalar l-Scalar-Plain">compatible = &quot;vendor,soc-i2c&quot;;</span>
<span class="w">    </span><span class="l l-Scalar l-Scalar-Plain">reg = &lt;0x400a0000 0x1000&gt;;    // MMIO地址范围</span>
<span class="w">    </span><span class="l l-Scalar l-Scalar-Plain">interrupts = &lt;0 32 IRQ_TYPE_LEVEL_HIGH&gt;;</span>
<span class="w">    </span><span class="l l-Scalar l-Scalar-Plain">clocks = &lt;&amp;i2c_clk&gt;;</span>
<span class="w">    </span><span class="l l-Scalar l-Scalar-Plain">#address-cells = &lt;1&gt;;</span>
<span class="w">    </span><span class="l l-Scalar l-Scalar-Plain">#size-cells = &lt;0&gt;;</span>

<span class="w">    </span><span class="l l-Scalar l-Scalar-Plain">// Camera设备节点</span>
<span class="w">    </span><span class="l l-Scalar l-Scalar-Plain">ov5640</span><span class="p p-Indicator">:</span><span class="w"> </span><span class="l l-Scalar l-Scalar-Plain">camera@3c {</span>
<span class="w">        </span><span class="l l-Scalar l-Scalar-Plain">compatible = &quot;ovti,ov5640&quot;;</span>
<span class="w">        </span><span class="l l-Scalar l-Scalar-Plain">reg = &lt;0x3c&gt;;             // I2C从地址</span>
<span class="w">        </span><span class="l l-Scalar l-Scalar-Plain">vdda-supply = &lt;&amp;vdd_cam&gt;; // 电源管理</span>
<span class="w">        </span><span class="l l-Scalar l-Scalar-Plain">clocks = &lt;&amp;cam_clk&gt;;      // 输入时钟</span>
<span class="w">        </span><span class="l l-Scalar l-Scalar-Plain">port {</span>
<span class="w">            </span><span class="l l-Scalar l-Scalar-Plain">// MIPI CSI接口绑定</span>
<span class="w">            </span><span class="l l-Scalar l-Scalar-Plain">ov5640_to_csi</span><span class="p p-Indicator">:</span><span class="w"> </span><span class="l l-Scalar l-Scalar-Plain">endpoint {</span>
<span class="w">                </span><span class="l l-Scalar l-Scalar-Plain">remote-endpoint = &lt;&amp;csi_to_ov5640&gt;;</span>
<span class="w">            </span><span class="l l-Scalar l-Scalar-Plain">};</span>
<span class="w">        </span><span class="l l-Scalar l-Scalar-Plain">};</span>
<span class="w">    </span><span class="l l-Scalar l-Scalar-Plain">};</span>
<span class="err">}</span><span class="l l-Scalar l-Scalar-Plain">;</span>
</code></pre></div>
<p><strong>关键点</strong>：</p>
<ul>
<li>I2C控制器通过<code>reg</code>属性声明MMIO地址</li>
<li>Camera设备通过<code>reg</code>指定I2C从地址</li>
<li>电源/时钟资源通过 <code>vdda-supply</code>和 <code>clocks</code> 关联</li>
</ul>
<blockquote>
<p>这里需要注意，由于 controller 的 not discoverabl，所以要使用设备树来传递配置。</p>
</blockquote>
</li>
<li>
<p><strong>内核驱动流程（代码级实现）</strong></p>
<ul>
<li>
<p><strong>I2C控制器驱动（Platform驱动）</strong></p>
<div class="highlight"><pre><span></span><code><span class="c1">// 注册Platform驱动</span>
<span class="k">static</span><span class="w"> </span><span class="k">struct</span><span class="w"> </span><span class="nc">platform_driver</span><span class="w"> </span><span class="n">soc_i2c_driver</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="p">.</span><span class="n">probe</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">soc_i2c_probe</span><span class="p">,</span>
<span class="w">    </span><span class="p">.</span><span class="n">driver</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="p">.</span><span class="n">name</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">&quot;soc-i2c&quot;</span><span class="p">,</span>
<span class="w">        </span><span class="p">.</span><span class="n">of_match_table</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">soc_i2c_of_match</span><span class="p">,</span>
<span class="w">    </span><span class="p">},</span>
<span class="p">};</span>
<span class="n">module_platform_driver</span><span class="p">(</span><span class="n">soc_i2c_driver</span><span class="p">);</span>

<span class="c1">// Probe函数初始化硬件</span>
<span class="k">static</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="nf">soc_i2c_probe</span><span class="p">(</span><span class="k">struct</span><span class="w"> </span><span class="nc">platform_device</span><span class="w"> </span><span class="o">*</span><span class="n">pdev</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="c1">// 解析设备树资源</span>
<span class="w">    </span><span class="k">struct</span><span class="w"> </span><span class="nc">resource</span><span class="w"> </span><span class="o">*</span><span class="n">res</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">platform_get_resource</span><span class="p">(</span><span class="n">pdev</span><span class="p">,</span><span class="w"> </span><span class="n">IORESOURCE_MEM</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">);</span>
<span class="w">    </span><span class="kt">void</span><span class="w"> </span><span class="n">__iomem</span><span class="w"> </span><span class="o">*</span><span class="n">base</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">devm_ioremap_resource</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span><span class="w"> </span><span class="n">res</span><span class="p">);</span>

<span class="w">    </span><span class="n">writel</span><span class="p">(</span><span class="n">CTRL_ENABLE</span><span class="p">,</span><span class="w"> </span><span class="n">base</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">CTRL_REG</span><span class="p">);</span><span class="w"> </span><span class="c1">// 使能控制器</span>
<span class="w">    </span><span class="c1">// 配置I2C时钟分频</span>

<span class="w">    </span><span class="n">writel</span><span class="p">(</span><span class="n">CLK_DIV_400K</span><span class="p">,</span><span class="w"> </span><span class="n">base</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">I2C_CLK_REG</span><span class="p">);</span>

<span class="w">    </span><span class="c1">// 注册I2C适配器</span>
<span class="w">    </span><span class="k">struct</span><span class="w"> </span><span class="nc">i2c_adapter</span><span class="w"> </span><span class="o">*</span><span class="n">adap</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">i2c_alloc_adapter</span><span class="p">();</span>
<span class="w">    </span><span class="n">adap</span><span class="o">-&gt;</span><span class="n">algo</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">&amp;</span><span class="n">soc_i2c_algo</span><span class="p">;</span><span class="w">  </span><span class="c1">// 实现i2c_algorithm</span>
<span class="w">    </span><span class="n">i2c_add_adapter</span><span class="p">(</span><span class="n">adap</span><span class="p">);</span><span class="w">       </span><span class="c1">// 生成/sys/class/i2c-dev/i2c-1</span>
<span class="p">}</span>
</code></pre></div>
</li>
<li>
<p><strong>Camera驱动（I2C设备驱动）</strong></p>
<div class="highlight"><pre><span></span><code><span class="c1">// 定义I2C设备ID表</span>
<span class="k">static</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="k">struct</span><span class="w"> </span><span class="nc">i2c_device_id</span><span class="w"> </span><span class="n">ov5640_id</span><span class="p">[]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="p">{</span><span class="w"> </span><span class="s">&quot;ov5640&quot;</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="p">},</span>
<span class="w">    </span><span class="p">{}</span>
<span class="p">};</span>
<span class="n">MODULE_DEVICE_TABLE</span><span class="p">(</span><span class="n">i2c</span><span class="p">,</span><span class="w"> </span><span class="n">ov5640_id</span><span class="p">);</span>

<span class="c1">// 定义设备树匹配表</span>
<span class="k">static</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="k">struct</span><span class="w"> </span><span class="nc">of_device_id</span><span class="w"> </span><span class="n">ov5640_of_match</span><span class="p">[]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="p">{</span><span class="w"> </span><span class="p">.</span><span class="n">compatible</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">&quot;ovti,ov5640&quot;</span><span class="w"> </span><span class="p">},</span>
<span class="w">    </span><span class="p">{}</span>
<span class="p">};</span>

<span class="c1">// 注册I2C驱动</span>
<span class="k">static</span><span class="w"> </span><span class="k">struct</span><span class="w"> </span><span class="nc">i2c_driver</span><span class="w"> </span><span class="n">ov5640_i2c_driver</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="p">.</span><span class="n">probe</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">ov5640_probe</span><span class="p">,</span>
<span class="w">    </span><span class="p">.</span><span class="n">remove</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">ov5640_remove</span><span class="p">,</span>
<span class="w">    </span><span class="p">.</span><span class="n">id_table</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">ov5640_id</span><span class="p">,</span>
<span class="w">    </span><span class="p">.</span><span class="n">driver</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="p">.</span><span class="n">name</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">&quot;ov5640&quot;</span><span class="p">,</span>
<span class="w">        </span><span class="p">.</span><span class="n">of_match_table</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">ov5640_of_match</span><span class="p">,</span>
<span class="w">    </span><span class="p">},</span>
<span class="p">};</span>
<span class="n">module_i2c_driver</span><span class="p">(</span><span class="n">ov5640_i2c_driver</span><span class="p">);</span>

<span class="k">static</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="nf">ov5640_probe</span><span class="p">(</span><span class="k">struct</span><span class="w"> </span><span class="nc">i2c_client</span><span class="w"> </span><span class="o">*</span><span class="n">client</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="c1">// 1. 获取设备树配置</span>
<span class="w">    </span><span class="k">struct</span><span class="w"> </span><span class="nc">device_node</span><span class="w"> </span><span class="o">*</span><span class="n">np</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">client</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">.</span><span class="n">of_node</span><span class="p">;</span>
<span class="w">    </span><span class="n">u32</span><span class="w"> </span><span class="n">addr</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">client</span><span class="o">-&gt;</span><span class="n">addr</span><span class="p">;</span><span class="w">          </span><span class="c1">// I2C地址（0x30）</span>
<span class="w">    </span><span class="n">u32</span><span class="w"> </span><span class="n">speed</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">of_property_read_u32</span><span class="p">(</span><span class="n">np</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;clock-frequency&quot;</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">speed</span><span class="p">);</span>

<span class="w">    </span><span class="c1">// 2. 初始化摄像头硬件</span>
<span class="w">    </span><span class="n">camera_sensor_power_on</span><span class="p">(</span><span class="o">&amp;</span><span class="n">client</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">);</span>
<span class="w">    </span><span class="n">i2c_smbus_write_byte_data</span><span class="p">(</span><span class="n">client</span><span class="p">,</span><span class="w"> </span><span class="n">REG_CONFIG</span><span class="p">,</span><span class="w"> </span><span class="mh">0x01</span><span class="p">);</span><span class="w"> </span><span class="c1">// 配置寄存器</span>

<span class="w">    </span><span class="c1">// 3. 注册字符设备或V4L2接口</span>
<span class="w">    </span><span class="n">v4l2_device_register</span><span class="p">(</span><span class="o">&amp;</span><span class="n">client</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">camera_v4l2_dev</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div>
</li>
<li>
<p><strong>I2C数据传输核心（i2c_algorithm实现）</strong></p>
<div class="highlight"><pre><span></span><code><span class="c1">// 实现I2C算法（控制器级）</span>
<span class="k">static</span><span class="w"> </span><span class="k">struct</span><span class="w"> </span><span class="nc">i2c_algorithm</span><span class="w"> </span><span class="n">soc_i2c_algo</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="p">.</span><span class="n">master_xfer</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">soc_i2c_xfer</span><span class="p">,</span>
<span class="w">    </span><span class="p">.</span><span class="n">functionality</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">soc_i2c_func</span><span class="p">,</span>
<span class="p">};</span>

<span class="c1">// 实际传输函数</span>
<span class="k">static</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="nf">soc_i2c_xfer</span><span class="p">(</span><span class="k">struct</span><span class="w"> </span><span class="nc">i2c_adapter</span><span class="w"> </span><span class="o">*</span><span class="n">adap</span><span class="p">,</span><span class="w"> </span>
<span class="w">                       </span><span class="k">struct</span><span class="w"> </span><span class="nc">i2c_msg</span><span class="w"> </span><span class="o">*</span><span class="n">msgs</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">num</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="kt">void</span><span class="w"> </span><span class="n">__iomem</span><span class="w"> </span><span class="o">*</span><span class="n">base</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">adap</span><span class="o">-&gt;</span><span class="n">algo_data</span><span class="p">;</span>

<span class="w">    </span><span class="c1">// 遍历每个消息</span>
<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">num</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">++</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="c1">// 设置从地址和方向</span>
<span class="w">        </span><span class="n">writel</span><span class="p">(</span><span class="n">msgs</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">addr</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="p">(</span><span class="n">msgs</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">flags</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span><span class="n">I2C_M_RD</span><span class="p">),</span><span class="w"> </span>
<span class="w">               </span><span class="n">base</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">I2C_ADDR_REG</span><span class="p">);</span>

<span class="w">        </span><span class="c1">// 写入数据（写操作）</span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">msgs</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">flags</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span><span class="n">I2C_M_RD</span><span class="p">))</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">j</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">j</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">msgs</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">len</span><span class="p">;</span><span class="w"> </span><span class="n">j</span><span class="o">++</span><span class="p">)</span>
<span class="w">                </span><span class="n">writeb</span><span class="p">(</span><span class="n">msgs</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">buf</span><span class="p">[</span><span class="n">j</span><span class="p">],</span><span class="w"> </span><span class="n">base</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">I2C_DATA_REG</span><span class="p">);</span>
<span class="w">        </span><span class="p">}</span>

<span class="w">        </span><span class="c1">// 触发传输</span>
<span class="w">        </span><span class="n">writel</span><span class="p">(</span><span class="n">CTRL_START</span><span class="p">,</span><span class="w"> </span><span class="n">base</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">I2C_CTRL_REG</span><span class="p">);</span>
<span class="w">        </span><span class="n">wait_for_completion</span><span class="p">(</span><span class="o">&amp;</span><span class="n">i2c_complete</span><span class="p">);</span><span class="w"> </span><span class="c1">// 等待中断</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">num</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>
<div class="highlight"><pre><span></span><code><span class="c1">// 单次写入寄存器</span>
<span class="n">i2c_smbus_write_byte_data</span><span class="p">(</span><span class="n">client</span><span class="p">,</span><span class="w"> </span><span class="n">reg</span><span class="p">,</span><span class="w"> </span><span class="n">value</span><span class="p">);</span>

<span class="c1">// 单次读取寄存器</span>
<span class="n">value</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">i2c_smbus_read_byte_data</span><span class="p">(</span><span class="n">client</span><span class="p">,</span><span class="w"> </span><span class="n">reg</span><span class="p">);</span>

<span class="c1">// 复杂传输（多个消息）</span>
<span class="k">struct</span><span class="w"> </span><span class="nc">i2c_msg</span><span class="w"> </span><span class="n">msg</span><span class="p">[]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="p">{</span><span class="w"> </span><span class="p">.</span><span class="n">addr</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">client</span><span class="o">-&gt;</span><span class="n">addr</span><span class="p">,</span><span class="w"> </span><span class="p">.</span><span class="n">flags</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="p">.</span><span class="n">len</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="p">.</span><span class="n">buf</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">write_buf</span><span class="w"> </span><span class="p">},</span><span class="w"> </span><span class="c1">// 写操作</span>
<span class="w">    </span><span class="p">{</span><span class="w"> </span><span class="p">.</span><span class="n">addr</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">client</span><span class="o">-&gt;</span><span class="n">addr</span><span class="p">,</span><span class="w"> </span><span class="p">.</span><span class="n">flags</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">I2C_M_RD</span><span class="p">,</span><span class="w"> </span><span class="p">.</span><span class="n">len</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">4</span><span class="p">,</span><span class="w"> </span><span class="p">.</span><span class="n">buf</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">read_buf</span><span class="w"> </span><span class="p">},</span><span class="w"> </span><span class="c1">// 读操作</span>
<span class="p">};</span>
<span class="n">ret</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">soc_i2c_xfer</span><span class="p">(</span><span class="n">client</span><span class="o">-&gt;</span><span class="n">adapter</span><span class="p">,</span><span class="w"> </span><span class="n">msg</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="p">);</span>
</code></pre></div>
</li>
</ul>
</li>
<li>
<p><strong>用户空间访问流程</strong></p>
<ul>
<li>
<p><strong>通过sysfs直接操作（调试用）</strong></p>
<div class="highlight"><pre><span></span><code><span class="c1"># 列出所有I2C总线</span>
ls<span class="w"> </span>/sys/class/i2c-dev/
<span class="c1"># 直接读写Camera寄存器</span>
i2cset<span class="w"> </span>-y<span class="w"> </span><span class="m">1</span><span class="w"> </span>0x3c<span class="w"> </span>0x3008<span class="w"> </span>0x80<span class="w">  </span><span class="c1"># 复位传感器</span>
i2cget<span class="w"> </span>-y<span class="w"> </span><span class="m">1</span><span class="w"> </span>0x3c<span class="w"> </span>0x300A<span class="w">       </span><span class="c1"># 读取芯片版本</span>
</code></pre></div>
</li>
<li>
<h5 id="v4l2"><strong>通过V4L2框架访问（标准方式）</strong></h5>
<div class="highlight"><pre><span></span><code><span class="c1">// 用户空间代码示例</span>
<span class="k">struct</span><span class="w"> </span><span class="nc">v4l2_format</span><span class="w"> </span><span class="n">fmt</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="p">.</span><span class="n">type</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">V4L2_BUF_TYPE_VIDEO_CAPTURE</span><span class="p">,</span>
<span class="w">    </span><span class="p">.</span><span class="n">fmt</span><span class="p">.</span><span class="n">pix</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="p">.</span><span class="n">width</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1920</span><span class="p">,</span><span class="w"> </span><span class="p">.</span><span class="n">height</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1080</span><span class="p">,</span><span class="w"> </span><span class="p">.</span><span class="n">pixelformat</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">V4L2_PIX_FMT_YUYV</span><span class="w"> </span><span class="p">}</span>
<span class="p">};</span>
<span class="n">ioctl</span><span class="p">(</span><span class="n">fd</span><span class="p">,</span><span class="w"> </span><span class="n">VIDIOC_S_FMT</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">fmt</span><span class="p">);</span>

<span class="c1">// 启动视频流</span>
<span class="k">struct</span><span class="w"> </span><span class="nc">v4l2_buffer</span><span class="w"> </span><span class="n">buf</span><span class="p">;</span>
<span class="n">ioctl</span><span class="p">(</span><span class="n">fd</span><span class="p">,</span><span class="w"> </span><span class="n">VIDIOC_REQBUFS</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">req</span><span class="p">);</span>
<span class="n">ioctl</span><span class="p">(</span><span class="n">fd</span><span class="p">,</span><span class="w"> </span><span class="n">VIDIOC_QBUF</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">buf</span><span class="p">);</span>
<span class="n">ioctl</span><span class="p">(</span><span class="n">fd</span><span class="p">,</span><span class="w"> </span><span class="n">VIDIOC_STREAMON</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">type</span><span class="p">);</span>
</code></pre></div>
</li>
</ul>
</li>
<li>
<p><strong>关键内核API与数据结构</strong></p>
<table>
<thead>
<tr>
<th style="text-align: left;"><strong>步骤</strong></th>
<th style="text-align: left;"><strong>代码路径</strong></th>
<th style="text-align: left;"><strong>核心函数/结构体</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: left;"><strong>设备树解析</strong></td>
<td style="text-align: left;"><code>drivers/of/platform.c</code></td>
<td style="text-align: left;"><code>of_platform_populate</code></td>
</tr>
<tr>
<td style="text-align: left;"><strong>Platform驱动注册</strong></td>
<td style="text-align: left;"><code>drivers/i2c/busses/i2c-vendor-controller.c</code></td>
<td style="text-align: left;"><code>platform_driver_register</code>, <code>i2c_add_adapter</code></td>
</tr>
<tr>
<td style="text-align: left;"><strong>I2C驱动注册</strong></td>
<td style="text-align: left;"><code>drivers/media/i2c/camera-sensor-driver.c</code></td>
<td style="text-align: left;"><code>i2c_register_driver</code>, <code>i2c_smbus_*</code></td>
</tr>
<tr>
<td style="text-align: left;"><strong>数据传输</strong></td>
<td style="text-align: left;"><code>drivers/i2c/i2c-core.c</code></td>
<td style="text-align: left;"><code>i2c_transfer</code>, <code>i2c_smbus_xfer</code></td>
</tr>
</tbody>
</table>
<table>
<thead>
<tr>
<th style="text-align: left;"><strong>组件</strong></th>
<th style="text-align: left;"><strong>API/数据结构</strong></th>
<th style="text-align: left;"><strong>作用</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: left;"><strong>Platform驱动</strong></td>
<td style="text-align: left;"><code>platform_driver</code></td>
<td style="text-align: left;">I2C控制器驱动注册</td>
</tr>
<tr>
<td style="text-align: left;"><strong>I2C适配器</strong></td>
<td style="text-align: left;"><code>i2c_add_adapter()</code></td>
<td style="text-align: left;">创建I2C总线（如i2c-1）</td>
</tr>
<tr>
<td style="text-align: left;"><strong>I2C设备驱动</strong></td>
<td style="text-align: left;"><code>i2c_driver.probe()</code></td>
<td style="text-align: left;">Camera设备初始化</td>
</tr>
<tr>
<td style="text-align: left;"><strong>数据传输</strong></td>
<td style="text-align: left;"><code>i2c_transfer()</code></td>
<td style="text-align: left;">底层I2C消息传输</td>
</tr>
<tr>
<td style="text-align: left;"><strong>V4L2集成</strong></td>
<td style="text-align: left;"><code>v4l2_subdev_ops</code></td>
<td style="text-align: left;">摄像头控制接口（曝光/对焦）</td>
</tr>
<tr>
<td style="text-align: left;"><strong>电源管理</strong></td>
<td style="text-align: left;"><code>dev_pm_ops</code></td>
<td style="text-align: left;">低功耗状态切换</td>
</tr>
</tbody>
</table>
</li>
<li>
<p><strong>调试</strong></p>
<ol>
<li>
<p><strong>查看设备树绑定状态</strong>：</p>
<div class="highlight"><pre><span></span><code>dtc<span class="w"> </span>-I<span class="w"> </span>fs<span class="w"> </span>/sys/firmware/devicetree/base<span class="w"> </span><span class="p">|</span><span class="w"> </span>grep<span class="w"> </span>-A<span class="w"> </span><span class="m">10</span><span class="w"> </span><span class="s2">&quot;i2c@400a0000&quot;</span>
</code></pre></div>
</li>
<li>
<p><strong>跟踪I2C通信</strong>：</p>
<div class="highlight"><pre><span></span><code><span class="nb">echo</span><span class="w"> </span><span class="m">1</span><span class="w"> </span>&gt;<span class="w"> </span>/sys/module/i2c_core/parameters/debug
dmesg<span class="w"> </span>-w<span class="w"> </span><span class="p">|</span><span class="w"> </span>grep<span class="w"> </span><span class="s2">&quot;i2c i2c-1&quot;</span>
</code></pre></div>
</li>
<li>
<p><strong>分析V4L2拓扑</strong>：</p>
<div class="highlight"><pre><span></span><code>media-ctl<span class="w"> </span>-p<span class="w"> </span>-d<span class="w"> </span>/dev/media0
</code></pre></div>
</li>
<li>
<p><strong>性能分析</strong>：</p>
<div class="highlight"><pre><span></span><code>perf<span class="w"> </span>trace<span class="w"> </span>-e<span class="w"> </span>i2c:i2c_read<span class="w"> </span>-e<span class="w"> </span>i2c:i2c_write
</code></pre></div>
</li>
</ol>
</li>
<li>
<p><strong>总结全流程</strong></p>
<ol>
<li><strong>设备树配置</strong>：<ul>
<li>描述I2C控制器和设备的硬件参数（地址、中断、时钟等）。</li>
<li>通过<code>compatible</code>字符串匹配驱动。</li>
</ul>
</li>
<li><strong>Platform总线与I2C控制器驱动</strong>：<ul>
<li>I2C控制器作为Platform设备，通过<code>platform_driver</code>注册。</li>
<li>在<code>probe</code>函数中初始化硬件并注册I2C适配器（<code>i2c_add_adapter</code>）。</li>
</ul>
</li>
<li><strong>I2C设备驱动</strong>：<ul>
<li>摄像头驱动通过<code>i2c_driver</code>注册，<code>probe</code>函数初始化设备并注册V4L2接口。</li>
<li>使用I2C核心层API（如<code>i2c_transfer</code>）进行数据传输。</li>
</ul>
</li>
<li><strong>数据传输流程</strong>：<ul>
<li>应用层调用V4L2接口 → 驱动层调用<code>i2c_smbus_write_byte_data</code> → I2C核心层 → I2C控制器驱动（<code>vendor_i2c_xfer</code>） → 硬件操作。</li>
</ul>
</li>
</ol>
<div class="highlight"><pre><span></span><code>flowchart TD
    A[硬件连接] --&gt; B[设备树描述]
    B --&gt; B1[I2C控制器节点]
    B --&gt; B2[I2C摄像头节点]

    B1 --&gt; C[Platform驱动注册]
    C --&gt; C1[vendor_i2c_probe]
    C1 --&gt; C2[注册I2C适配器i2c_add_adapter]

    B2 --&gt; D[I2C驱动注册]
    D --&gt; D1[camera_sensor_probe]
    D1 --&gt; D2[硬件初始化和V4L2注册]

    C2 --&gt; E[I2C核心层]
    D2 --&gt; E
    E --&gt; F[数据传输API调用]
    F --&gt; F1[i2c_transfer/i2c_smbus_*]
</code></pre></div>
</li>
</ol>
<h4 id="uart-uart">拓展 UART：从零开发 UART驱动全流程</h4>
<blockquote>
<h3 id="uart">从零开发UART驱动的完整流程</h3>
<hr />
<h4 id="_29"><strong>一、硬件架构与设备树配置</strong></h4>
<h5 id="1_4"><strong>1. 硬件连接</strong></h5>
<ul>
<li><strong>SoC内部UART控制器</strong>：集成在芯片内部，负责串行通信。</li>
<li><strong>外部引脚</strong>：通过TX（发送）和RX（接收）引脚连接外部设备（如传感器、调试器）。</li>
<li><strong>时钟源</strong>：UART控制器需要时钟信号（通常由SoC内部时钟模块提供）。</li>
</ul>
<div class="highlight"><pre><span></span><code>graph LR
    SoC[&quot;SoC&quot;] --&gt; UART_Ctrl[&quot;UART控制器&quot;]
    UART_Ctrl --&gt; TX_Pin[&quot;TX引脚&quot;]
    UART_Ctrl --&gt; RX_Pin[&quot;RX引脚&quot;]
    UART_Ctrl --&gt; IRQ_Line[&quot;中断线&quot;]
</code></pre></div>
<h5 id="2_5"><strong>2. 设备树配置</strong></h5>
<p>UART控制器作为<strong>Platform设备</strong>，需在设备树中声明其资源（寄存器地址、中断号、时钟等）。</p>
<div class="highlight"><pre><span></span><code><span class="c1">// 设备树节点示例（ARM SoC）</span>
<span class="nl">uart0</span><span class="p">:</span><span class="w"> </span><span class="nf">serial</span><span class="o">@</span><span class="mi">a00003f8</span><span class="cm"> </span><span class="p">{</span>
<span class="w">    </span><span class="kr">compatible</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">&quot;vendor,my-uart&quot;</span><span class="p">;</span><span class="w"> </span><span class="c1">// 匹配驱动</span>
<span class="w">    </span><span class="kr">reg</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">&lt;</span><span class="mh">0xa00003f8</span><span class="w"> </span><span class="mh">0x1000</span><span class="o">&gt;</span><span class="p">;</span><span class="w">     </span><span class="c1">// 寄存器地址范围</span>
<span class="w">    </span><span class="n">interrupts</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">&lt;</span><span class="mi">0</span><span class="w"> </span><span class="mi">32</span><span class="w"> </span><span class="na">IRQ_TYPE_LEVEL_HIGH</span><span class="o">&gt;</span><span class="p">;</span><span class="w"> </span><span class="c1">// 中断号及触发类型</span>
<span class="w">    </span><span class="n">clocks</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">&lt;&amp;</span><span class="na">uart_clk</span><span class="o">&gt;</span><span class="p">;</span><span class="w">          </span><span class="c1">// 时钟源</span>
<span class="w">    </span><span class="n">clock-frequency</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">&lt;</span><span class="mi">115200</span><span class="o">&gt;</span><span class="p">;</span><span class="w">    </span><span class="c1">// 波特率</span>
<span class="w">    </span><span class="kr">status</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">&quot;okay&quot;</span><span class="p">;</span><span class="w">               </span><span class="c1">// 启用设备</span>
<span class="p">};</span>
</code></pre></div>
<hr />
<h4 id="_30"><strong>二、驱动层次结构</strong></h4>
<h5 id="1-linux-tty"><strong>1. Linux TTY子系统架构</strong></h5>
<p>UART驱动基于TTY子系统，核心组件包括：
- <strong>tty_driver</strong>：管理TTY设备（如<code>/dev/ttyS0</code>）。
- <strong>uart_driver</strong>：封装UART硬件操作。
- <strong>uart_port</strong>：描述具体的UART端口（寄存器、中断等）。
- <strong>uart_ops</strong>：定义硬件操作函数（发送、接收、配置等）。</p>
<div class="highlight"><pre><span></span><code>graph TD
    UserSpace[用户空间] --&gt; TTY_Core[TTY核心层]
    TTY_Core --&gt; UART_Driver[UART驱动层]
    UART_Driver --&gt; UART_Port[UART硬件端口]
    UART_Port --&gt; UART_HW[UART控制器]
</code></pre></div>
<h5 id="2_6"><strong>2. 关键数据结构</strong></h5>
<div class="highlight"><pre><span></span><code><span class="c1">// UART驱动结构</span>
<span class="k">struct</span><span class="w"> </span><span class="nc">uart_driver</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">struct</span><span class="w"> </span><span class="nc">module</span><span class="w"> </span><span class="o">*</span><span class="n">owner</span><span class="p">;</span><span class="w">          </span><span class="c1">// 模块所有者</span>
<span class="w">    </span><span class="k">const</span><span class="w"> </span><span class="kt">char</span><span class="w"> </span><span class="o">*</span><span class="n">driver_name</span><span class="p">;</span><span class="w">       </span><span class="c1">// 驱动名称</span>
<span class="w">    </span><span class="kt">dev_t</span><span class="w"> </span><span class="n">major</span><span class="p">;</span><span class="w">                   </span><span class="c1">// 主设备号</span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">minor</span><span class="p">;</span><span class="w">                     </span><span class="c1">// 起始次设备号</span>
<span class="w">    </span><span class="k">struct</span><span class="w"> </span><span class="nc">console</span><span class="w"> </span><span class="o">*</span><span class="n">cons</span><span class="p">;</span><span class="w">          </span><span class="c1">// 控制台支持</span>
<span class="p">};</span>

<span class="c1">// UART端口结构</span>
<span class="k">struct</span><span class="w"> </span><span class="nc">uart_port</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">resource_size_t</span><span class="w"> </span><span class="n">mapbase</span><span class="p">;</span><span class="w">       </span><span class="c1">// 物理地址</span>
<span class="w">    </span><span class="kt">void</span><span class="w"> </span><span class="n">__iomem</span><span class="w"> </span><span class="o">*</span><span class="n">membase</span><span class="p">;</span><span class="w">         </span><span class="c1">// 映射后的虚拟地址</span>
<span class="w">    </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">irq</span><span class="p">;</span><span class="w">              </span><span class="c1">// 中断号</span>
<span class="w">    </span><span class="k">struct</span><span class="w"> </span><span class="nc">device</span><span class="w"> </span><span class="o">*</span><span class="n">dev</span><span class="p">;</span><span class="w">            </span><span class="c1">// 关联的设备</span>
<span class="w">    </span><span class="k">struct</span><span class="w"> </span><span class="nc">uart_ops</span><span class="w"> </span><span class="o">*</span><span class="n">ops</span><span class="p">;</span><span class="w">          </span><span class="c1">// 硬件操作函数集</span>
<span class="p">};</span>

<span class="c1">// 硬件操作函数集</span>
<span class="k">struct</span><span class="w"> </span><span class="nc">uart_ops</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="kt">void</span><span class="w"> </span><span class="p">(</span><span class="o">*</span><span class="n">start_tx</span><span class="p">)(</span><span class="k">struct</span><span class="w"> </span><span class="nc">uart_port</span><span class="w"> </span><span class="o">*</span><span class="p">);</span>
<span class="w">    </span><span class="kt">void</span><span class="w"> </span><span class="p">(</span><span class="o">*</span><span class="n">stop_tx</span><span class="p">)(</span><span class="k">struct</span><span class="w"> </span><span class="nc">uart_port</span><span class="w"> </span><span class="o">*</span><span class="p">);</span>
<span class="w">    </span><span class="c1">// ...其他操作函数</span>
<span class="p">};</span>
</code></pre></div>
<hr />
<h4 id="_31"><strong>三、驱动实现步骤</strong></h4>
<h5 id="1-uart"><strong>1. 初始化UART驱动</strong></h5>
<div class="highlight"><pre><span></span><code><span class="c1">// 定义UART驱动</span>
<span class="k">static</span><span class="w"> </span><span class="k">struct</span><span class="w"> </span><span class="nc">uart_driver</span><span class="w"> </span><span class="n">my_uart_driver</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="p">.</span><span class="n">owner</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">THIS_MODULE</span><span class="p">,</span>
<span class="w">    </span><span class="p">.</span><span class="n">driver_name</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">&quot;my_uart&quot;</span><span class="p">,</span>
<span class="w">    </span><span class="p">.</span><span class="n">major</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w">                    </span><span class="c1">// 动态分配主设备号</span>
<span class="w">    </span><span class="p">.</span><span class="n">minor</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">64</span><span class="p">,</span><span class="w">                    </span><span class="c1">// 起始次设备号</span>
<span class="w">    </span><span class="p">.</span><span class="n">cons</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">&amp;</span><span class="n">my_uart_console</span><span class="p">,</span><span class="w">       </span><span class="c1">// 控制台支持（可选）</span>
<span class="p">};</span>

<span class="c1">// 模块初始化</span>
<span class="k">static</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">__init</span><span class="w"> </span><span class="nf">my_uart_init</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">ret</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">uart_register_driver</span><span class="p">(</span><span class="o">&amp;</span><span class="n">my_uart_driver</span><span class="p">);</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">ret</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">pr_err</span><span class="p">(</span><span class="s">&quot;Failed to register UART driver</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="n">ret</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>
<h5 id="2_7"><strong>2. 实现硬件操作函数</strong></h5>
<div class="highlight"><pre><span></span><code><span class="k">static</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="k">struct</span><span class="w"> </span><span class="nc">uart_ops</span><span class="w"> </span><span class="n">my_uart_ops</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="p">.</span><span class="n">start_tx</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">my_uart_start_tx</span><span class="p">,</span>
<span class="w">    </span><span class="p">.</span><span class="n">stop_tx</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">my_uart_stop_tx</span><span class="p">,</span>
<span class="w">    </span><span class="p">.</span><span class="n">startup</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">my_uart_startup</span><span class="p">,</span>
<span class="w">    </span><span class="p">.</span><span class="n">shutdown</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">my_uart_shutdown</span><span class="p">,</span>
<span class="w">    </span><span class="p">.</span><span class="n">set_termios</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">my_uart_set_termios</span><span class="p">,</span>
<span class="p">};</span>

<span class="c1">// 发送数据函数</span>
<span class="k">static</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">my_uart_start_tx</span><span class="p">(</span><span class="k">struct</span><span class="w"> </span><span class="nc">uart_port</span><span class="w"> </span><span class="o">*</span><span class="n">port</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">struct</span><span class="w"> </span><span class="nc">circ_buf</span><span class="w"> </span><span class="o">*</span><span class="n">xmit</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">&amp;</span><span class="n">port</span><span class="o">-&gt;</span><span class="n">state</span><span class="o">-&gt;</span><span class="n">xmit</span><span class="p">;</span>
<span class="w">    </span><span class="k">while</span><span class="w"> </span><span class="p">(</span><span class="o">!</span><span class="n">uart_circ_empty</span><span class="p">(</span><span class="n">xmit</span><span class="p">))</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">writeb</span><span class="p">(</span><span class="n">xmit</span><span class="o">-&gt;</span><span class="n">buf</span><span class="p">[</span><span class="n">xmit</span><span class="o">-&gt;</span><span class="n">tail</span><span class="p">],</span><span class="w"> </span><span class="n">port</span><span class="o">-&gt;</span><span class="n">membase</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">UART_TX</span><span class="p">);</span>
<span class="w">        </span><span class="n">xmit</span><span class="o">-&gt;</span><span class="n">tail</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">xmit</span><span class="o">-&gt;</span><span class="n">tail</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="p">)</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span><span class="p">(</span><span class="n">UART_XMIT_SIZE</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mi">1</span><span class="p">);</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">}</span>

<span class="c1">// 接收中断处理</span>
<span class="k">static</span><span class="w"> </span><span class="n">irqreturn_t</span><span class="w"> </span><span class="nf">my_uart_irq</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">irq</span><span class="p">,</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="o">*</span><span class="n">dev_id</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">struct</span><span class="w"> </span><span class="nc">uart_port</span><span class="w"> </span><span class="o">*</span><span class="n">port</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">dev_id</span><span class="p">;</span>
<span class="w">    </span><span class="kt">char</span><span class="w"> </span><span class="n">ch</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">readb</span><span class="p">(</span><span class="n">port</span><span class="o">-&gt;</span><span class="n">membase</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">UART_RX</span><span class="p">);</span>
<span class="w">    </span><span class="n">tty_insert_flip_char</span><span class="p">(</span><span class="o">&amp;</span><span class="n">port</span><span class="o">-&gt;</span><span class="n">state</span><span class="o">-&gt;</span><span class="n">port</span><span class="p">,</span><span class="w"> </span><span class="n">ch</span><span class="p">,</span><span class="w"> </span><span class="n">TTY_NORMAL</span><span class="p">);</span>
<span class="w">    </span><span class="n">tty_flip_buffer_push</span><span class="p">(</span><span class="o">&amp;</span><span class="n">port</span><span class="o">-&gt;</span><span class="n">state</span><span class="o">-&gt;</span><span class="n">port</span><span class="p">);</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">IRQ_HANDLED</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>
<h5 id="3-platform"><strong>3. 注册Platform驱动</strong></h5>
<div class="highlight"><pre><span></span><code><span class="k">static</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="k">struct</span><span class="w"> </span><span class="nc">of_device_id</span><span class="w"> </span><span class="n">my_uart_of_match</span><span class="p">[]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="p">{</span><span class="w"> </span><span class="p">.</span><span class="n">compatible</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">&quot;vendor,my-uart&quot;</span><span class="w"> </span><span class="p">},</span>
<span class="w">    </span><span class="p">{}</span>
<span class="p">};</span>

<span class="k">static</span><span class="w"> </span><span class="k">struct</span><span class="w"> </span><span class="nc">platform_driver</span><span class="w"> </span><span class="n">my_uart_platform_driver</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="p">.</span><span class="n">probe</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">my_uart_probe</span><span class="p">,</span>
<span class="w">    </span><span class="p">.</span><span class="n">remove</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">my_uart_remove</span><span class="p">,</span>
<span class="w">    </span><span class="p">.</span><span class="n">driver</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="p">.</span><span class="n">name</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">&quot;my_uart&quot;</span><span class="p">,</span>
<span class="w">        </span><span class="p">.</span><span class="n">of_match_table</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">my_uart_of_match</span><span class="p">,</span>
<span class="w">    </span><span class="p">},</span>
<span class="p">};</span>

<span class="c1">// Probe函数（设备树匹配时调用）</span>
<span class="k">static</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="nf">my_uart_probe</span><span class="p">(</span><span class="k">struct</span><span class="w"> </span><span class="nc">platform_device</span><span class="w"> </span><span class="o">*</span><span class="n">pdev</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">struct</span><span class="w"> </span><span class="nc">uart_port</span><span class="w"> </span><span class="o">*</span><span class="n">port</span><span class="p">;</span>
<span class="w">    </span><span class="n">port</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">devm_kzalloc</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span><span class="w"> </span><span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">port</span><span class="p">),</span><span class="w"> </span><span class="n">GFP_KERNEL</span><span class="p">);</span>
<span class="w">    </span><span class="n">port</span><span class="o">-&gt;</span><span class="n">ops</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">&amp;</span><span class="n">my_uart_ops</span><span class="p">;</span>
<span class="w">    </span><span class="n">port</span><span class="o">-&gt;</span><span class="n">membase</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">ioremap</span><span class="p">(</span><span class="n">res</span><span class="o">-&gt;</span><span class="n">start</span><span class="p">,</span><span class="w"> </span><span class="n">resource_size</span><span class="p">(</span><span class="n">res</span><span class="p">));</span>
<span class="w">    </span><span class="n">port</span><span class="o">-&gt;</span><span class="n">irq</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">platform_get_irq</span><span class="p">(</span><span class="n">pdev</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">);</span>
<span class="w">    </span><span class="n">uart_add_one_port</span><span class="p">(</span><span class="o">&amp;</span><span class="n">my_uart_driver</span><span class="p">,</span><span class="w"> </span><span class="n">port</span><span class="p">);</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>
<hr />
<h4 id="_32"><strong>四、数据传输流程优化</strong></h4>
<h5 id="1_5"><strong>1. 使用环形缓冲区</strong></h5>
<ul>
<li><strong>发送缓冲区</strong>：<code>state-&gt;xmit</code>环形缓冲区存储待发送数据。</li>
<li><strong>接收缓冲区</strong>：通过<code>tty_insert_flip_char</code>写入TTY接收队列。</li>
</ul>
<h5 id="2_8"><strong>2. 中断优化</strong></h5>
<div class="highlight"><pre><span></span><code><span class="c1">// 改进的中断处理函数</span>
<span class="k">static</span><span class="w"> </span><span class="n">irqreturn_t</span><span class="w"> </span><span class="nf">my_uart_irq</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">irq</span><span class="p">,</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="o">*</span><span class="n">dev_id</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">struct</span><span class="w"> </span><span class="nc">uart_port</span><span class="w"> </span><span class="o">*</span><span class="n">port</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">dev_id</span><span class="p">;</span>
<span class="w">    </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">char</span><span class="w"> </span><span class="n">iir</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">readb</span><span class="p">(</span><span class="n">port</span><span class="o">-&gt;</span><span class="n">membase</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">UART_IIR</span><span class="p">);</span>
<span class="w">    </span>
<span class="w">    </span><span class="c1">// 处理接收中断</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">iir</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span><span class="n">UART_IIR_RX_TIMEOUT</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="k">while</span><span class="w"> </span><span class="p">(</span><span class="n">readb</span><span class="p">(</span><span class="n">port</span><span class="o">-&gt;</span><span class="n">membase</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">UART_LSR</span><span class="p">)</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span><span class="n">UART_LSR_DR</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="kt">char</span><span class="w"> </span><span class="n">ch</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">readb</span><span class="p">(</span><span class="n">port</span><span class="o">-&gt;</span><span class="n">membase</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">UART_RX</span><span class="p">);</span>
<span class="w">            </span><span class="n">tty_insert_flip_char</span><span class="p">(</span><span class="o">&amp;</span><span class="n">port</span><span class="o">-&gt;</span><span class="n">state</span><span class="o">-&gt;</span><span class="n">port</span><span class="p">,</span><span class="w"> </span><span class="n">ch</span><span class="p">,</span><span class="w"> </span><span class="n">TTY_NORMAL</span><span class="p">);</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">        </span><span class="n">tty_flip_buffer_push</span><span class="p">(</span><span class="o">&amp;</span><span class="n">port</span><span class="o">-&gt;</span><span class="n">state</span><span class="o">-&gt;</span><span class="n">port</span><span class="p">);</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span>
<span class="w">    </span><span class="c1">// 处理发送中断（FIFO空）</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">iir</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span><span class="n">UART_IIR_THRI</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">my_uart_start_tx</span><span class="p">(</span><span class="n">port</span><span class="p">);</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">IRQ_HANDLED</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>
<h5 id="3-dma"><strong>3. 集成DMA（示例）</strong></h5>
<div class="highlight"><pre><span></span><code><span class="c1">// DMA发送函数</span>
<span class="k">static</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">my_uart_start_tx_dma</span><span class="p">(</span><span class="k">struct</span><span class="w"> </span><span class="nc">uart_port</span><span class="w"> </span><span class="o">*</span><span class="n">port</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">struct</span><span class="w"> </span><span class="nc">circ_buf</span><span class="w"> </span><span class="o">*</span><span class="n">xmit</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">&amp;</span><span class="n">port</span><span class="o">-&gt;</span><span class="n">state</span><span class="o">-&gt;</span><span class="n">xmit</span><span class="p">;</span>
<span class="w">    </span><span class="n">dma_addr_t</span><span class="w"> </span><span class="n">dma_addr</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">dma_map_single</span><span class="p">(</span><span class="n">port</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span><span class="w"> </span><span class="n">xmit</span><span class="o">-&gt;</span><span class="n">buf</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">xmit</span><span class="o">-&gt;</span><span class="n">tail</span><span class="p">,</span>
<span class="w">                                         </span><span class="n">count</span><span class="p">,</span><span class="w"> </span><span class="n">DMA_TO_DEVICE</span><span class="p">);</span>
<span class="w">    </span><span class="k">struct</span><span class="w"> </span><span class="nc">dma_async_tx_descriptor</span><span class="w"> </span><span class="o">*</span><span class="n">desc</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">dmaengine_prep_slave_single</span><span class="p">(</span>
<span class="w">        </span><span class="n">port</span><span class="o">-&gt;</span><span class="n">tx_chan</span><span class="p">,</span><span class="w"> </span><span class="n">dma_addr</span><span class="p">,</span><span class="w"> </span><span class="n">count</span><span class="p">,</span><span class="w"> </span><span class="n">DMA_MEM_TO_DEV</span><span class="p">,</span><span class="w"> </span><span class="n">DMA_PREP_INTERRUPT</span><span class="p">);</span>
<span class="w">    </span><span class="n">desc</span><span class="o">-&gt;</span><span class="n">callback</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">my_uart_dma_tx_complete</span><span class="p">;</span>
<span class="w">    </span><span class="n">dmaengine_submit</span><span class="p">(</span><span class="n">desc</span><span class="p">);</span>
<span class="w">    </span><span class="n">dma_async_issue_pending</span><span class="p">(</span><span class="n">port</span><span class="o">-&gt;</span><span class="n">tx_chan</span><span class="p">);</span>
<span class="p">}</span>

<span class="c1">// DMA完成回调</span>
<span class="k">static</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">my_uart_dma_tx_complete</span><span class="p">(</span><span class="kt">void</span><span class="w"> </span><span class="o">*</span><span class="n">param</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">struct</span><span class="w"> </span><span class="nc">uart_port</span><span class="w"> </span><span class="o">*</span><span class="n">port</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">param</span><span class="p">;</span>
<span class="w">    </span><span class="n">dma_unmap_single</span><span class="p">(</span><span class="n">port</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span><span class="w"> </span><span class="n">port</span><span class="o">-&gt;</span><span class="n">tx_dma_addr</span><span class="p">,</span><span class="w"> </span><span class="n">port</span><span class="o">-&gt;</span><span class="n">tx_dma_size</span><span class="p">,</span><span class="w"> </span><span class="n">DMA_TO_DEVICE</span><span class="p">);</span>
<span class="w">    </span><span class="n">uart_write_wakeup</span><span class="p">(</span><span class="n">port</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div>
<hr />
<h4 id="_33"><strong>五、调试与验证</strong></h4>
<h5 id="1_6"><strong>1. 用户空间测试</strong></h5>
<div class="highlight"><pre><span></span><code><span class="c1"># 查看注册的串口设备</span>
ls<span class="w"> </span>/dev/ttyS*<span class="w"> </span>

<span class="c1"># 使用stty配置波特率</span>
stty<span class="w"> </span>-F<span class="w"> </span>/dev/ttyS0<span class="w"> </span><span class="m">115200</span>

<span class="c1"># 发送数据</span>
<span class="nb">echo</span><span class="w"> </span><span class="s2">&quot;Hello UART&quot;</span><span class="w"> </span>&gt;<span class="w"> </span>/dev/ttyS0

<span class="c1"># 接收数据</span>
cat<span class="w"> </span>/dev/ttyS0
</code></pre></div>
<h5 id="2_9"><strong>2. 调试技巧</strong></h5>
<ul>
<li><strong>查看内核日志</strong>：<code>dmesg | grep my_uart</code></li>
<li><strong>检查中断状态</strong>：<code>cat /proc/interrupts | grep uart</code></li>
<li><strong>调试DMA传输</strong>：<code>perf trace -e dma:*</code></li>
</ul>
<hr />
<h4 id="_34"><strong>六、总结</strong></h4>
<ul>
<li><strong>UART控制器作为Platform设备</strong>：需在设备树中静态配置寄存器地址和中断。</li>
<li><strong>与TTY子系统的集成</strong>：通过<code>uart_driver</code>和<code>tty_port</code>实现用户空间接口。</li>
<li><strong>性能关键点</strong>：使用环形缓冲区和DMA提升吞吐量，优化中断处理逻辑。</li>
<li><strong>可靠性保障</strong>：实现硬件流控（RTS/CTS）和错误检测（溢出、帧错误）。</li>
</ul>
<p>通过上述流程，可以完整实现一个支持设备树配置、中断驱动和DMA优化的UART驱动，满足嵌入式系统的实时性和可靠性需求。</p>
<h3 id="uart_1"><strong>UART驱动层与应用层数据传输流程详解</strong></h3>
<h4 id="1_7"><strong>1. 数据传输流程</strong></h4>
<p><strong>发送数据（应用层 → 硬件）：</strong>
1. <strong>用户空间调用<code>write()</code></strong>：应用程序通过系统调用将数据写入字符设备（如<code>/dev/ttyS0</code>）。
2. <strong>VFS转发到驱动</strong>：内核的虚拟文件系统（VFS）将请求路由到UART驱动的<code>tty_operations.write</code>函数。
3. <strong>驱动缓存管理</strong>：驱动将数据存入发送环形缓冲区（避免直接操作硬件寄存器）。
4. <strong>启动硬件传输</strong>：
   - 配置UART控制器的发送寄存器（如数据寄存器<code>UART_THR</code>）。
   - 若启用DMA，设置DMA描述符并触发传输。
5. <strong>中断处理</strong>：每个字节发送完成后触发中断，驱动检查状态寄存器（<code>UART_LSR</code>）并继续发送下一个字节，直至缓冲区清空。</p>
<p><strong>接收数据（硬件 → 应用层）：</strong></p>
<ol>
<li><strong>硬件触发接收中断</strong>：UART控制器检测到数据到达，触发接收中断（<code>UART_IIR_RX_TIMEOUT</code>或<code>UART_IIR_RX</code>）。</li>
<li><strong>中断处理程序读取数据</strong>：驱动从接收寄存器（<code>UART_RHR</code>）读取数据并存入接收环形缓冲区。</li>
<li><strong>唤醒用户进程</strong>：若应用层正在阻塞读取（<code>read()</code>），驱动通过<code>wake_up_interruptible()</code>唤醒进程。</li>
<li><strong>用户空间读取数据</strong>：应用程序通过<code>read()</code>系统调用从接收缓冲区获取数据。</li>
</ol>
<h4 id="2_10"><strong>2. 避免数据丢失的关键方法</strong></h4>
<ul>
<li><strong>双缓冲机制</strong>：</li>
<li><strong>发送端</strong>：维护环形缓冲区，确保应用层写入时不会覆盖未发送的数据。</li>
<li><strong>接收端</strong>：使用足够大的接收缓冲区（如4096字节），防止数据溢出。</li>
<li><strong>流量控制</strong>：</li>
<li><strong>硬件流控（RTS/CTS）</strong>：通过控制信号暂停发送方。</li>
<li><strong>软件流控（XON/XOFF）</strong>：发送特殊字符控制数据流。</li>
<li><strong>中断优化</strong>：</li>
<li><strong>合并中断</strong>：使用高水位标记（High Water Mark）减少中断频率。</li>
<li><strong>NAPI（New API）</strong>：类似网络驱动的轮询机制，减少中断开销。</li>
<li><strong>DMA传输</strong>：通过DMA批量传输数据，减少CPU中断处理次数。</li>
</ul>
<hr />
<h3 id="dma_3"><strong>DMA在驱动开发中的核心作用与实现</strong></h3>
<h4 id="1-dma"><strong>1. DMA的核心优势</strong></h4>
<ul>
<li><strong>降低CPU负载</strong>：数据传输由DMA控制器完成，CPU仅需初始化和监控。</li>
<li><strong>提升吞吐量</strong>：支持大块数据传输，减少硬件寄存器操作的次数。</li>
<li><strong>减少延迟</strong>：避免CPU频繁响应中断，提高实时性。</li>
</ul>
<h4 id="2-dmauart"><strong>2. DMA在UART驱动中的实现步骤</strong></h4>
<p><strong>步骤1：分配DMA缓冲区</strong>
<div class="highlight"><pre><span></span><code><span class="c1">// 分配一致性DMA内存（CPU和DMA控制器共享）</span>
<span class="n">dma_addr_t</span><span class="w"> </span><span class="n">dma_tx_handle</span><span class="p">,</span><span class="w"> </span><span class="n">dma_rx_handle</span><span class="p">;</span>
<span class="kt">void</span><span class="w"> </span><span class="o">*</span><span class="n">dma_tx_buf</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">dma_alloc_coherent</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span><span class="w"> </span><span class="n">BUF_SIZE</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">dma_tx_handle</span><span class="p">,</span><span class="w"> </span><span class="n">GFP_KERNEL</span><span class="p">);</span>
<span class="kt">void</span><span class="w"> </span><span class="o">*</span><span class="n">dma_rx_buf</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">dma_alloc_coherent</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span><span class="w"> </span><span class="n">BUF_SIZE</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">dma_rx_handle</span><span class="p">,</span><span class="w"> </span><span class="n">GFP_KERNEL</span><span class="p">);</span>
</code></pre></div></p>
<p><strong>步骤2：配置DMA通道</strong>
<div class="highlight"><pre><span></span><code><span class="c1">// 请求DMA通道（以TI UART为例）</span>
<span class="k">struct</span><span class="w"> </span><span class="nc">dma_chan</span><span class="w"> </span><span class="o">*</span><span class="n">tx_chan</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">dma_request_chan</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;tx&quot;</span><span class="p">);</span>
<span class="k">struct</span><span class="w"> </span><span class="nc">dma_chan</span><span class="w"> </span><span class="o">*</span><span class="n">rx_chan</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">dma_request_chan</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;rx&quot;</span><span class="p">);</span>

<span class="c1">// 配置发送描述符</span>
<span class="k">struct</span><span class="w"> </span><span class="nc">dma_async_tx_descriptor</span><span class="w"> </span><span class="o">*</span><span class="n">tx_desc</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">dmaengine_prep_slave_single</span><span class="p">(</span>
<span class="w">    </span><span class="n">tx_chan</span><span class="p">,</span><span class="w"> </span><span class="n">dma_tx_handle</span><span class="p">,</span><span class="w"> </span><span class="n">BUF_SIZE</span><span class="p">,</span><span class="w"> </span><span class="n">DMA_MEM_TO_DEV</span><span class="p">,</span><span class="w"> </span><span class="n">DMA_PREP_INTERRUPT</span><span class="p">);</span>

<span class="c1">// 配置接收描述符</span>
<span class="k">struct</span><span class="w"> </span><span class="nc">dma_async_tx_descriptor</span><span class="w"> </span><span class="o">*</span><span class="n">rx_desc</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">dmaengine_prep_slave_single</span><span class="p">(</span>
<span class="w">    </span><span class="n">rx_chan</span><span class="p">,</span><span class="w"> </span><span class="n">dma_rx_handle</span><span class="p">,</span><span class="w"> </span><span class="n">BUF_SIZE</span><span class="p">,</span><span class="w"> </span><span class="n">DMA_DEV_TO_MEM</span><span class="p">,</span><span class="w"> </span><span class="n">DMA_PREP_INTERRUPT</span><span class="p">);</span>
</code></pre></div></p>
<p><strong>步骤3：启动DMA传输</strong>
<div class="highlight"><pre><span></span><code><span class="c1">// 启动发送DMA</span>
<span class="n">dmaengine_submit</span><span class="p">(</span><span class="n">tx_desc</span><span class="p">);</span>
<span class="n">dma_async_issue_pending</span><span class="p">(</span><span class="n">tx_chan</span><span class="p">);</span>

<span class="c1">// 启动接收DMA（循环模式）</span>
<span class="n">dmaengine_submit</span><span class="p">(</span><span class="n">rx_desc</span><span class="p">);</span>
<span class="n">dma_async_issue_pending</span><span class="p">(</span><span class="n">rx_chan</span><span class="p">);</span>
</code></pre></div></p>
<p><strong>步骤4：处理DMA中断</strong>
<div class="highlight"><pre><span></span><code><span class="c1">// 注册DMA完成中断</span>
<span class="n">tx_desc</span><span class="o">-&gt;</span><span class="n">callback</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">dma_tx_complete_callback</span><span class="p">;</span>
<span class="n">rx_desc</span><span class="o">-&gt;</span><span class="n">callback</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">dma_rx_complete_callback</span><span class="p">;</span>

<span class="c1">// 中断处理函数</span>
<span class="k">static</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">dma_tx_complete_callback</span><span class="p">(</span><span class="kt">void</span><span class="w"> </span><span class="o">*</span><span class="n">data</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">pr_info</span><span class="p">(</span><span class="s">&quot;DMA发送完成！&quot;</span><span class="p">);</span>
<span class="w">    </span><span class="c1">// 通知应用层可继续写入</span>
<span class="p">}</span>

<span class="k">static</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">dma_rx_complete_callback</span><span class="p">(</span><span class="kt">void</span><span class="w"> </span><span class="o">*</span><span class="n">data</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">pr_info</span><span class="p">(</span><span class="s">&quot;DMA接收完成！&quot;</span><span class="p">);</span>
<span class="w">    </span><span class="c1">// 将数据从DMA缓冲区复制到内核接收缓冲区</span>
<span class="w">    </span><span class="n">memcpy</span><span class="p">(</span><span class="n">rx_kernel_buf</span><span class="p">,</span><span class="w"> </span><span class="n">dma_rx_buf</span><span class="p">,</span><span class="w"> </span><span class="n">BUF_SIZE</span><span class="p">);</span>
<span class="w">    </span><span class="n">wake_up_interruptible</span><span class="p">(</span><span class="o">&amp;</span><span class="n">read_queue</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></p>
<h4 id="3-dma_1"><strong>3. DMA开发中的关键注意事项</strong></h4>
<ul>
<li><strong>缓存一致性</strong>：</li>
<li>使用<code>dma_sync_single_for_device()</code>和<code>dma_sync_single_for_cpu()</code>同步缓存。</li>
<li><strong>内存对齐</strong>：</li>
<li>DMA缓冲区需按硬件要求对齐（如32字节边界）。</li>
<li><strong>错误处理</strong>：</li>
<li>检查DMA状态寄存器（如<code>DMA_SR</code>），处理传输错误和超时。</li>
<li><strong>性能调优</strong>：</li>
<li>调整DMA块大小（Burst Size）和传输宽度（Transfer Width）以匹配硬件能力。</li>
</ul>
<hr />
<h3 id="uartdma"><strong>代码示例：UART驱动中的DMA发送</strong></h3>
<div class="highlight"><pre><span></span><code><span class="k">static</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="nf">uart_start_tx_dma</span><span class="p">(</span><span class="k">struct</span><span class="w"> </span><span class="nc">uart_port</span><span class="w"> </span><span class="o">*</span><span class="n">port</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="kt">char</span><span class="w"> </span><span class="o">*</span><span class="n">buf</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">count</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="c1">// 映射用户空间数据到DMA地址</span>
<span class="w">    </span><span class="n">dma_addr_t</span><span class="w"> </span><span class="n">dma_addr</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">dma_map_single</span><span class="p">(</span><span class="n">port</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span><span class="w"> </span><span class="p">(</span><span class="kt">void</span><span class="w"> </span><span class="o">*</span><span class="p">)</span><span class="n">buf</span><span class="p">,</span><span class="w"> </span><span class="n">count</span><span class="p">,</span><span class="w"> </span><span class="n">DMA_TO_DEVICE</span><span class="p">);</span>
<span class="w">    </span>
<span class="w">    </span><span class="c1">// 配置DMA描述符</span>
<span class="w">    </span><span class="k">struct</span><span class="w"> </span><span class="nc">dma_async_tx_descriptor</span><span class="w"> </span><span class="o">*</span><span class="n">desc</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">dmaengine_prep_slave_single</span><span class="p">(</span>
<span class="w">        </span><span class="n">port</span><span class="o">-&gt;</span><span class="n">tx_chan</span><span class="p">,</span><span class="w"> </span><span class="n">dma_addr</span><span class="p">,</span><span class="w"> </span><span class="n">count</span><span class="p">,</span><span class="w"> </span><span class="n">DMA_MEM_TO_DEV</span><span class="p">,</span><span class="w"> </span><span class="n">DMA_PREP_INTERRUPT</span><span class="p">);</span>
<span class="w">    </span>
<span class="w">    </span><span class="c1">// 设置完成回调</span>
<span class="w">    </span><span class="n">desc</span><span class="o">-&gt;</span><span class="n">callback</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">uart_dma_tx_complete</span><span class="p">;</span>
<span class="w">    </span><span class="n">desc</span><span class="o">-&gt;</span><span class="n">callback_param</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">port</span><span class="p">;</span>
<span class="w">    </span>
<span class="w">    </span><span class="c1">// 提交并启动DMA</span>
<span class="w">    </span><span class="n">dmaengine_submit</span><span class="p">(</span><span class="n">desc</span><span class="p">);</span>
<span class="w">    </span><span class="n">dma_async_issue_pending</span><span class="p">(</span><span class="n">port</span><span class="o">-&gt;</span><span class="n">tx_chan</span><span class="p">);</span>
<span class="w">    </span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">uart_dma_tx_complete</span><span class="p">(</span><span class="kt">void</span><span class="w"> </span><span class="o">*</span><span class="n">param</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">struct</span><span class="w"> </span><span class="nc">uart_port</span><span class="w"> </span><span class="o">*</span><span class="n">port</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">param</span><span class="p">;</span>
<span class="w">    </span><span class="c1">// 解除DMA映射</span>
<span class="w">    </span><span class="n">dma_unmap_single</span><span class="p">(</span><span class="n">port</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span><span class="w"> </span><span class="n">port</span><span class="o">-&gt;</span><span class="n">tx_dma_addr</span><span class="p">,</span><span class="w"> </span><span class="n">port</span><span class="o">-&gt;</span><span class="n">tx_dma_size</span><span class="p">,</span><span class="w"> </span><span class="n">DMA_TO_DEVICE</span><span class="p">);</span>
<span class="w">    </span><span class="c1">// 通知上层传输完成</span>
<span class="w">    </span><span class="n">uart_write_wakeup</span><span class="p">(</span><span class="n">port</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div>
<hr />
<h3 id="_35"><strong>总结</strong></h3>
<ul>
<li><strong>UART数据传输流程</strong>：通过内核缓冲区和中断机制实现应用层与硬件的交互，关键点在于流量控制和缓冲区管理。</li>
<li><strong>DMA的核心价值</strong>：减少CPU负载，提升吞吐量，适用于高带宽或低延迟场景。</li>
<li><strong>实现要点</strong>：合理分配DMA缓冲区，配置传输参数，处理中断与错误，确保缓存一致性。</li>
</ul>
</blockquote>
<p>ysyx-port-Linux 别人写的Linux UART 驱动</p>
<blockquote>
<h3 id="uart_2"><strong>UART驱动实现详解</strong></h3>
<h4 id="1_8"><strong>1. 驱动架构与核心逻辑</strong></h4>
<p>该UART驱动基于Linux内核的串口核心框架（<code>serial_core</code>）实现，主要包含以下组件：</p>
<ul>
<li><strong><code>uart_driver</code></strong>：定义驱动名称、设备号、控制台支持等。</li>
<li><strong><code>uart_port</code></strong>：描述UART硬件端口（内存地址、中断号、时钟等）。</li>
<li><strong><code>uart_ops</code></strong>：实现UART操作函数（发送、接收、中断处理等）。</li>
<li><strong>平台驱动集成</strong>：通过<code>platform_driver</code>和<code>of_device_id</code>支持设备树匹配。</li>
</ul>
<h4 id="2_11"><strong>2. 数据传输流程</strong></h4>
<p><strong>发送数据（应用层 → 硬件）：</strong>
1. <strong>用户空间调用<code>write()</code></strong>：数据通过tty子系统传递到驱动。
2. <strong>驱动写入环形缓冲区</strong>：数据暂存于<code>state-&gt;xmit</code>环形缓冲区。
3. <strong>触发发送</strong>：调用<code>nemu_uart_start_tx</code>，逐个字符写入UART数据寄存器（<code>nemu_uart_putchar</code>）。
4. <strong>中断通知</strong>：发送完成后通过<code>uart_write_wakeup</code>唤醒等待进程。</p>
<p><strong>接收数据（硬件 → 应用层）：</strong>
1. <strong>接收中断触发</strong>：硬件检测到数据到达，触发中断。
2. <strong>读取数据</strong>：从UART数据寄存器读取字符（<code>readb(port-&gt;membase)</code>）。
3. <strong>推送至tty层</strong>：通过<code>tty_insert_flip_char</code>和<code>tty_flip_buffer_push</code>将数据传递到用户空间。</p>
<h4 id="3_3"><strong>3. 关键代码分析</strong></h4>
<h5 id="31"><strong>3.1 中断处理</strong></h5>
<p><div class="highlight"><pre><span></span><code><span class="k">static</span><span class="w"> </span><span class="n">irqreturn_t</span><span class="w"> </span><span class="nf">nemu_uart_irq</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">irq</span><span class="p">,</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="o">*</span><span class="n">dev_id</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">struct</span><span class="w"> </span><span class="nc">uart_port</span><span class="w"> </span><span class="o">*</span><span class="n">port</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">dev_id</span><span class="p">;</span>
<span class="w">    </span><span class="kt">char</span><span class="w"> </span><span class="n">ch</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">readb</span><span class="p">(</span><span class="n">port</span><span class="o">-&gt;</span><span class="n">membase</span><span class="p">);</span><span class="w"> </span><span class="c1">// 读取接收数据</span>
<span class="w">    </span><span class="n">tty_insert_flip_char</span><span class="p">(</span><span class="o">&amp;</span><span class="n">port</span><span class="o">-&gt;</span><span class="n">state</span><span class="o">-&gt;</span><span class="n">port</span><span class="p">,</span><span class="w"> </span><span class="n">ch</span><span class="p">,</span><span class="w"> </span><span class="n">TTY_NORMAL</span><span class="p">);</span>
<span class="w">    </span><span class="n">tty_flip_buffer_push</span><span class="p">(</span><span class="o">&amp;</span><span class="n">port</span><span class="o">-&gt;</span><span class="n">state</span><span class="o">-&gt;</span><span class="n">port</span><span class="p">);</span><span class="w"> </span><span class="c1">// 推送数据到tty层</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">IRQ_HANDLED</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>
- <strong>问题</strong>：未检查中断状态寄存器（如<code>UART_IIR</code>），无法区分接收中断、发送中断或错误中断。
- <strong>改进建议</strong>：根据中断类型处理不同事件（见下文优化示例）。</p>
<h5 id="32"><strong>3.2 发送函数</strong></h5>
<p><div class="highlight"><pre><span></span><code><span class="k">static</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">nemu_uart_start_tx</span><span class="p">(</span><span class="k">struct</span><span class="w"> </span><span class="nc">uart_port</span><span class="w"> </span><span class="o">*</span><span class="n">port</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">struct</span><span class="w"> </span><span class="nc">circ_buf</span><span class="w"> </span><span class="o">*</span><span class="n">xmit</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">&amp;</span><span class="n">port</span><span class="o">-&gt;</span><span class="n">state</span><span class="o">-&gt;</span><span class="n">xmit</span><span class="p">;</span>
<span class="w">    </span><span class="k">while</span><span class="w"> </span><span class="p">(</span><span class="o">!</span><span class="n">uart_circ_empty</span><span class="p">(</span><span class="n">xmit</span><span class="p">))</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="kt">char</span><span class="w"> </span><span class="n">ch</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">xmit</span><span class="o">-&gt;</span><span class="n">buf</span><span class="p">[</span><span class="n">xmit</span><span class="o">-&gt;</span><span class="n">tail</span><span class="p">];</span>
<span class="w">        </span><span class="n">nemu_uart_putchar</span><span class="p">(</span><span class="n">port</span><span class="p">,</span><span class="w"> </span><span class="n">ch</span><span class="p">);</span><span class="w"> </span><span class="c1">// 逐个字符写入硬件</span>
<span class="w">        </span><span class="n">xmit</span><span class="o">-&gt;</span><span class="n">tail</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">xmit</span><span class="o">-&gt;</span><span class="n">tail</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="p">)</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span><span class="p">(</span><span class="n">UART_XMIT_SIZE</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mi">1</span><span class="p">);</span>
<span class="w">        </span><span class="n">port</span><span class="o">-&gt;</span><span class="n">icount</span><span class="p">.</span><span class="n">tx</span><span class="o">++</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span><span class="n">uart_write_wakeup</span><span class="p">(</span><span class="n">port</span><span class="p">);</span><span class="w"> </span><span class="c1">// 唤醒等待进程</span>
<span class="p">}</span>
</code></pre></div>
- <strong>问题</strong>：逐个字符传输效率低，未利用FIFO或DMA。
- <strong>改进建议</strong>：使用DMA批量传输数据（见下文优化示例）。</p>
<h4 id="4-uart"><strong>4. 与标准UART流程的对比</strong></h4>
<table>
<thead>
<tr>
<th><strong>特性</strong></th>
<th><strong>当前实现</strong></th>
<th><strong>标准实现</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>中断处理</strong></td>
<td>仅处理接收中断，未区分中断类型</td>
<td>检查中断状态寄存器，处理多种中断源</td>
</tr>
<tr>
<td><strong>流量控制</strong></td>
<td>无硬件（RTS/CTS）或软件（XON/XOFF）流控</td>
<td>支持流控，防止数据丢失</td>
</tr>
<tr>
<td><strong>数据传输</strong></td>
<td>逐个字符写入，无DMA支持</td>
<td>使用DMA或FIFO批量传输</td>
</tr>
<tr>
<td><strong>错误处理</strong></td>
<td>未检测溢出、帧错误等</td>
<td>处理线路状态错误</td>
</tr>
</tbody>
</table>
<h4 id="5"><strong>5. 优化建议与示例</strong></h4>
<h5 id="51"><strong>5.1 完善中断处理</strong></h5>
<div class="highlight"><pre><span></span><code><span class="k">static</span><span class="w"> </span><span class="n">irqreturn_t</span><span class="w"> </span><span class="nf">nemu_uart_irq</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">irq</span><span class="p">,</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="o">*</span><span class="n">dev_id</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">struct</span><span class="w"> </span><span class="nc">uart_port</span><span class="w"> </span><span class="o">*</span><span class="n">port</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">dev_id</span><span class="p">;</span>
<span class="w">    </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">char</span><span class="w"> </span><span class="n">iir</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">readb</span><span class="p">(</span><span class="n">port</span><span class="o">-&gt;</span><span class="n">membase</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">UART_IIR</span><span class="p">);</span>

<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">iir</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span><span class="n">UART_IIR_NO_INT</span><span class="p">)</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="n">IRQ_NONE</span><span class="p">;</span>

<span class="w">    </span><span class="k">switch</span><span class="w"> </span><span class="p">(</span><span class="n">iir</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span><span class="n">UART_IIR_ID_MASK</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">case</span><span class="w"> </span><span class="no">UART_IIR_RX_TIMEOUT</span><span class="p">:</span><span class="w"> </span><span class="c1">// 接收中断</span>
<span class="w">        </span><span class="k">do</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="kt">char</span><span class="w"> </span><span class="n">ch</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">readb</span><span class="p">(</span><span class="n">port</span><span class="o">-&gt;</span><span class="n">membase</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">UART_RX</span><span class="p">);</span>
<span class="w">            </span><span class="n">tty_insert_flip_char</span><span class="p">(</span><span class="o">&amp;</span><span class="n">port</span><span class="o">-&gt;</span><span class="n">state</span><span class="o">-&gt;</span><span class="n">port</span><span class="p">,</span><span class="w"> </span><span class="n">ch</span><span class="p">,</span><span class="w"> </span><span class="n">TTY_NORMAL</span><span class="p">);</span>
<span class="w">        </span><span class="p">}</span><span class="w"> </span><span class="k">while</span><span class="w"> </span><span class="p">(</span><span class="n">readb</span><span class="p">(</span><span class="n">port</span><span class="o">-&gt;</span><span class="n">membase</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">UART_LSR</span><span class="p">)</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span><span class="n">UART_LSR_DR</span><span class="p">);</span>
<span class="w">        </span><span class="n">tty_flip_buffer_push</span><span class="p">(</span><span class="o">&amp;</span><span class="n">port</span><span class="o">-&gt;</span><span class="n">state</span><span class="o">-&gt;</span><span class="n">port</span><span class="p">);</span>
<span class="w">        </span><span class="k">break</span><span class="p">;</span>

<span class="w">    </span><span class="k">case</span><span class="w"> </span><span class="no">UART_IIR_THRI</span><span class="p">:</span><span class="w"> </span><span class="c1">// 发送中断</span>
<span class="w">        </span><span class="n">nemu_uart_start_tx</span><span class="p">(</span><span class="n">port</span><span class="p">);</span>
<span class="w">        </span><span class="k">break</span><span class="p">;</span>

<span class="w">    </span><span class="k">case</span><span class="w"> </span><span class="no">UART_IIR_MSI</span><span class="p">:</span><span class="w"> </span><span class="c1">// Modem状态变化</span>
<span class="w">        </span><span class="c1">// 更新CTS/RTS状态</span>
<span class="w">        </span><span class="k">break</span><span class="p">;</span>

<span class="w">    </span><span class="k">case</span><span class="w"> </span><span class="no">UART_IIR_RLSI</span><span class="p">:</span><span class="w"> </span><span class="c1">// 线路状态错误</span>
<span class="w">        </span><span class="c1">// 处理溢出、帧错误等</span>
<span class="w">        </span><span class="k">break</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">IRQ_HANDLED</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>
<h5 id="52-dma"><strong>5.2 引入DMA发送</strong></h5>
<div class="highlight"><pre><span></span><code><span class="k">static</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">nemu_uart_start_tx_dma</span><span class="p">(</span><span class="k">struct</span><span class="w"> </span><span class="nc">uart_port</span><span class="w"> </span><span class="o">*</span><span class="n">port</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">struct</span><span class="w"> </span><span class="nc">circ_buf</span><span class="w"> </span><span class="o">*</span><span class="n">xmit</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">&amp;</span><span class="n">port</span><span class="o">-&gt;</span><span class="n">state</span><span class="o">-&gt;</span><span class="n">xmit</span><span class="p">;</span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">count</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">CIRC_CNT_TO_END</span><span class="p">(</span><span class="n">xmit</span><span class="o">-&gt;</span><span class="n">head</span><span class="p">,</span><span class="w"> </span><span class="n">xmit</span><span class="o">-&gt;</span><span class="n">tail</span><span class="p">,</span><span class="w"> </span><span class="n">UART_XMIT_SIZE</span><span class="p">);</span>

<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">count</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span>
<span class="w">        </span><span class="k">return</span><span class="p">;</span>

<span class="w">    </span><span class="c1">// 映射DMA缓冲区</span>
<span class="w">    </span><span class="n">dma_addr_t</span><span class="w"> </span><span class="n">dma_addr</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">dma_map_single</span><span class="p">(</span><span class="n">port</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span><span class="w"> </span><span class="n">xmit</span><span class="o">-&gt;</span><span class="n">buf</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">xmit</span><span class="o">-&gt;</span><span class="n">tail</span><span class="p">,</span>
<span class="w">                                         </span><span class="n">count</span><span class="p">,</span><span class="w"> </span><span class="n">DMA_TO_DEVICE</span><span class="p">);</span>

<span class="w">    </span><span class="c1">// 配置DMA描述符</span>
<span class="w">    </span><span class="k">struct</span><span class="w"> </span><span class="nc">dma_async_tx_descriptor</span><span class="w"> </span><span class="o">*</span><span class="n">desc</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">dmaengine_prep_slave_single</span><span class="p">(</span>
<span class="w">        </span><span class="n">port</span><span class="o">-&gt;</span><span class="n">tx_chan</span><span class="p">,</span><span class="w"> </span><span class="n">dma_addr</span><span class="p">,</span><span class="w"> </span><span class="n">count</span><span class="p">,</span><span class="w"> </span><span class="n">DMA_MEM_TO_DEV</span><span class="p">,</span><span class="w"> </span><span class="n">DMA_PREP_INTERRUPT</span><span class="p">);</span>

<span class="w">    </span><span class="n">desc</span><span class="o">-&gt;</span><span class="n">callback</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">nemu_uart_dma_tx_complete</span><span class="p">;</span>
<span class="w">    </span><span class="n">desc</span><span class="o">-&gt;</span><span class="n">callback_param</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">port</span><span class="p">;</span>

<span class="w">    </span><span class="c1">// 提交并启动DMA</span>
<span class="w">    </span><span class="n">dmaengine_submit</span><span class="p">(</span><span class="n">desc</span><span class="p">);</span>
<span class="w">    </span><span class="n">dma_async_issue_pending</span><span class="p">(</span><span class="n">port</span><span class="o">-&gt;</span><span class="n">tx_chan</span><span class="p">);</span>

<span class="w">    </span><span class="n">xmit</span><span class="o">-&gt;</span><span class="n">tail</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">xmit</span><span class="o">-&gt;</span><span class="n">tail</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">count</span><span class="p">)</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span><span class="p">(</span><span class="n">UART_XMIT_SIZE</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mi">1</span><span class="p">);</span>
<span class="w">    </span><span class="n">port</span><span class="o">-&gt;</span><span class="n">icount</span><span class="p">.</span><span class="n">tx</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="n">count</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">nemu_uart_dma_tx_complete</span><span class="p">(</span><span class="kt">void</span><span class="w"> </span><span class="o">*</span><span class="n">param</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">struct</span><span class="w"> </span><span class="nc">uart_port</span><span class="w"> </span><span class="o">*</span><span class="n">port</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">param</span><span class="p">;</span>
<span class="w">    </span><span class="n">dma_unmap_single</span><span class="p">(</span><span class="n">port</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span><span class="w"> </span><span class="n">port</span><span class="o">-&gt;</span><span class="n">tx_dma_addr</span><span class="p">,</span><span class="w"> </span><span class="n">port</span><span class="o">-&gt;</span><span class="n">tx_dma_size</span><span class="p">,</span><span class="w"> </span><span class="n">DMA_TO_DEVICE</span><span class="p">);</span>
<span class="w">    </span><span class="n">uart_write_wakeup</span><span class="p">(</span><span class="n">port</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div>
<h4 id="6"><strong>6. 性能与可靠性优化</strong></h4>
<ul>
<li><strong>流量控制</strong>：在<code>nemu_uart_start_tx</code>中添加CTS检查：
  <div class="highlight"><pre><span></span><code><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">readb</span><span class="p">(</span><span class="n">port</span><span class="o">-&gt;</span><span class="n">membase</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">UART_MSR</span><span class="p">)</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span><span class="n">UART_MSR_CTS</span><span class="p">))</span>
<span class="w">    </span><span class="k">return</span><span class="p">;</span><span class="w"> </span><span class="c1">// CTS无效，暂停发送</span>
</code></pre></div></li>
<li><strong>错误处理</strong>：在中断中检测线路状态错误：</li>
</ul>
<div class="highlight"><pre><span></span><code><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">lsr</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span><span class="n">UART_LSR_OE</span><span class="p">)</span><span class="w"> </span><span class="c1">// 溢出错误</span>
<span class="w">    </span><span class="n">port</span><span class="o">-&gt;</span><span class="n">icount</span><span class="p">.</span><span class="n">overrun</span><span class="o">++</span><span class="p">;</span>
</code></pre></div>
<h4 id="7"><strong>7. 总结</strong></h4>
<p>该UART驱动实现了基本的串口通信功能，但存在以下改进空间：
1. <strong>中断处理</strong>：需支持多种中断类型和错误检测。
2. <strong>性能优化</strong>：引入DMA和FIFO批量传输。
3. <strong>可靠性增强</strong>：添加硬件流控和缓冲区管理。</p>
<p>通过上述优化，可显著提升驱动性能，避免数据丢失，并更好地适应高负载场景。</p>
</blockquote>
<h3 id="_36">电源管理</h3>
<p>核心看文档：<a href="https://docs.kernel.org/driver-api/pm/devices.html">Device Power Management Basics — The Linux Kernel documentation</a></p>
<div class="highlight"><pre><span></span><code>sequenceDiagram
    participant PM Core
    participant USB摄像头
    participant USB Hub
    participant USB控制器

    PM Core-&gt;&gt;USB摄像头: suspend()
    USB摄像头--&gt;&gt;PM Core: 确认挂起
    PM Core-&gt;&gt;USB Hub: suspend()
    USB Hub--&gt;&gt;PM Core: 确认挂起
    PM Core-&gt;&gt;USB控制器: suspend()
    USB控制器--&gt;&gt;PM Core: 确认挂起
</code></pre></div>
<p>电源管理，给计算机系统找一个合适的系统状态？避免温度过高直接烧坏。</p>
<p>下面主要讨论和 ARM 的资料，</p>
<h4 id="_37">电源管理的硬件架构</h4>
<p>由于 全志 H616 没有开放相关架构，用了一个比较老的图，但这和全志的区别不大，原理一样的。</p>
<p><img alt="image-20250321143044911" src="pic/image-20250321143044911.png" /></p>
<p>AP：Soc里，没画总线。PMIC。</p>
<p>掌握几个核心概念：</p>
<ul>
<li>
<p>一直不会掉电</p>
<p><code>PMU domain</code>、<code>always domain</code></p>
</li>
<li>
<p>会掉电，可关闭</p>
<p><code>PSO domain</code>、<code>shutdown domain</code></p>
</li>
</ul>
<p>静态功耗越来越高。</p>
<p>关键省电在于待机状态时，要关掉哪些模块？（比如听音乐）</p>
<p>比如手机：在什么都没用的时候，那就直接关到只有 CPU 是通电的，按需关模块省电。</p>
<blockquote>
<p>一个量级：如果 <code>PSO domain</code> 全开和全关，功耗大概在 10 倍数：<code>10mA</code> → <code>100/200 mA</code></p>
</blockquote>
<p>所以，补充一些电源管理的基础知识：</p>
<ul>
<li>
<p>功耗 = 动态功耗 + 静态功耗</p>
<p>动态功耗：0、1切换之间的功耗。</p>
<p>静态功耗：</p>
</li>
<li>
<p>电源域</p>
<p>由于上面的场景，不得不划分为每个模块供电划分区域，这个区域就叫<strong>电源域：独立地控制电源的开关、独立调整电压的区域。</strong></p>
</li>
<li>
<p>电压域</p>
<p>电压可以独立调节，但是不能关闭。</p>
</li>
<li>
<p>时钟域</p>
<p>clock gating</p>
<p>这个模块时钟是否可以单独控制的。</p>
<p>比如之前的架构图，那个网卡 master 和 MAC 和 slave 可以用3个时钟域来管理。</p>
</li>
<li>
<p>动态调频调压（DVFS）</p>
<p>每一个模块的电压供电有范围的，可以动态调整。</p>
</li>
</ul>
<p>具体看外部供电模块就是DC/DC、LDO。</p>
<p>具体例子，当我不需要 3D 模块的时候，直接把 3D 关掉，具体关：上图左上角连到3D 的那个 DC/DC（EN脚），具体对应到Linux 内核中是一个 regulator（LDO、DC/DC都是）。</p>
<p>但是仅仅开关3D是不够的，如果说把 ARM 关掉？需要软硬件协同。</p>
<p>PMIC 作为一个上电一直运行的模块，实际上叫做 <code>Multi-funcition-device</code>，具体是多个device 耦合在一起的设备，PMIC 就是。</p>
<ul>
<li>
<p>Cortex-A53 power domain</p>
<p><strong><mark>TODO</mark></strong></p>
<p>看手册，还要结合 计组/体系结构的一些内容。</p>
<p>《ARM®Cortex®-A53 MPCore Processor——2.4 power management》</p>
<p><img alt="image-20250321170652693" src="pic/image-20250321170652693.png" /></p>
</li>
</ul>
<p>正常情况下，要关闭别的模块以省电都是通过 ARM CPU 核心执行，通过 I2C 总线传递控制，给 PMIC，以关闭各个模块。</p>
<p>但关闭CPU core 的时候，就有个问题，要把 CPU 断电，那就要 cache 的数据、驱动等等内容都刷到内存保存下来，那怎么执行再把电源关掉？因为执行的时候不可避免地要把使用 cache。</p>
<p>这个时候需要用到 PMU：长上电区。</p>
<p>当ARM 做好断电前的一系列准备的时候，就会告诉 PMU 准备做好断电，这个时候 PMU 就会自己去控制 I2C bus，然后在 PMIC 里关掉 ARM CPU core 的供电的 DC/DC，之后再把其他的内容都断电。</p>
<p>大体就是这么个流程。再具体一点，ARM是怎么通知PMU的呢？<code>WFI</code> 指令。</p>
<p><strong><code>WFI</code> 之后具体发生了什么？（都是什么）</strong></p>
<ul>
<li>CPU standby/retention</li>
<li>CPU 下电</li>
<li>cluster 下电</li>
<li>系统关机</li>
</ul>
<p>实际看看实际的 Soc的设备有哪几个电源和设备树怎么写的：</p>
<p><code>arch/arm64/boot/dts/allwinner/sun50i-h616-orangepi-zero2.dts</code></p>
<p><img src="pic/image-20250314111632204.png" alt="image-20250314111632204" style="zoom: 67%;" /></p>
<p>每一个GPIO的供电是不一样的，对应到硬件设计不同（LDO、DCDC：带负载能力和电流大小）</p>
<p>比如那个 PG口，选的是 <code>bldo1</code>，对应到设备树是 1.8 V</p>
<p>对应代码：<code>arch/arm64/boot/dts/allwinner/sun50i-h616-orangepi-zero2.dts</code>，不同版本 kernel 可能不同。</p>
<p><img alt="image-20250314111606527" src="pic/image-20250314111606527.png" /></p>
<p><img src="pic/image-20250314112054241.png" alt="image-20250314112054241" style="zoom:67%;" /></p>
<p>由于上面的regulator比较混乱，既有 ldo、DC/DC、I2C、RTC、按键等等模块，具有多个功能，所以，内核用一个叫 MFD 的东西来管理。</p>
<p>那具体 pmic 怎么和 MFD 对应？<code>struct mfd_cell</code>、<code>drivers/mfd/axp20x.c</code></p>
<div class="highlight"><pre><span></span><code><span class="k">static</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="k">struct</span><span class="w"> </span><span class="nc">mfd_cell</span><span class="w"> </span><span class="n">axp806_self_working_cells</span><span class="p">[]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="p">.</span><span class="n">name</span><span class="w">       </span><span class="o">=</span><span class="w"> </span><span class="s">&quot;axp221-pek&quot;</span><span class="p">,</span>
<span class="w">        </span><span class="p">.</span><span class="n">num_resources</span><span class="w">  </span><span class="o">=</span><span class="w"> </span><span class="n">ARRAY_SIZE</span><span class="p">(</span><span class="n">axp806_pek_resources</span><span class="p">),</span>
<span class="w">        </span><span class="p">.</span><span class="n">resources</span><span class="w">  </span><span class="o">=</span><span class="w"> </span><span class="n">axp806_pek_resources</span><span class="p">,</span>
<span class="w">    </span><span class="p">},</span>
<span class="w">    </span><span class="p">{</span><span class="w">   </span><span class="p">.</span><span class="n">name</span><span class="w">       </span><span class="o">=</span><span class="w"> </span><span class="s">&quot;axp20x-regulator&quot;</span><span class="w"> </span><span class="p">},</span>
<span class="p">};</span>

<span class="k">static</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="k">struct</span><span class="w"> </span><span class="nc">mfd_cell</span><span class="w"> </span><span class="n">axp806_cells</span><span class="p">[]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="p">.</span><span class="n">id</span><span class="w">     </span><span class="o">=</span><span class="w"> </span><span class="mi">2</span><span class="p">,</span>
<span class="w">        </span><span class="p">.</span><span class="n">name</span><span class="w">       </span><span class="o">=</span><span class="w"> </span><span class="s">&quot;axp20x-regulator&quot;</span><span class="p">,</span>
<span class="w">    </span><span class="p">},</span>
<span class="p">};</span>
</code></pre></div>
<p><code>drivers/regulator/axp20x-regulator.c</code></p>
<div class="highlight"><pre><span></span><code><span class="w"> </span><span class="k">static</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="nf">axp20x_regulator_probe</span><span class="p">(</span><span class="k">struct</span><span class="w"> </span><span class="nc">platform_device</span><span class="w"> </span><span class="o">*</span><span class="n">pdev</span><span class="p">)</span>
<span class="w"> </span><span class="p">{</span>
<span class="w">     </span><span class="k">struct</span><span class="w"> </span><span class="nc">regulator_dev</span><span class="w"> </span><span class="o">*</span><span class="n">rdev</span><span class="p">;</span>
<span class="w">     </span><span class="k">struct</span><span class="w"> </span><span class="nc">axp20x_dev</span><span class="w"> </span><span class="o">*</span><span class="n">axp20x</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">dev_get_drvdata</span><span class="p">(</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">.</span><span class="n">parent</span><span class="p">);</span>
<span class="w">     </span><span class="k">const</span><span class="w"> </span><span class="k">struct</span><span class="w"> </span><span class="nc">regulator_desc</span><span class="w"> </span><span class="o">*</span><span class="n">regulators</span><span class="p">;</span>
<span class="w">     </span><span class="k">struct</span><span class="w"> </span><span class="nc">regulator_config</span><span class="w"> </span><span class="n">config</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span>
<span class="w">         </span><span class="p">.</span><span class="n">dev</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">.</span><span class="n">parent</span><span class="p">,</span>
<span class="w">         </span><span class="p">.</span><span class="n">regmap</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">axp20x</span><span class="o">-&gt;</span><span class="n">regmap</span><span class="p">,</span>
<span class="w">         </span><span class="p">.</span><span class="n">driver_data</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">axp20x</span><span class="p">,</span>
<span class="w">     </span><span class="p">};</span>
<span class="w">     </span><span class="kt">int</span><span class="w"> </span><span class="n">ret</span><span class="p">,</span><span class="w"> </span><span class="n">i</span><span class="p">,</span><span class="w"> </span><span class="n">nregulators</span><span class="p">;</span>
<span class="w">     </span><span class="n">u32</span><span class="w"> </span><span class="n">workmode</span><span class="p">;</span>
<span class="w">     </span><span class="k">const</span><span class="w"> </span><span class="kt">char</span><span class="w"> </span><span class="o">*</span><span class="n">dcdc1_name</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">axp22x_regulators</span><span class="p">[</span><span class="n">AXP22X_DCDC1</span><span class="p">].</span><span class="n">name</span><span class="p">;</span>
<span class="w">     </span><span class="k">const</span><span class="w"> </span><span class="kt">char</span><span class="w"> </span><span class="o">*</span><span class="n">dcdc5_name</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">axp22x_regulators</span><span class="p">[</span><span class="n">AXP22X_DCDC5</span><span class="p">].</span><span class="n">name</span><span class="p">;</span>
<span class="w">     </span><span class="k">const</span><span class="w"> </span><span class="kt">char</span><span class="w"> </span><span class="o">*</span><span class="n">aldo1_name</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">axp15060_regulators</span><span class="p">[</span><span class="n">AXP15060_ALDO1</span><span class="p">].</span><span class="n">name</span><span class="p">;</span>
<span class="w">     </span><span class="kt">bool</span><span class="w"> </span><span class="n">drivevbus</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">false</span><span class="p">;</span>

<span class="w">     </span><span class="k">switch</span><span class="w"> </span><span class="p">(</span><span class="n">axp20x</span><span class="o">-&gt;</span><span class="n">variant</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">     </span><span class="k">case</span><span class="w"> </span><span class="no">AXP202_ID</span><span class="p">:</span>
<span class="w">     </span><span class="k">case</span><span class="w"> </span><span class="no">AXP209_ID</span><span class="p">:</span>
<span class="w">         </span><span class="n">regulators</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">axp20x_regulators</span><span class="p">;</span>
<span class="w">         </span><span class="n">nregulators</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">AXP20X_REG_ID_MAX</span><span class="p">;</span>
<span class="w">         </span><span class="k">break</span><span class="p">;</span>
<span class="w">     </span><span class="k">case</span><span class="w"> </span><span class="no">AXP221_ID</span><span class="p">:</span>
<span class="w">     </span><span class="k">case</span><span class="w"> </span><span class="no">AXP223_ID</span><span class="p">:</span>
<span class="w">         </span><span class="n">regulators</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">axp22x_regulators</span><span class="p">;</span>
<span class="w">         </span><span class="n">nregulators</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">AXP22X_REG_ID_MAX</span><span class="p">;</span>
<span class="w">         </span><span class="n">drivevbus</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">of_property_read_bool</span><span class="p">(</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">.</span><span class="n">parent</span><span class="o">-&gt;</span><span class="n">of_node</span><span class="p">,</span>
<span class="w">                           </span><span class="s">&quot;x-powers,drive-vbus-en&quot;</span><span class="p">);</span>
<span class="w">         </span><span class="k">break</span><span class="p">;</span><span class="w">         </span>
<span class="w">      </span><span class="p">....</span>
<span class="w">     </span><span class="p">}</span>
<span class="w">     </span><span class="p">....</span>
<span class="w"> </span><span class="p">}</span>

<span class="k">static</span><span class="w"> </span><span class="k">struct</span><span class="w"> </span><span class="nc">platform_driver</span><span class="w"> </span><span class="n">axp20x_regulator_driver</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="p">.</span><span class="n">probe</span><span class="w">  </span><span class="o">=</span><span class="w"> </span><span class="n">axp20x_regulator_probe</span><span class="p">,</span><span class="w">                                                                                    </span>
<span class="w">    </span><span class="p">.</span><span class="n">driver</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="p">.</span><span class="n">name</span><span class="w">       </span><span class="o">=</span><span class="w"> </span><span class="s">&quot;axp20x-regulator&quot;</span><span class="p">,</span>
<span class="w">        </span><span class="p">.</span><span class="n">probe_type</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">PROBE_PREFER_ASYNCHRONOUS</span><span class="p">,</span>
<span class="w">    </span><span class="p">},</span>
<span class="p">};</span>
</code></pre></div>
<p>具体使用：以 mmc 驱动为例 <code>drivers/mmc/core/regulator.c</code> 和设备树 <code>arch/arm64/boot/dts/allwinner/sun50i-h616-orangepi-zero2.dts</code> （由于目前手上还没有板子，只能看这个） </p>
<p><img alt="image-20250321164709850" src="pic/image-20250321164709850.png" /></p>
<p>比如mmc0 的供电是用的DC/DCe来供电的，而mmc1用的是 wifi 的供电。</p>
<p><strong>根据这个声明，在内核中就能得到 power supply，由此来控制电源的开关。</strong></p>
<div class="highlight"><pre><span></span><code><span class="cm">/**</span>
<span class="cm"> * mmc_regulator_get_supply - try to get VMMC and VQMMC regulators for a host</span>
<span class="cm"> * @mmc: the host to regulate</span>
<span class="cm"> *</span>
<span class="cm"> * Returns 0 or errno. errno should be handled, it is either a critical error</span>
<span class="cm"> * or -EPROBE_DEFER. 0 means no critical error but it does not mean all</span>
<span class="cm"> * regulators have been found because they all are optional. If you require</span>
<span class="cm"> * certain regulators, you need to check separately in your driver if they got</span>
<span class="cm"> * populated after calling this function.</span>
<span class="cm"> */</span>
<span class="kt">int</span><span class="w"> </span><span class="nf">mmc_regulator_get_supply</span><span class="p">(</span><span class="k">struct</span><span class="w"> </span><span class="nc">mmc_host</span><span class="w"> </span><span class="o">*</span><span class="n">mmc</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">    </span><span class="k">struct</span><span class="w"> </span><span class="nc">device</span><span class="w"> </span><span class="o">*</span><span class="n">dev</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">mmc_dev</span><span class="p">(</span><span class="n">mmc</span><span class="p">);</span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">ret</span><span class="p">;</span>

<span class="w">    </span><span class="n">mmc</span><span class="o">-&gt;</span><span class="n">supply</span><span class="p">.</span><span class="n">vmmc</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">devm_regulator</span><span class="w"> </span><span class="n">get_optional</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;vmmc&quot;</span><span class="p">);</span>
<span class="w">    </span><span class="n">mmc</span><span class="o">-&gt;</span><span class="n">supply</span><span class="p">.</span><span class="n">vqmmc</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">devm_regulator_get_optional</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;vqmmc&quot;</span><span class="p">);</span>

<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">mmc</span><span class="o">-&gt;</span><span class="n">supply</span><span class="p">.</span><span class="n">vmmc</span><span class="p">))</span><span class="w"> </span><span class="p">{</span><span class="w">                                                                                                                                                </span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">PTR_ERR</span><span class="p">(</span><span class="n">mmc</span><span class="o">-&gt;</span><span class="n">supply</span><span class="p">.</span><span class="n">vmmc</span><span class="p">)</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="o">-</span><span class="n">EPROBE_DEFER</span><span class="p">)</span>
<span class="w">            </span><span class="k">return</span><span class="w"> </span><span class="o">-</span><span class="n">EPROBE_DEFER</span><span class="p">;</span>
<span class="w">        </span><span class="n">dev_dbg</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;No vmmc regulator found</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
<span class="w">    </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="p">{</span><span class="w">  </span>
<span class="w">        </span><span class="n">ret</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">mmc_regulator_get_ocrmask</span><span class="p">(</span><span class="n">mmc</span><span class="o">-&gt;</span><span class="n">supply</span><span class="p">.</span><span class="n">vmmc</span><span class="p">);</span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">ret</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span>
<span class="w">            </span><span class="n">mmc</span><span class="o">-&gt;</span><span class="n">ocr_avail</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">ret</span><span class="p">;</span>
<span class="w">        </span><span class="k">else</span>
<span class="w">            </span><span class="n">dev_warn</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;Failed getting OCR mask: %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">ret</span><span class="p">);</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">mmc</span><span class="o">-&gt;</span><span class="n">supply</span><span class="p">.</span><span class="n">vqmmc</span><span class="p">))</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">PTR_ERR</span><span class="p">(</span><span class="n">mmc</span><span class="o">-&gt;</span><span class="n">supply</span><span class="p">.</span><span class="n">vqmmc</span><span class="p">)</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="o">-</span><span class="n">EPROBE_DEFER</span><span class="p">)</span>
<span class="w">            </span><span class="k">return</span><span class="w"> </span><span class="o">-</span><span class="n">EPROBE_DEFER</span><span class="p">;</span>
<span class="w">        </span><span class="n">dev_dbg</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;No vqmmc regulator found</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">mmc_regulator_get_supply</span><span class="p">);</span><span class="w">     </span>
</code></pre></div>
<p>这个pm的行为就是这样的。</p>
<p>具体再看看文档：<code>Documentation/power/regulator/overview.rst</code>。</p>
<h4 id="linux_4">Linux 的 电源管理框架</h4>
<p>还是之前那个总线那个图。</p>
<p>上面的内容还是比较偏硬件的，这里再看看软件层面的。基本分成这个几个，从上到下越来越省电，同时唤醒时间也越长，除了运行时电源管理，剩余的四个都是比较影响系统运行的。</p>
<ul>
<li>
<p>runtime pm</p>
<p>系统运行时，当设备不用的话就直接关掉。比如听音乐、音频模块、视频编解码模块</p>
</li>
<li>
<p>suspend-to-Idle</p>
<p>还是纯软件的内容，比较通用。 </p>
<p>这个模块就是让所有模块都是休眠状态。</p>
</li>
<li>
<p>standby</p>
<p>和上面的那个比较类似，只是standby能够借助硬件关闭一些额外的电源和时钟，依赖于硬件注册的回调函数。</p>
</li>
<li>
<p>suspend-to-RAM</p>
<p>这个就是手机里通常最常用的低功耗模式。比如怎么做到待机两周？2000mA的电池就能维持很久，大概功耗就是几到十几 mA。</p>
<p>具体和上面的区别。就是保存 <code>PSO domain</code> 的内容，保存到 DDR 里（比如cache的数据、CPU 的 register 状态等等）。</p>
<p>这里有个 有意思的地方，就是DDR需要不断地刷新，那系统正常运行的时候，这个DDR是由 DDRC刷新的（这样子功耗比较大），而在这个级别下，需要让 DDR 进入一个自刷新的状态。（为什么平时这么做不好？刷新相当于是读写，又把数据重新写一遍也是有性能开销的，而DDRC是会和这个错开，写过就不会再写了。）</p>
<p><img src="pic/image-20250321172807972.png" alt="image-20250321172807972" style="zoom:67%;" /></p>
<p>具体唤醒就比较久，不会瞬间醒来，具体硬件具体分析，大概几个到几十毫秒。</p>
</li>
<li>
<p>hibernation</p>
<p>还有一个更省电的，保存到硬盘。</p>
<p>之前的状态都是保存到内存，唤醒再从内存，这个是保存到硬盘里？</p>
<p>要唤醒的话，需要把数据从硬盘中读回到内存中，这样时间更久。</p>
</li>
</ul>
<h4 id="linux_5">Linux 的休眠唤醒</h4>
<h4 id="linux_6">Linux 的唤醒源</h4>
<h4 id="linux_7">Linux 唤醒演示实验</h4>
<p>配合板子</p>
<div class="highlight"><pre><span></span><code>find<span class="w"> </span>/sys/devices<span class="w"> </span>-wholename<span class="w"> </span><span class="s1">&#39;*power/wakeup&#39;</span>
<span class="nb">echo</span><span class="w"> </span><span class="nb">enable</span><span class="w"> </span>&gt;<span class="w"> </span>/sys/devices/platform/soc/5000000.serial/tty/ttyS0/power/wakeup
cat<span class="w"> </span>/sys/power/mem_sleep

<span class="nb">echo</span><span class="w"> </span>s2idle<span class="w"> </span>&gt;<span class="w"> </span>/sys/power/meme_sleep
<span class="nb">echo</span><span class="w"> </span>mem<span class="w"> </span>&gt;<span class="w"> </span>/sys/power/state
</code></pre></div>
<h4 id="_38">具体流程</h4>
<ol>
<li>
<p><strong>硬件架构核心概念化</strong></p>
<ol>
<li>
<p><strong>PMIC与SoC的协作关系</strong>：</p>
<ul>
<li>
<p>PMIC是独立芯片（如AXP系列），通过I2C/SPI与SoC通信</p>
</li>
<li>
<p>典型工作流程：</p>
<p>复制</p>
<div class="highlight"><pre><span></span><code>CPU执行WFI指令 → PMU接管 → PMIC关闭CPU电源 → 维持Always-on域供电
</code></pre></div>
</li>
</ul>
</li>
<li>
<p><strong>电源域实战分析</strong>：</p>
<ul>
<li>
<p>Allwinner H616设备树示例：</p>
<div class="highlight"><pre><span></span><code><span class="o">&amp;</span><span class="na">reg_dcdc1</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">regulator-name</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">&quot;vdd-sys&quot;</span><span class="p">;</span>
<span class="w">    </span><span class="n">regulator-min-microvolt</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">&lt;</span><span class="mi">810000</span><span class="o">&gt;</span><span class="p">;</span>
<span class="w">    </span><span class="n">regulator-max-microvolt</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">&lt;</span><span class="mi">1100000</span><span class="o">&gt;</span><span class="p">;</span>
<span class="p">};</span>
</code></pre></div>
</li>
<li>
<p>电源域划分原则：</p>
<ul>
<li>Always-on域：RTC、PMIC、关键IO</li>
<li>Shutdown域：CPU核心、外设模块</li>
</ul>
</li>
</ul>
</li>
<li>
<p><strong>动态调压案例</strong>：</p>
<div class="highlight"><pre><span></span><code><span class="c1">// 调整CPU电压</span>
<span class="kt">int</span><span class="w"> </span><span class="nf">set_cpu_voltage</span><span class="p">(</span><span class="k">struct</span><span class="w"> </span><span class="nc">regulator</span><span class="w"> </span><span class="o">*</span><span class="n">reg</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">uv</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">regulator_set_voltage</span><span class="p">(</span><span class="n">reg</span><span class="p">,</span><span class="w"> </span><span class="n">uv</span><span class="p">,</span><span class="w"> </span><span class="n">uv</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div>
</li>
</ol>
</li>
<li>
<p><strong>Linux电源管理框架深度解析</strong></p>
<ol>
<li>
<p><strong>Regulator子系统四层架构</strong>：</p>
<div class="highlight"><pre><span></span><code><span class="c1"># 查看regulator状态</span>
ls<span class="w"> </span>/sys/class/regulator/
<span class="c1"># 调节GPIO供电电压</span>
<span class="nb">echo</span><span class="w"> </span><span class="m">1800000</span><span class="w"> </span>&gt;<span class="w"> </span>/sys/class/regulator/regulator.2/microvolts
</code></pre></div>
</li>
<li>
<p><strong>Runtime PM实现机制</strong>：</p>
<div class="highlight"><pre><span></span><code><span class="c1">// 设备驱动示例</span>
<span class="k">static</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="nf">mydev_runtime_suspend</span><span class="p">(</span><span class="k">struct</span><span class="w"> </span><span class="nc">device</span><span class="w"> </span><span class="o">*</span><span class="n">dev</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">struct</span><span class="w"> </span><span class="nc">mydev</span><span class="w"> </span><span class="o">*</span><span class="n">data</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">dev_get_drvdata</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
<span class="w">    </span><span class="n">regulator_disable</span><span class="p">(</span><span class="n">data</span><span class="o">-&gt;</span><span class="n">vcc</span><span class="p">);</span>
<span class="w">    </span><span class="n">clk_disable</span><span class="p">(</span><span class="n">data</span><span class="o">-&gt;</span><span class="n">clk</span><span class="p">);</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="k">struct</span><span class="w"> </span><span class="nc">dev_pm_ops</span><span class="w"> </span><span class="n">mydev_pm_ops</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">SET_RUNTIME_PM_OPS</span><span class="p">(</span><span class="n">mydev_runtime_suspend</span><span class="p">,</span>
<span class="w">                       </span><span class="n">mydev_runtime_resume</span><span class="p">,</span><span class="w"> </span><span class="nb">NULL</span><span class="p">)</span>
<span class="p">};</span>
</code></pre></div>
</li>
<li>
<p><strong>休眠唤醒流程</strong>：</p>
<div class="highlight"><pre><span></span><code>sequenceDiagram
    User Space-&gt;&gt;Kernel: echo mem &gt; /sys/power/state
    Kernel-&gt;&gt;Drivers: suspend_noirq()
    Drivers-&gt;&gt;PMIC: 保存寄存器状态
    PMIC-&gt;&gt;DDR: 进入自刷新模式
    Kernel-&gt;&gt;CPU: 执行WFI
    CPU-&gt;&gt;PMU: 移交控制权
    PMU-&gt;&gt;PMIC: 关闭非必要电源
</code></pre></div>
</li>
</ol>
</li>
<li>
<p><strong>Platform Device电源管理实战</strong></p>
<ol>
<li>
<p><strong>设备树配置</strong>：</p>
<div class="highlight"><pre><span></span><code><span class="nl">gpio_pwr</span><span class="p">:</span><span class="w"> </span><span class="nf">regulator-gpio</span><span class="cm"> </span><span class="p">{</span>
<span class="w">    </span><span class="kr">compatible</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">&quot;regulator-fixed&quot;</span><span class="p">;</span>
<span class="w">    </span><span class="n">regulator-name</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">&quot;gpio-pwr&quot;</span><span class="p">;</span>
<span class="w">    </span><span class="n">gpio</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">&lt;&amp;</span><span class="na">pio</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="mi">5</span><span class="w"> </span><span class="na">GPIO_ACTIVE_HIGH</span><span class="o">&gt;</span><span class="p">;</span>
<span class="w">    </span><span class="n">enable-active-high</span><span class="p">;</span>
<span class="p">};</span>

<span class="nf">my_gpio_device</span><span class="cm"> </span><span class="p">{</span>
<span class="w">    </span><span class="kr">compatible</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">&quot;my,gpio-dev&quot;</span><span class="p">;</span>
<span class="w">    </span><span class="n">vcc-supply</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">&lt;&amp;</span><span class="na">gpio_pwr</span><span class="o">&gt;</span><span class="p">;</span>
<span class="p">};</span>
</code></pre></div>
</li>
<li>
<p><strong>驱动实现关键代码</strong>：</p>
<div class="highlight"><pre><span></span><code><span class="k">struct</span><span class="w"> </span><span class="nc">my_gpio_dev</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">struct</span><span class="w"> </span><span class="nc">regulator</span><span class="w"> </span><span class="o">*</span><span class="n">vcc</span><span class="p">;</span>
<span class="w">    </span><span class="k">struct</span><span class="w"> </span><span class="nc">gpio_chip</span><span class="w"> </span><span class="n">chip</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">static</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="nf">my_gpio_probe</span><span class="p">(</span><span class="k">struct</span><span class="w"> </span><span class="nc">platform_device</span><span class="w"> </span><span class="o">*</span><span class="n">pdev</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">struct</span><span class="w"> </span><span class="nc">my_gpio_dev</span><span class="w"> </span><span class="o">*</span><span class="n">data</span><span class="p">;</span>

<span class="w">    </span><span class="n">data</span><span class="o">-&gt;</span><span class="n">vcc</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">devm_regulator_get</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;vcc&quot;</span><span class="p">);</span>
<span class="w">    </span><span class="n">regulator_set_voltage</span><span class="p">(</span><span class="n">data</span><span class="o">-&gt;</span><span class="n">vcc</span><span class="p">,</span><span class="w"> </span><span class="mi">1800000</span><span class="p">,</span><span class="w"> </span><span class="mi">1800000</span><span class="p">);</span>
<span class="w">    </span><span class="n">regulator_enable</span><span class="p">(</span><span class="n">data</span><span class="o">-&gt;</span><span class="n">vcc</span><span class="p">);</span>

<span class="w">    </span><span class="n">pm_runtime_set_active</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">);</span>
<span class="w">    </span><span class="n">pm_runtime_enable</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="nf">my_gpio_runtime_suspend</span><span class="p">(</span><span class="k">struct</span><span class="w"> </span><span class="nc">device</span><span class="w"> </span><span class="o">*</span><span class="n">dev</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">struct</span><span class="w"> </span><span class="nc">my_gpio_dev</span><span class="w"> </span><span class="o">*</span><span class="n">data</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">dev_get_drvdata</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
<span class="w">    </span><span class="n">regulator_disable</span><span class="p">(</span><span class="n">data</span><span class="o">-&gt;</span><span class="n">vcc</span><span class="p">);</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>
</li>
<li>
<p><strong>电源状态转换验证</strong>：</p>
<div class="highlight"><pre><span></span><code><span class="c1"># 查看设备电源状态</span>
cat<span class="w"> </span>/sys/devices/platform/my_gpio_device/power/runtime_status
<span class="c1"># 手动触发挂起</span>
<span class="nb">echo</span><span class="w"> </span>auto<span class="w"> </span>&gt;<span class="w"> </span>/sys/devices/platform/my_gpio_device/power/control
</code></pre></div>
</li>
</ol>
</li>
<li>
<p><strong>深度调试技巧</strong></p>
<ol>
<li>
<p><strong>Regulator状态跟踪</strong>：</p>
<div class="highlight"><pre><span></span><code><span class="c1"># 监控所有regulator状态变化</span>
ftrace<span class="w"> </span>-p<span class="w"> </span><span class="s1">&#39;regulator_enable regulator_disable&#39;</span>

<span class="c1"># 查看详细电源域信息</span>
<span class="nv">debugfs</span><span class="o">=</span>/sys/kernel/debug/regulator/
cat<span class="w"> </span><span class="nv">$debugfs</span>/regulator_summary
</code></pre></div>
</li>
<li>
<p><strong>唤醒源分析</strong>：</p>
<div class="highlight"><pre><span></span><code><span class="c1"># 查看当前唤醒源配置</span>
cat<span class="w"> </span>/sys/devices/platform/pmic/power/wakeup/wakeup_sources

<span class="c1"># 测试GPIO唤醒功能</span>
<span class="nb">echo</span><span class="w"> </span>enabled<span class="w"> </span>&gt;<span class="w"> </span>/sys/class/gpio/gpioXX/power/wakeup
</code></pre></div>
</li>
</ol>
</li>
<li>
<p><strong>进阶学习建议</strong></p>
<ol>
<li>
<p><strong>ARM PMU机制研究</strong>：</p>
<ul>
<li>阅读ARMv8 Architecture Reference Manual中Power State章节</li>
<li>分析<code>drivers/cpuidle/</code>实现</li>
</ul>
</li>
<li>
<p><strong>PMIC协议逆向</strong>：</p>
<ul>
<li>使用逻辑分析仪捕获I2C通信</li>
<li>解析AXP20x系列数据手册</li>
</ul>
</li>
<li>
<p><strong>相关书籍</strong></p>
<h2 id="-soc">- 《Soc 底层软件低功耗系统设计与实现》——李晓杰</h2>
</li>
<li>
<p><strong>低功耗设计实践</strong>：</p>
<div class="highlight"><pre><span></span><code><span class="c1">// 优化中断唤醒策略</span>
<span class="n">device_init_wakeup</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span><span class="w"> </span><span class="nb">true</span><span class="p">);</span>
<span class="n">enable_irq_wake</span><span class="p">(</span><span class="n">irq</span><span class="p">);</span>
</code></pre></div>
</li>
</ol>
<p>建议结合Allwinner H616 SDK中的<code>axp22x_driver.c</code>和<code>sunxi_pmu.c</code>进行代码级分析，理解从CPU指令到PMIC控制的全链路实现。</p>
</li>
<li>
<p>搜到的一些资料</p>
<p>[<a href="https://www.amobbs.com/thread-4932393-1-1.html">分享][讨论]说说低功耗的那些事儿 2011-12-16 updated (amobbs.com 阿莫电子技术论坛)</a></p>
</li>
</ol>
<blockquote>
<p>结合你的笔记和文档内容，我们从硬件到软件为你梳理电源管理知识体系，并通过一个GPIO设备案例说明如何实现电源管理：</p>
<hr />
<h3 id="_39">一、硬件架构核心概念深化</h3>
<ol>
<li><strong>PMIC与SoC的协作关系</strong>：</li>
<li>PMIC是独立芯片（如AXP系列），通过I2C/SPI与SoC通信</li>
<li>
<p>典型工作流程：
     <div class="highlight"><pre><span></span><code>CPU执行WFI指令 → PMU接管 → PMIC关闭CPU电源 → 维持Always-on域供电
</code></pre></div></p>
</li>
<li>
<p><strong>电源域实战分析</strong>：</p>
</li>
<li>
<p>Allwinner H616设备树示例：
     <div class="highlight"><pre><span></span><code><span class="o">&amp;</span><span class="na">reg_dcdc1</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">regulator-name</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">&quot;vdd-sys&quot;</span><span class="p">;</span>
<span class="w">    </span><span class="n">regulator-min-microvolt</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">&lt;</span><span class="mi">810000</span><span class="o">&gt;</span><span class="p">;</span>
<span class="w">    </span><span class="n">regulator-max-microvolt</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">&lt;</span><span class="mi">1100000</span><span class="o">&gt;</span><span class="p">;</span>
<span class="p">};</span>
</code></pre></div></p>
</li>
<li>
<p>电源域划分原则：</p>
<ul>
<li>Always-on域：RTC、PMIC、关键IO</li>
<li>Shutdown域：CPU核心、外设模块</li>
</ul>
</li>
<li>
<p><strong>动态调压案例</strong>：
   <div class="highlight"><pre><span></span><code><span class="c1">// 调整CPU电压</span>
<span class="kt">int</span><span class="w"> </span><span class="nf">set_cpu_voltage</span><span class="p">(</span><span class="k">struct</span><span class="w"> </span><span class="nc">regulator</span><span class="w"> </span><span class="o">*</span><span class="n">reg</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">uv</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">regulator_set_voltage</span><span class="p">(</span><span class="n">reg</span><span class="p">,</span><span class="w"> </span><span class="n">uv</span><span class="p">,</span><span class="w"> </span><span class="n">uv</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></p>
</li>
</ol>
<hr />
<h3 id="linux_8">二、Linux电源管理框架深度解析</h3>
<ol>
<li>
<p><strong>Regulator子系统四层架构</strong>：
   <div class="highlight"><pre><span></span><code><span class="c1"># 查看regulator状态</span>
ls<span class="w"> </span>/sys/class/regulator/
<span class="c1"># 调节GPIO供电电压</span>
<span class="nb">echo</span><span class="w"> </span><span class="m">1800000</span><span class="w"> </span>&gt;<span class="w"> </span>/sys/class/regulator/regulator.2/microvolts
</code></pre></div></p>
</li>
<li>
<p><strong>Runtime PM实现机制</strong>：
   <div class="highlight"><pre><span></span><code><span class="c1">// 设备驱动示例</span>
<span class="k">static</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="nf">mydev_runtime_suspend</span><span class="p">(</span><span class="k">struct</span><span class="w"> </span><span class="nc">device</span><span class="w"> </span><span class="o">*</span><span class="n">dev</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">struct</span><span class="w"> </span><span class="nc">mydev</span><span class="w"> </span><span class="o">*</span><span class="n">data</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">dev_get_drvdata</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
<span class="w">    </span><span class="n">regulator_disable</span><span class="p">(</span><span class="n">data</span><span class="o">-&gt;</span><span class="n">vcc</span><span class="p">);</span>
<span class="w">    </span><span class="n">clk_disable</span><span class="p">(</span><span class="n">data</span><span class="o">-&gt;</span><span class="n">clk</span><span class="p">);</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
<span class="w">   </span>
<span class="k">static</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="k">struct</span><span class="w"> </span><span class="nc">dev_pm_ops</span><span class="w"> </span><span class="n">mydev_pm_ops</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">SET_RUNTIME_PM_OPS</span><span class="p">(</span><span class="n">mydev_runtime_suspend</span><span class="p">,</span>
<span class="w">                       </span><span class="n">mydev_runtime_resume</span><span class="p">,</span><span class="w"> </span><span class="nb">NULL</span><span class="p">)</span>
<span class="p">};</span>
</code></pre></div></p>
</li>
<li>
<p><strong>休眠唤醒流程</strong>：
   <div class="highlight"><pre><span></span><code>sequenceDiagram
    User Space-&gt;&gt;Kernel: echo mem &gt; /sys/power/state
    Kernel-&gt;&gt;Drivers: suspend_noirq()
    Drivers-&gt;&gt;PMIC: 保存寄存器状态
    PMIC-&gt;&gt;DDR: 进入自刷新模式
    Kernel-&gt;&gt;CPU: 执行WFI
    CPU-&gt;&gt;PMU: 移交控制权
    PMU-&gt;&gt;PMIC: 关闭非必要电源
</code></pre></div></p>
</li>
</ol>
<hr />
<h3 id="platform-device">三、Platform Device电源管理实战</h3>
<p>以GPIO控制器为例说明完整实现：</p>
<ol>
<li>
<p><strong>设备树配置</strong>：
   <div class="highlight"><pre><span></span><code><span class="nl">gpio_pwr</span><span class="p">:</span><span class="w"> </span><span class="nf">regulator-gpio</span><span class="cm"> </span><span class="p">{</span>
<span class="w">    </span><span class="kr">compatible</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">&quot;regulator-fixed&quot;</span><span class="p">;</span>
<span class="w">    </span><span class="n">regulator-name</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">&quot;gpio-pwr&quot;</span><span class="p">;</span>
<span class="w">    </span><span class="n">gpio</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">&lt;&amp;</span><span class="na">pio</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="mi">5</span><span class="w"> </span><span class="na">GPIO_ACTIVE_HIGH</span><span class="o">&gt;</span><span class="p">;</span>
<span class="w">    </span><span class="n">enable-active-high</span><span class="p">;</span>
<span class="p">};</span>
<span class="w">   </span>
<span class="nf">my_gpio_device</span><span class="cm"> </span><span class="p">{</span>
<span class="w">    </span><span class="kr">compatible</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">&quot;my,gpio-dev&quot;</span><span class="p">;</span>
<span class="w">    </span><span class="n">vcc-supply</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">&lt;&amp;</span><span class="na">gpio_pwr</span><span class="o">&gt;</span><span class="p">;</span>
<span class="p">};</span>
</code></pre></div></p>
</li>
<li>
<p><strong>驱动实现关键代码</strong>：
   <div class="highlight"><pre><span></span><code><span class="k">struct</span><span class="w"> </span><span class="nc">my_gpio_dev</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">struct</span><span class="w"> </span><span class="nc">regulator</span><span class="w"> </span><span class="o">*</span><span class="n">vcc</span><span class="p">;</span>
<span class="w">    </span><span class="k">struct</span><span class="w"> </span><span class="nc">gpio_chip</span><span class="w"> </span><span class="n">chip</span><span class="p">;</span>
<span class="p">};</span>
<span class="w">   </span>
<span class="k">static</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="nf">my_gpio_probe</span><span class="p">(</span><span class="k">struct</span><span class="w"> </span><span class="nc">platform_device</span><span class="w"> </span><span class="o">*</span><span class="n">pdev</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">struct</span><span class="w"> </span><span class="nc">my_gpio_dev</span><span class="w"> </span><span class="o">*</span><span class="n">data</span><span class="p">;</span>
<span class="w">       </span>
<span class="w">    </span><span class="n">data</span><span class="o">-&gt;</span><span class="n">vcc</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">devm_regulator_get</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;vcc&quot;</span><span class="p">);</span>
<span class="w">    </span><span class="n">regulator_set_voltage</span><span class="p">(</span><span class="n">data</span><span class="o">-&gt;</span><span class="n">vcc</span><span class="p">,</span><span class="w"> </span><span class="mi">1800000</span><span class="p">,</span><span class="w"> </span><span class="mi">1800000</span><span class="p">);</span>
<span class="w">    </span><span class="n">regulator_enable</span><span class="p">(</span><span class="n">data</span><span class="o">-&gt;</span><span class="n">vcc</span><span class="p">);</span>
<span class="w">       </span>
<span class="w">    </span><span class="n">pm_runtime_set_active</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">);</span>
<span class="w">    </span><span class="n">pm_runtime_enable</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">);</span>
<span class="p">}</span>
<span class="w">   </span>
<span class="k">static</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="nf">my_gpio_runtime_suspend</span><span class="p">(</span><span class="k">struct</span><span class="w"> </span><span class="nc">device</span><span class="w"> </span><span class="o">*</span><span class="n">dev</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">struct</span><span class="w"> </span><span class="nc">my_gpio_dev</span><span class="w"> </span><span class="o">*</span><span class="n">data</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">dev_get_drvdata</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
<span class="w">    </span><span class="n">regulator_disable</span><span class="p">(</span><span class="n">data</span><span class="o">-&gt;</span><span class="n">vcc</span><span class="p">);</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></p>
</li>
<li>
<p><strong>电源状态转换验证</strong>：
   <div class="highlight"><pre><span></span><code><span class="c1"># 查看设备电源状态</span>
cat<span class="w"> </span>/sys/devices/platform/my_gpio_device/power/runtime_status
<span class="c1"># 手动触发挂起</span>
<span class="nb">echo</span><span class="w"> </span>auto<span class="w"> </span>&gt;<span class="w"> </span>/sys/devices/platform/my_gpio_device/power/control
</code></pre></div></p>
</li>
</ol>
<hr />
<h3 id="_40">四、深度调试技巧</h3>
<ol>
<li>
<p><strong>Regulator状态跟踪</strong>：
   <div class="highlight"><pre><span></span><code><span class="c1"># 监控所有regulator状态变化</span>
ftrace<span class="w"> </span>-p<span class="w"> </span><span class="s1">&#39;regulator_enable regulator_disable&#39;</span>
<span class="w">   </span>
<span class="c1"># 查看详细电源域信息</span>
<span class="nv">debugfs</span><span class="o">=</span>/sys/kernel/debug/regulator/
cat<span class="w"> </span><span class="nv">$debugfs</span>/regulator_summary
</code></pre></div></p>
</li>
<li>
<p><strong>唤醒源分析</strong>：
   <div class="highlight"><pre><span></span><code><span class="c1"># 查看当前唤醒源配置</span>
cat<span class="w"> </span>/sys/devices/platform/pmic/power/wakeup/wakeup_sources
<span class="w">   </span>
<span class="c1"># 测试GPIO唤醒功能</span>
<span class="nb">echo</span><span class="w"> </span>enabled<span class="w"> </span>&gt;<span class="w"> </span>/sys/class/gpio/gpioXX/power/wakeup
</code></pre></div></p>
</li>
</ol>
<hr />
<h3 id="_41">五、进阶学习建议</h3>
<ol>
<li><strong>ARM PMU机制研究</strong>：</li>
<li>阅读ARMv8 Architecture Reference Manual中Power State章节</li>
<li>
<p>分析<code>drivers/cpuidle/</code>实现</p>
</li>
<li>
<p><strong>PMIC协议逆向</strong>：</p>
</li>
<li>使用逻辑分析仪捕获I2C通信</li>
<li>
<p>解析AXP20x系列数据手册</p>
</li>
<li>
<p><strong>低功耗设计实践</strong>：
   <div class="highlight"><pre><span></span><code><span class="c1">// 优化中断唤醒策略</span>
<span class="n">device_init_wakeup</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span><span class="w"> </span><span class="nb">true</span><span class="p">);</span>
<span class="n">enable_irq_wake</span><span class="p">(</span><span class="n">irq</span><span class="p">);</span>
</code></pre></div></p>
</li>
</ol>
<p>建议结合Allwinner H616 SDK中的<code>axp22x_driver.c</code>和<code>sunxi_pmu.c</code>进行代码级分析，理解从CPU指令到PMIC控制的全链路实现。</p>
</blockquote>
<h2 id="_42">第四课：网络驱动</h2>
<p>引导问题：网络不通如何定位。（很广泛的问题）</p>
<p>从三个角度来看：</p>
<ul>
<li>协议角度看网络不通</li>
<li>从硬件连接角度看网络不通</li>
<li>从驱动角度看网络不通</li>
</ul>
<h3 id="_43">网络协议栈</h3>
<h3 id="u-boot">u-boot 下的网络驱动</h3>
<h3 id="linux_9">Linux 网络协议栈</h3>
<h4 id="linux_10">Linux 网络驱动</h4>
<h2 id="_44">第五课：调测</h2>
<p>引导问题：调测对系统的影响。</p>
<h3 id="_45">调测方法简述</h3>
<h3 id="_46">适合驱动的调测方法</h3>
<h3 id="linux-50">Linux 5.0 以来重要的更新</h3>







  
    
  
  
    
  


  <aside class="md-source-file">
    
      
  <span class="md-source-file__fact">
    <span class="md-icon" title="Last update">
      <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M21 13.1c-.1 0-.3.1-.4.2l-1 1 2.1 2.1 1-1c.2-.2.2-.6 0-.8l-1.3-1.3c-.1-.1-.2-.2-.4-.2m-1.9 1.8-6.1 6V23h2.1l6.1-6.1zM12.5 7v5.2l4 2.4-1 1L11 13V7zM11 21.9c-5.1-.5-9-4.8-9-9.9C2 6.5 6.5 2 12 2c5.3 0 9.6 4.1 10 9.3-.3-.1-.6-.2-1-.2s-.7.1-1 .2C19.6 7.2 16.2 4 12 4c-4.4 0-8 3.6-8 8 0 4.1 3.1 7.5 7.1 7.9l-.1.2z"/></svg>
    </span>
    <span class="git-revision-date-localized-plugin git-revision-date-localized-plugin-timeago"><span class="timeago" datetime="2025-03-26T07:48:07+01:00" locale="en"></span></span><span class="git-revision-date-localized-plugin git-revision-date-localized-plugin-iso_date">2025-03-26</span>
  </span>

    
    
      
  <span class="md-source-file__fact">
    <span class="md-icon" title="Created">
      <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M14.47 15.08 11 13V7h1.5v5.25l3.08 1.83c-.41.28-.79.62-1.11 1m-1.39 4.84c-.36.05-.71.08-1.08.08-4.42 0-8-3.58-8-8s3.58-8 8-8 8 3.58 8 8c0 .37-.03.72-.08 1.08.69.1 1.33.32 1.92.64.1-.56.16-1.13.16-1.72 0-5.5-4.5-10-10-10S2 6.5 2 12s4.47 10 10 10c.59 0 1.16-.06 1.72-.16-.32-.59-.54-1.23-.64-1.92M18 15v3h-3v2h3v3h2v-3h3v-2h-3v-3z"/></svg>
    </span>
    <span class="git-revision-date-localized-plugin git-revision-date-localized-plugin-timeago"><span class="timeago" datetime="2025-03-26T07:48:07+01:00" locale="en"></span></span><span class="git-revision-date-localized-plugin git-revision-date-localized-plugin-iso_date">2025-03-26</span>
  </span>

    
    
    
  </aside>





                
              </article>
            </div>
          
          
<script>var target=document.getElementById(location.hash.slice(1));target&&target.name&&(target.checked=target.name.startsWith("__tabbed_"))</script>
        </div>
        
      </main>
      
        <footer class="md-footer">
  
    
  
  <div class="md-footer-meta md-typeset">
    <div class="md-footer-meta__inner md-grid">
      <div class="md-copyright">
  
  
    Made with
    <a href="https://squidfunk.github.io/mkdocs-material/" target="_blank" rel="noopener">
      Material for MkDocs
    </a>
  
</div>
      
        <div class="md-social">
  
    
    
    
    
    <a href="https://github.com/JAILuo" target="_blank" rel="noopener" title="JAILuo" class="md-social__link">
      <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 496 512"><!--! Font Awesome Free 6.7.1 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2024 Fonticons, Inc.--><path d="M165.9 397.4c0 2-2.3 3.6-5.2 3.6-3.3.3-5.6-1.3-5.6-3.6 0-2 2.3-3.6 5.2-3.6 3-.3 5.6 1.3 5.6 3.6m-31.1-4.5c-.7 2 1.3 4.3 4.3 4.9 2.6 1 5.6 0 6.2-2s-1.3-4.3-4.3-5.2c-2.6-.7-5.5.3-6.2 2.3m44.2-1.7c-2.9.7-4.9 2.6-4.6 4.9.3 2 2.9 3.3 5.9 2.6 2.9-.7 4.9-2.6 4.6-4.6-.3-1.9-3-3.2-5.9-2.9M244.8 8C106.1 8 0 113.3 0 252c0 110.9 69.8 205.8 169.5 239.2 12.8 2.3 17.3-5.6 17.3-12.1 0-6.2-.3-40.4-.3-61.4 0 0-70 15-84.7-29.8 0 0-11.4-29.1-27.8-36.6 0 0-22.9-15.7 1.6-15.4 0 0 24.9 2 38.6 25.8 21.9 38.6 58.6 27.5 72.9 20.9 2.3-16 8.8-27.1 16-33.7-55.9-6.2-112.3-14.3-112.3-110.5 0-27.5 7.6-41.3 23.6-58.9-2.6-6.5-11.1-33.3 2.6-67.9 20.9-6.5 69 27 69 27 20-5.6 41.5-8.5 62.8-8.5s42.8 2.9 62.8 8.5c0 0 48.1-33.6 69-27 13.7 34.7 5.2 61.4 2.6 67.9 16 17.7 25.8 31.5 25.8 58.9 0 96.5-58.9 104.2-114.8 110.5 9.2 7.9 17 22.9 17 46.4 0 33.7-.3 75.4-.3 83.6 0 6.5 4.6 14.4 17.3 12.1C428.2 457.8 496 362.9 496 252 496 113.3 383.5 8 244.8 8M97.2 352.9c-1.3 1-1 3.3.7 5.2 1.6 1.6 3.9 2.3 5.2 1 1.3-1 1-3.3-.7-5.2-1.6-1.6-3.9-2.3-5.2-1m-10.8-8.1c-.7 1.3.3 2.9 2.3 3.9 1.6 1 3.6.7 4.3-.7.7-1.3-.3-2.9-2.3-3.9-2-.6-3.6-.3-4.3.7m32.4 35.6c-1.6 1.3-1 4.3 1.3 6.2 2.3 2.3 5.2 2.6 6.5 1 1.3-1.3.7-4.3-1.3-6.2-2.2-2.3-5.2-2.6-6.5-1m-11.4-14.7c-1.6 1-1.6 3.6 0 5.9s4.3 3.3 5.6 2.3c1.6-1.3 1.6-3.9 0-6.2-1.4-2.3-4-3.3-5.6-2"/></svg>
    </a>
  
</div>
      
    </div>
  </div>
</footer>
      
    </div>
    <div class="md-dialog" data-md-component="dialog">
      <div class="md-dialog__inner md-typeset"></div>
    </div>
    
    
    <script id="__config" type="application/json">{"base": "../../..", "features": ["navigation.footer"], "search": "../../../assets/javascripts/workers/search.6ce7567c.min.js", "translations": {"clipboard.copied": "Copied to clipboard", "clipboard.copy": "Copy to clipboard", "search.result.more.one": "1 more on this page", "search.result.more.other": "# more on this page", "search.result.none": "No matching documents", "search.result.one": "1 matching document", "search.result.other": "# matching documents", "search.result.placeholder": "Type to start searching", "search.result.term.missing": "Missing", "select.version": "Select version"}}</script>
    
    
      <script src="../../../assets/javascripts/bundle.83f73b43.min.js"></script>
      
        <script src="../../../js/timeago.min.js"></script>
      
        <script src="../../../js/timeago_mkdocs_material.js"></script>
      
        <script src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
      
    
  </body>
</html>